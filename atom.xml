<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>阿菁菁菁菁菁</title>
  <subtitle>Change takes time.</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://lijingjing.top/"/>
  <updated>2017-05-09T13:52:36.000Z</updated>
  <id>http://lijingjing.top/</id>
  
  <author>
    <name>阿菁菁菁菁菁</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>《Node.js实战》读书笔记（一）</title>
    <link href="http://lijingjing.top/blog/2017/05/09/%E3%80%8ANode-js%E5%AE%9E%E6%88%98%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>http://lijingjing.top/blog/2017/05/09/《Node-js实战》读书笔记（一）/</id>
    <published>2017-05-09T12:24:52.000Z</published>
    <updated>2017-05-09T13:52:36.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>一个搭建在Chrome JavaScript运行时上的平台，用于构建高速、可伸缩的网络程序。Node.js采用的事件驱动、非阻塞I/O模型，使它既轻便又高效，并成为构建运行在分布式设备上的数据密集型实时程序的完美选择。</p>
</blockquote>
<h3 id="构建于JavaScript之上"><a href="#构建于JavaScript之上" class="headerlink" title="构建于JavaScript之上"></a>构建于JavaScript之上</h3><p>在服务器端编程，Node使用的是位Google Chrome提供动力的V8虚拟机，V8让Node在性能上得到了巨大的提升，因为它丢掉了中间环节，执行的不是字节码，用的也不是解释器，而是直接编译成了本地机器码。Node在服务器端使用JS的其他好处：</p>
<ol>
<li>减少开发客户端和服务端时所需的语言切换，代码还可以子啊客户端和服务端共享。</li>
<li>JSON是目前非常流行的数据交换格式，并且还是JS原生的。</li>
<li>有些NoSQL数据库用的就是JS语言，比如CouchDB和MongoDB。</li>
<li>JS是一门编译目标语言，现在有很多可以编译成JS的语言。<a href="https://github.com/jashkenas/coffeescript/wiki/List-of-languages-that-compile-to-js" target="_blank" rel="external">点击查看具体列表</a></li>
<li>Node用的是虚拟机（V8）会紧跟ECMAScript标准，即在Node中如果想用新的JS语言特性，不用等到所有浏览器都支持。</li>
</ol>
<h3 id="异步和事件触发：浏览器"><a href="#异步和事件触发：浏览器" class="headerlink" title="异步和事件触发：浏览器"></a>异步和事件触发：浏览器</h3><p>Node为服务端JS提供了一个事件驱动的、异步的平台。它把JS带到服务端中的方式跟浏览器把JS带到客户端的方式几乎一样，它们都是<strong>事件驱动（用事件轮询）和非阻塞的I/O处理（异步I/O）</strong>。</p>
<p>事件轮询和异步I/O：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$.post(<span class="string">'/resource.json'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</div><div class="line">	cnsole.log(data);</div><div class="line">&#125;);</div><div class="line"><span class="comment">//脚本继续执行，上面的I/O不会阻塞当前JS线程</span></div></pre></td></tr></table></figure></p>
<p>浏览器是单线程的，当浏览器中有I/O操作时，该操作会留在事件轮询的外面执行（脚本执行的主程序之外），然后当这个I/O操作完成时，会发出一个“事件”，会有一个函数（通常称为“回调”）处理它。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> data = $.post(<span class="string">'/resource.json'</span>);<span class="comment">//在I/O完成之前程序会被阻塞</span></div><div class="line"><span class="built_in">console</span>.log(data);</div></pre></td></tr></table></figure>
<h3 id="异步和事件触发：服务器"><a href="#异步和事件触发：服务器" class="headerlink" title="异步和事件触发：服务器"></a>异步和事件触发：服务器</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$result = mysql_query(<span class="string">'SELECT * FROM myTable'</span>);</div><div class="line">print_r($result);</div></pre></td></tr></table></figure>
<p>这段代码做了些I/O操作，并且在所有数据回来之前，这个进程会被阻塞。同时，这个进程也有状态，或者说内存空间，并且在I/O完成之前基本上什么也不做。根据I/O操作的延迟情况，可能会有10ms到几分钟的时间。延迟也可能是以下意外情况引发：</p>
<ol>
<li>硬盘正在执行维护操作，读/写都暂停了。</li>
<li>因为负载增加，数据库查询变得更慢了。</li>
<li>由于某种资源，从一个域名下拉取资源非常迟缓。</li>
</ol>
<p>如果程序在I/O上阻塞了，当有更多请求过来时，服务器一般会用多线程的方式进行解决。一种常见的实现是给每个连接分配一个线程，并为那些连接设置一个线程池。可以把线程想象成一个计算工作区，处理器在这个工作区中完成指定的任务。线程通常都是出于进程之内的，并且会维护它自己的工作内存。每个线程会处理一到多个服务器连接。当需要大量的线程处理很多并发的服务器连接时，线程会消耗额外的操作系统资源，线程需要CPU和额外的RAM来做上下文切换。</p>
<p>NGINX和Apache一样，是一个HTTP服务器，但它用的不是带有阻塞I/O的多线程方式，而是带有异步I/O的事件轮询。因为这些设计上的选择，NGNIX通常能处理更多的请求和客户端连接，它因此变成了响应能力更强的解决方案。<br>在Node中，I/O几乎总是在主事件轮询之外进行，使得服务器可以一直处于高效并且随时能够做出响应的状态，就像NGINX一样。这样进程就更加不会受I/O限制，因为I/O延迟不会拖垮服务器，或者像在阻塞方式下那样占用很多资源。因此一些服务器上曾经是重量级的操作，在Node服务器上仍然可以是轻量级的。</p>
<h3 id="DIRT程序"><a href="#DIRT程序" class="headerlink" title="DIRT程序"></a>DIRT程序</h3><p>Node针对的应用程序为DIRT（data-intensive real-time），表示数据密集型实时程序。因为Node自身在I/O上比较轻便，善于将数据从一个管道混排或代理到另一个管道上，这能在处理大量请求时持有很多开发的连接，并且只占用一小部分内存，它的设计目标是保证响应能力，跟浏览器一样。</p>
<p>现在有很多Web程序提供的信息几乎都是即时的，比如通过白板在线协作、对临近公交车的实时精确定位以及多人在线游戏。不管是用实时组件增强已有程序，还是打造全新的程序，Web都在朝响应型和协作型环境逐渐进发，而这种新型Web应用程序需要一个能够实时响应大量并发用户请求的平台来支撑它们。这正是Node所擅长的领域，并且不仅限于web程序，其他I/O负载比较重的程序也可以用到它。</p>
<p><a href="https://www.browserling.com/" target="_blank" rel="external">Browserling</a>是一个用Node开发的DIRT程序。在这个网站上，可以在浏览器中使用各种浏览器。Browserling用了一个叫做StackVM的由Node驱动的项目，而StackVM管理了用QEMU模拟器创建的虚拟机，QEMU会模拟运行浏览器所需的CPU和外设。</p>
<p>Browserling在VM中运行测试浏览器，将键盘和鼠标的输入数据从用户的浏览器中转到模拟出来的浏览器中，然后将模拟浏览器中要重新渲染的区域转出来，在用户浏览器的画布上重新画出来。</p>
<h3 id="默认DIRT"><a href="#默认DIRT" class="headerlink" title="默认DIRT"></a>默认DIRT</h3><p>Node从创建开始就有一个事件驱动和异步模型。JS从来没有标准的I/O库，那是服务端语言的常见配置。对于JS而言，这是由“宿主”环境决定的。JS的宿主环境，大多数为浏览器，它是事件驱动和异步的。</p>
<p>Node重新实现了宿主中那些常用的对象，尽量让浏览器和服务器保持一致。比如：计时器API（setTimeOut）和控制台API（console.log）</p>
<p>Node还有一组用来处理多种网络和文件I/O的核心模块。其中包括用于HTTP、TLS、HTTPS、文件系统（POSIX）、数据报（UDP）和NET（TCP）的模块。这些核心模块很小、底层并且简单，只包含要给基于I/O的程序用的组成部分。第三方模块基于这些核心模块，针对常见的问题进行了更高层的抽象。</p>
<p><strong>平台与框架</strong>：Node是JS程序的平台。Express是Node中流行的框架。</p>
<h3 id="流数据"><a href="#流数据" class="headerlink" title="流数据"></a>流数据</h3><p>Node在数据流和数据流动上也很强大，可以把数据流看成特殊的数组，只不过数据中的数据分散在空间上，而数据流中的数据时分散在时间上的。通过将数据一块一块地传送，开发人员可以每收到一块数据就开始处理，而不用等所有数据都到全了再做处理。用数据流的方式处理resource.json如下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> stream = fs.createReadStream(<span class="string">'./resource.json'</span>);</div><div class="line">stream.on(<span class="string">'data'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">chunk</span>)</span>&#123;</div><div class="line">	<span class="built_in">console</span>.log(chunk);</div><div class="line">&#125;);</div><div class="line">stream.on(<span class="string">'end'</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">	<span class="built_in">console</span>.log(<span class="string">'finished'</span>);</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>只要有新的数据块准备好，就会激发data事件，当所有数据块都加载完后，会激发一个end事件。由于数据类型不同，数据块的大小可能会发生变化。有了对读取流的底层访问，程序就可以边读取边处理，这要比等着所有数据都缓存到内存中再处理效率高得多。</p>
<p>Node也有可写数据流，可以往里面写数据块。当HTTP服务器上有请求过来时，对其进行响应的res对象就是可写数据流的一种。<br>可读和可写数据流可以连接起来形成管道，就像shell脚本中用的<code>|</code>（管道）操作符一样。这是一种高效的数据处理方式，只要有数据准备好就可以处理，不用等着读取完整个资源再把它写出去。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</div><div class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</div><div class="line">http.createServer(<span class="function"><span class="keyword">function</span>(<span class="params">req,res</span>) </span>&#123;</div><div class="line">	res.writeHead(<span class="number">200</span>,&#123;<span class="string">'Content-Type'</span>: <span class="string">'image/png'</span>&#125;);</div><div class="line">	fs.createReadStream(<span class="string">'./image.png'</span>).pipe(res);</div><div class="line">&#125;).listen(<span class="number">3000</span>);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(<span class="string">"Server running at http://localhost:3000/"</span>);</div></pre></td></tr></table></figure></p>
<p>在上面代码中，数据从文件中读进来（<code>fs.createReadStream</code>），然后数据随着进来就被送到(<code>.pipe()</code>)客户端（res）。在数据流动时，时间轮询还能处理其他事件。</p>
<p>Node在多个平台上均默认提供了DIRT方式，包括各种Windows和类UNIX系统。底层的I/O库（libuv）特意屏蔽了宿主操作系统的差异性，提供了统一的使用方式，如果需要的话，程序可以在多个设备上轻松移植和运行。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>Node是：</p>
<ol>
<li>构建在JavaScript上的。</li>
<li>事件触发和异步的。</li>
<li>专为数据密集型实时程序设计的。</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;一个搭建在Chrome JavaScript运行时上的平台，用于构建高速、可伸缩的网络程序。Node.js采用的事件驱动、非阻塞I/O模型，使它既轻便又高效，并成为构建运行在分布式设备上的数据密集型实时程序的完美选择。&lt;/p&gt;
&lt;/blockquo
    
    </summary>
    
      <category term="Web开发" scheme="http://lijingjing.top/categories/Web%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="Node" scheme="http://lijingjing.top/tags/Node/"/>
    
  </entry>
  
  <entry>
    <title>《HTML5实战》读书笔记（一）</title>
    <link href="http://lijingjing.top/blog/2017/05/05/HTML5%E5%AE%9E%E6%88%98/"/>
    <id>http://lijingjing.top/blog/2017/05/05/HTML5实战/</id>
    <published>2017-05-05T06:29:33.000Z</published>
    <updated>2017-05-09T13:55:32.000Z</updated>
    
    <content type="html"><![CDATA[<p>HTML5的新语义元素，能够让搜索引擎或辅助技术（如屏幕阅读器）更好地理解页面。</p>
<h3 id="HTML5引入的新表单特性"><a href="#HTML5引入的新表单特性" class="headerlink" title="HTML5引入的新表单特性"></a>HTML5引入的新表单特性</h3><p>HTML5引入的新表单输入类型：</p>
<table>
<thead>
<tr>
<th>输入类型</th>
<th></th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>color</td>
<td>date</td>
<td>datetime</td>
<td>datetime-local</td>
<td>email</td>
</tr>
<tr>
<td>month</td>
<td>number</td>
<td>range</td>
<td>search</td>
<td>tel</td>
</tr>
<tr>
<td>time</td>
<td>url</td>
<td>week</td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<p>HTML5引入的输入元素属性</p>
<table>
<thead>
<tr>
<th>输入元素类型</th>
<th></th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>autocomplete</td>
<td>autofocus</td>
<td>list</td>
<td>max</td>
<td>min</td>
</tr>
<tr>
<td>multiple</td>
<td>pattern</td>
<td>required</td>
<td>step</td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td>palceholder</td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<p><strong>不能单纯依靠客户端验证，无论是HTML5新增的浏览器原生验证，还是JS验证代码，它们都不可靠。由于可以很容易绕过客户端验证，服务端验证输入是不可或缺的。客户端验证主要应该用在改善用户体验上，并不能用作保障应用绝对安全的手段。</strong></p>
<h3 id="进度条、度量器和可折叠内容"><a href="#进度条、度量器和可折叠内容" class="headerlink" title="进度条、度量器和可折叠内容"></a>进度条、度量器和可折叠内容</h3><p><code>&lt;progress&gt;</code>: 向用户呈现确定或不确定的进度条。确定的进度条有指定数值，进度条的进度由该值确定，所以很适用于显示文件上传进度（随着文件上传量，动态地改变进度条数值）。不确定进度条则没有明确的数值，进度条会完全充满，在不确定操作进度的情况下，应用这种进度条，用户可以知道应用正在加载。<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">progress</span> <span class="attr">value</span>=<span class="string">"50"</span> <span class="attr">max</span>=<span class="string">"100"</span>&gt;</span><span class="tag">&lt;/<span class="name">progress</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">progress</span>&gt;</span><span class="tag">&lt;/<span class="name">progress</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p><code>&lt;meter&gt;</code>：与<code>&lt;progress&gt;</code>相似。<code>&lt;progress&gt;</code>主要用于展示任务的完成度（百分比），而<code>&lt;meter&gt;</code>则能展示在已知的标量范围内的数据变化。也可以定义low,high和optimum这些范围的关键点参数。<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">meter</span> <span class="attr">min</span>=<span class="string">"0"</span> <span class="attr">max</span>=<span class="string">"10"</span> <span class="attr">low</span>=<span class="string">"3"</span> <span class="attr">high</span>=<span class="string">"7"</span> <span class="attr">optimum</span>=<span class="string">"9"</span> <span class="attr">value</span>=<span class="string">"0"</span>&gt;</span><span class="tag">&lt;/<span class="name">meter</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>无需JS，使用<code>&lt;details&gt;</code>和<code>&lt;summary&gt;</code>创建可折叠内容。以前创建可折叠内容，需要利用JS切换内容部分的CSS属性，才能实现内容的隐藏和出现。H5利用<code>&lt;details&gt;</code>和<code>&lt;summary&gt;</code>元素可达到相同的效果。<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">details</span>&gt;</span></div><div class="line">	<span class="tag">&lt;<span class="name">summary</span>&gt;</span>Section Heading<span class="tag">&lt;/<span class="name">summary</span>&gt;</span></div><div class="line">	This is an example of using &amp;lt; details &amp;gt; and &amp;lt; summary &amp;gt; to create collapsible content without using JS.</div><div class="line"><span class="tag">&lt;/<span class="name">details</span>&gt;</span></div></pre></td></tr></table></figure></p>
<h3 id="附加的Web规范"><a href="#附加的Web规范" class="headerlink" title="附加的Web规范"></a>附加的Web规范</h3><p>H5不再是只包含那些描述文档结构的标记，还包含了更多的特性及其相关规范，用以确保Web应用的视觉效果和用户体验。</p>
<p>微数据（Microdata），可以为文档添加额外语义，以后还可以取回并修改它们。<br>CSS3，改进后的样式表，可以为Web页面添加最新的样式及效果，而不必再依赖外部图像或JS技巧来实现。</p>
<h4 id="微数据"><a href="#微数据" class="headerlink" title="微数据"></a>微数据</h4><p>利用H5的微数据，可以为Web页面添加语义信息；另一方面，搜索引擎和浏览器也可以通过微数据，向用户提供额外的功能。</p>
<p>通过读取HTML文档中的微数据，google向用户提供了更为完善的搜索结果。Web页面若应用了微数据，Google就能为网站或应用提供相似的搜索结果列表。</p>
<p>要想使用微数据，需要一个词汇表，它要定义出你所用到的语义。词汇表可以自定义，但是一般会使用已经发布的词汇表。eg:google发布的词汇表(www.data-vocabulary.org)。通过已经发布的词汇表，能够保证搜索引擎及其他应用能够始终如一地理解微数据。</p>
<table>
<thead>
<tr>
<th>方法（属性）</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>document.getItems([types])</td>
<td>获取顶级微数据项的所有元素，也就是那些带有itemscope属性的元素，可以用types参数来过滤返回一个或多个itemtype属性值</td>
</tr>
<tr>
<td>element.properties</td>
<td>为一个指定的微数据项(element)获取所有的项属性（带有itemprop属性的元素）</td>
</tr>
<tr>
<td>element.itemValue[=value]</td>
<td>获取或设置项目属性的值</td>
</tr>
</tbody>
</table>
<h3 id="H5的DOM-API"><a href="#H5的DOM-API" class="headerlink" title="H5的DOM API"></a>H5的DOM API</h3><h4 id="Canvas"><a href="#Canvas" class="headerlink" title="Canvas"></a>Canvas</h4><p>Canvas API定义了一个2D内容，为在画布上进行绘制提供了一些方法。这些方法能够创建形状、定义路径、使用颜色与渐变、使用文本等等。另外，开发者还可以通过数据URL或Blob对象，将当前画布内容导出为PNG或JPG格式的图像。</p>
<h4 id="音频与视频"><a href="#音频与视频" class="headerlink" title="音频与视频"></a>音频与视频</h4><p><code>&lt;video&gt;</code>和<code>&lt;audio&gt;</code>这两个元素都支持<code>&lt;track&gt;</code>元素，从而可以添加如字幕这样的附加文本。通过使用<code>&lt;source&gt;</code>元素，还可以提供多种文件格式，从而能够以多种系统和浏览器访问同一内容。H5还提供了一种可以控制音频及视频回放的API。利用该API所包含的各种方法，播放，暂停，快进，快退，调整音量等功能都可以实现。</p>
<h4 id="拖放功能"><a href="#拖放功能" class="headerlink" title="拖放功能"></a>拖放功能</h4><p>H5中，使用某一个元素的draggable属性，即可使该元素（如图像，默认）具备可拖放功能。当用户拖动元素进入或离开其他元素时，甚至当用户放下元素时，你可以利用一系列的事件来监听这些改变。借助拖放API，可以设定与拖动操作的相关数据，当放下时再进行读取。H5还实现了文件的拖动。如Gmail中将文件添加到当前消息中。</p>
<h4 id="跨文档通信、服务器端发送的事件以及WebSockets"><a href="#跨文档通信、服务器端发送的事件以及WebSockets" class="headerlink" title="跨文档通信、服务器端发送的事件以及WebSockets"></a>跨文档通信、服务器端发送的事件以及WebSockets</h4><h5 id="利用跨文档通信与通道通信实现客户端通信"><a href="#利用跨文档通信与通道通信实现客户端通信" class="headerlink" title="利用跨文档通信与通道通信实现客户端通信"></a>利用跨文档通信与通道通信实现客户端通信</h5><p>跨文档通信可以让各文档通过消息来进行沟通——一个文档发布消息，而另一个文档利用注册的事件处理器来侦听这些消息。</p>
<p>跨文档通信比较安全，由于能够跨域运作，所以无需暴露每一个Web应用的DOM即能实现消息在各个应用间的传播。</p>
<h5 id="利用服务器发送事件实现从服务器端到客户端的单向通信"><a href="#利用服务器发送事件实现从服务器端到客户端的单向通信" class="headerlink" title="利用服务器发送事件实现从服务器端到客户端的单向通信"></a>利用服务器发送事件实现从服务器端到客户端的单向通信</h5><p>对于两个客户端之间的通信来说，跨文档通信是很好的方式。但是，如果想让Web服务器发送的消息能被浏览器接收，则需要用到服务器端发送事件。</p>
<p>利用EventSource接口，你的Web应用能够订阅一个服务器端事件流，它只接收服务器发送的更新消息。与过去使用的难以实现的AJAX长轮询方式相比，这是一个非常大的改进。</p>
<p>非常适合聊天应用，利用AJAX发布新的聊天消息，然后通过事件流接收来自其他用户的聊天消息。</p>
<h5 id="使用WebSocket实现服务器端与客户端的双向通信"><a href="#使用WebSocket实现服务器端与客户端的双向通信" class="headerlink" title="使用WebSocket实现服务器端与客户端的双向通信"></a>使用WebSocket实现服务器端与客户端的双向通信</h5><p>如果需要双向通信，H5还提供了WebSocket，这是客户端与服务器端之间的一种最基本的网络技术，没有与HTTP相关的开销。WebSocket很适合快速传送小规模数据。对于在线游戏和时间敏感性极高的财务系统来说，这种特性非常关键。</p>
<h5 id="文档编辑"><a href="#文档编辑" class="headerlink" title="文档编辑"></a>文档编辑</h5><p>H5提供了两种新属性，可以实现在HTML页面内进行富文本编辑。一个是contenteditable属性，它可以在页面的任何一个HTML元素中设置，从而使该元素具备可编辑性；另一个是designMode，在HTML文档自身设置，使整个文档都编程可编辑状态。</p>
<p>当元素或文档可编辑时，可以用HTML5的Editing DOM API的方法document.execCommand来操纵其内容。该方法能应用于当前选择或区块，可以实现粗体、斜体、插入链接等特性。</p>
<h5 id="Web存储"><a href="#Web存储" class="headerlink" title="Web存储"></a>Web存储</h5><p>一直以来，Web应用都在用cookie将数据存储在客户端，它们能在一次会话或多个会话中维持。这就是Web认证技术的底层技术：在客户端存储cookie含有一些标识符，Web应用借此可以识别登录的用户。Cookie有很多问题，导致它们只能存储极少量的数据。</p>
<p>第一个问题在于，大多数浏览器都将cookie限制在4096字节内，每个域最多只能存储20个cookie。限额一旦达到，浏览器就会将旧cookie删除，以便为新cookie腾出空间，这就意味着浏览器无法保存所有cookie。<br>另一个问题在于，当Web应用使用cookie时，每一个针对该会话的HTTP请求都会带有cookie，从而加重了每一个事务的负担。因为每个HTTP请求都将带有所有cookie发送出去，这就减慢了页面加载速度与应用作出的AJAX请求。</p>
<p>因此Web Storage DOM API为Web应用提供了一个能够替代cookie的JS解决方案。这一API定义了以下两个接口。<br>sessionStorage —— 客户端数据存储，只能维持在当前会话范围内。<br>localStorage —— 客户端数据存储，能维持在多个会话范围内。</p>
<p>该API公开的方法能把简单的键值对数据存储在客户端。使用这些接口的已存储数据项只能被同一域内的页面所访问。虽然该API能够存储兆（M）级数据，但复杂的数据结构并不适用于此，而通常是存储到数据库中。</p>
<p></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;HTML5的新语义元素，能够让搜索引擎或辅助技术（如屏幕阅读器）更好地理解页面。&lt;/p&gt;
&lt;h3 id=&quot;HTML5引入的新表单特性&quot;&gt;&lt;a href=&quot;#HTML5引入的新表单特性&quot; class=&quot;headerlink&quot; title=&quot;HTML5引入的新表单特性&quot;&gt;&lt;/a
    
    </summary>
    
      <category term="前端" scheme="http://lijingjing.top/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="HTML5" scheme="http://lijingjing.top/tags/HTML5/"/>
    
  </entry>
  
  <entry>
    <title>响应式Web设计性能优化</title>
    <link href="http://lijingjing.top/blog/2017/04/16/%E5%93%8D%E5%BA%94%E5%BC%8FWeb%E8%AE%BE%E8%AE%A1%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    <id>http://lijingjing.top/blog/2017/04/16/响应式Web设计性能优化/</id>
    <published>2017-04-16T05:54:13.000Z</published>
    <updated>2017-04-16T13:52:11.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="响应式设计现状"><a href="#响应式设计现状" class="headerlink" title="响应式设计现状"></a>响应式设计现状</h3><h4 id="反模式"><a href="#反模式" class="headerlink" title="反模式"></a>反模式</h4><h5 id="为所有设备加载同样的内容"><a href="#为所有设备加载同样的内容" class="headerlink" title="为所有设备加载同样的内容"></a>为所有设备加载同样的内容</h5><p>为手机和桌面渲染加载完全一样的资源，加载同样的CSS文件，通过媒体查询给不同的分辨率设备提供不同的体验，加载同样的图片，通过缩放来解决不同分辨率下的显示需要。</p>
<p>会在HTTP拥堵时造成性能急剧下降，且考虑更大分辨率的显示设备如苹果饿Retina显示屏以及超高清电视时，这种解决方案不能很好地扩展显示。</p>
<h5 id="加载额外的资源"><a href="#加载额外的资源" class="headerlink" title="加载额外的资源"></a>加载额外的资源</h5><p>在手机端除了加载通用资源外，加载一些额外的CSS以及sprite文件等其他额外的资源。造成手机体验中会发送比桌面体验下发送更多的HTTP请求。</p>
<h5 id="加载双倍的图片"><a href="#加载双倍的图片" class="headerlink" title="加载双倍的图片"></a>加载双倍的图片</h5><p>有些站点会为手机版本加载另外一组图片，如此一来，图片文件的大小就是桌面图片的两倍了。</p>
<p>以上问题有几个共同的哲学思想：</p>
<ol>
<li>它们明显都是着眼于桌面版本，并以此作为基础，在其上修改或新增元素，而不是从最小版本往上开发。</li>
<li>它们都没有利用各个平台的优势，也没有意识到各个平台的限制。</li>
<li>它们都试图仅从客户端来解决问题。</li>
</ol>
<h4 id="模式"><a href="#模式" class="headerlink" title="模式"></a>模式</h4><h5 id="加载适合相应设备的资源"><a href="#加载适合相应设备的资源" class="headerlink" title="加载适合相应设备的资源"></a>加载适合相应设备的资源</h5><p>针对手机端加载相比桌面端一半大小的图片，使用设备独有的sprite图和CSS，并不是在桌面程序的基础上为其他设备增加其他资源。</p>
<h5 id="从后端提供专有的体验"><a href="#从后端提供专有的体验" class="headerlink" title="从后端提供专有的体验"></a>从后端提供专有的体验</h5><p>针对不同的设备提供完全不同的专有体验。有些站点提供了独立的“m.”网站，另外一些网站展示的是从服务端传输过来的基于设备独有布局和功能的页面。这种解决方案我们称之为<strong>RESS（响应式设计+服务端组件）</strong>。</p>
<h5 id="前端延迟加载的专有体验"><a href="#前端延迟加载的专有体验" class="headerlink" title="前端延迟加载的专有体验"></a>前端延迟加载的专有体验</h5><p>有些站点不仅对图片进行延迟加载，而且对整个内容模块也进行延迟加载，包括上方和下方的折叠部分。通过这种方式，可以有效地避免为每个断点加载内容，智能地加载那些需要的内容，从而适应客户端性能，达到最佳体验。但是是否延迟加载的决定权在客户端，问不是在服务端。</p>
<h3 id="初识Web应用性能"><a href="#初识Web应用性能" class="headerlink" title="初识Web应用性能"></a>初识Web应用性能</h3><h4 id="性能度量基础"><a href="#性能度量基础" class="headerlink" title="性能度量基础"></a>性能度量基础</h4><p>当提及网站和Web应用的性能的时候，我们说的要么是Web性能，要么是运行时性能。我们将Web性能定义为，一个终端用户从请求一段内容开始到这段内容显示在用户设备上这段时间的度量值。将运行时性能定义为，应用在运行时对用户输入响应能力的一个标示。</p>
<p>将性能指标类型分为以下几类：</p>
<ol>
<li>定量指标： 可以通过实验进行度量的一种目标（如某个东西的数量）</li>
<li>定性指标： 不能通过实验度量的一种目标（如某个东西的质量）</li>
<li>先行指标： 用于预测结果</li>
<li>输入指标：用户度量某个过程中消耗的资源</li>
</ol>
<h5 id="什么是Web性能"><a href="#什么是Web性能" class="headerlink" title="什么是Web性能"></a>什么是Web性能</h5><p>想想每次浏览网页的过程。打开浏览器，键入URL，然后等待网页加载。从键入URL后按下回车键（或是从书签列表中点击某个书签，亦或是点击页面中的某个链接），到页面渲染，这之间消耗的时间就是所浏览页面的Web性能。若站点运行正常，这个时间甚至不应该被人感受到。</p>
<p>Web性能的定量指标数不胜数：</p>
<ol>
<li>页面加载时间</li>
<li>页面文件大小</li>
<li>HTTP请求数</li>
<li>页面渲染时间</li>
</ol>
<p><strong>页面是如何到达浏览器并展现给用户的？</strong></p>
<ol>
<li>当通过浏览器请求一个Web页面，浏览器会创建一个线程去处理这个请求，随后开始远程DNS查找，远程DNS服务器将你输入的URL对应的IP地址返回给浏览器。</li>
<li>接着，浏览器通过与远程Web服务端的三次握手来建立一个TCP/IP连接。这个握手由浏览器与远程服务端之间的SYN、SYN-ACK以及ACK消息组成。</li>
<li>TCP连接建立之后，浏览器同构连接发送一个HTTP GET请求到Web服务端。Web服务端找到请求的资源，然后再HTTP响应中将其返回，状态200表示响应正常。如果服务端找不到请求的资源或是解析资源的过程中出错，亦或是资源被重定向，HTTP响应状态也会反映出这些情况。</li>
<li>当浏览器收到页面的HTML后，就开始解析并渲染页面内容。</li>
<li>浏览器用其渲染引擎来解析和渲染内容。</li>
</ol>
<p>一些常见的状态码：</p>
<ul>
<li>200 表示服务端成功响应</li>
<li>301 表示永久重定向</li>
<li>302 表示临时重定向</li>
<li>401 表示未授权</li>
<li>403 表示请求被拒绝</li>
<li>404 表示服务端找不到请求的资源</li>
<li>500 表示处理请求时出错</li>
<li>503 表示服务不可用</li>
<li>504 表示网关超时</li>
</ul>
<p>加载一个HTML页面不知需要一次这个过程，浏览器还要为页面链接的每个资源发起一个HTTP请求-所有的图片，链接的CSS和JS文件以及其他类型的外部资源（<strong>只要后续的HTTP请求链接的是相同的源，浏览器就可以重用相应的TCP链接</strong>）。</p>
<p>现有的浏览器架构由几个关联的模块组成：<br><strong>UI层</strong><br>这一层为浏览器绘制界面。有些元素，如地址栏。刷新按钮以及用户界面上的（UI）的其他元素是浏览器自身的。<br><strong>网络层</strong><br>该层处理网络连接，承担的职责有建立TCP连接以及处理HTTP的往返过程。网络层处理内容下载，然后将内容传递给渲染引擎。<br><strong>渲染引擎</strong><br>渲染引擎负责将内容绘制到显示器上。浏览器制造商会将他们的渲染引擎以及JS引擎打上商标并对外授权。最流行的渲染引擎是webkit/chrome(Blink)/Safari/Opera以及其他浏览器都用到了webkit。当渲染引擎遇到了JS，会将其传递给JS解释器。<br><strong>JS引擎</strong><br>JS引擎会解析并执行JS。如果渲染引擎，浏览器制造商给他们的JS打上商标并授权，一个流行的JS引擎是V8，Node.js就是用它作为引擎的。</p>
<p><strong>用户在浏览器键入一个URL后发生了什么？</strong></p>
<ul>
<li>UI层将这个请求传递给网络层，网络层随后建立连接，然后下载初始页面。当含有HTML块的数据包到达，就被传递给渲染引擎。渲染引擎将HTML组装成原始文本，然后对文本中的字符开始进行词法分析或解析。这些字符会与一个规则集相比较，我们在HTML文档中指定的文档类型定义（DTD），然后转换成基于规则集的符号。DTD规定了一系列标签，这些标签组成了我们将要使用的语言版本。这些标签就是由一些被分割成有意义片段的字符组成。</li>
<li>渲染引擎拿到这些符号后，将它们转换成文档对象类型（DOM）元素，DOM是页面元素的内存表现形式，也是JS用于访问页面元素的API。DOM元素被布局成一棵渲染树，渲染引擎会迭代该树。首次迭代中，渲染引擎会布局好DOM元素的位置，下一次迭代就将这些元素绘制到屏幕上。</li>
<li>如果渲染层在解析和符号化过程中发现了<code>&lt;script&gt;</code>标签，就会暂停下来然后评估接下来要进行的处理。如果<code>&lt;script&gt;</code>标签指向一个外部的JS文件，解析过程暂停，随后网络层接入，下载JS文件，然后初始化JS引擎解析，执行该文件。如果<code>&lt;script&gt;</code>标签包含的是内嵌的JS，渲染引擎暂停，JS引擎被初始化，内嵌的JS会被解析与执行。执行完成后，之前暂停的渲染过程会恢复运行。</li>
</ul>
<h5 id="性能指标"><a href="#性能指标" class="headerlink" title="性能指标"></a>性能指标</h5><ul>
<li>HTTP请求数<br>当浏览器获取HTML页面时会创建一个HTTP请求，还会创建更多的HTTP请求来获取页面中链接的每个资源。根据网络延迟情况，每个HTTP请求都会使总的页面加载时间增加20~200毫秒（如果考虑可以并行加载资源的浏览器，这个数字会有所不同）。如果只是少量的资源，这些额外的加载时间可以忽略不计，但如果是100个或更多的HTTP请求，将会显著增大总体的Web性能的延迟。</li>
</ul>
<p>减少页面需要的HTTP请求数，开发者可以有很多办法，比如将不同的CSS或JS文件合并成单个文件，将常用的图片合并成单个的称之为sprite的图片文件。</p>
<ul>
<li><p>页面加载<br>影响Web性能的因素之一是页面的总文件大小。总负载包括组成该页面的HTML、CSS以及JS累计的文件大小。还包括所有的图片、cookie以及其他潜在页面中的媒体。</p>
</li>
<li><p>页面加载时间<br>HTTP请求数以及总的页面负载本身只是输入，但Web性能方面需要关注的真正KPI是页面加载时间。</p>
</li>
</ul>
<p>压面加载时间是最明显的性能指标，也最容易被量化。简而言之，它是从浏览器下载并渲染所有页面内容的时间。以前度量的是从页面请求到页面（窗口加载，window onload）事件之间消耗的时间。最近，由于开发者越来越喜欢在页面完成加载之前就提供好的用户体验，这样度量结束的时间点就会移动，甚至完全改变。</p>
<p>特别是，在一些用例中，window.onload事件出发后，可以动态加载内容，比如，如果内容是延迟加载的，就会出现这种情况，并且有一些用例，在window.onload事件触发之前页面就是可用的，看起来也是完整的（先加载内容，然后再加载广告）。这些用例会降低依靠window.onload事件追踪特定页面加载时间的有效性。</p>
<h4 id="Web运行时性能"><a href="#Web运行时性能" class="headerlink" title="Web运行时性能"></a>Web运行时性能</h4><p>Web性能跟踪的是内容传递到用户的耗时。Web运行时性能，跟踪的是用户与应用交互时应用的行为。</p>
<p>对于传统的编译类型的应用，运行时性能是有关内存管理、垃圾回收以及线程等各个方面的。这是因为变一类的应用运行在内核之上，直接使用系统资源。</p>
<p>在客户端运行Web应用与运行编译类应用是大不相同的。这是因为Web应用运行在沙盒中，即运行在浏览器中。当它们运行时，用的是浏览器的资源。而浏览器的资源是运行在它事先从内核中分配的内存资源中的。所以，当我们提到Web运行时性能，我们实际上说的是应用是怎样在客户端的浏览器运行，以及让浏览器在虚拟内存中其自身的内存里执行。</p>
<p>我们需要考虑到的影响Web运行时性能的因素：</p>
<ul>
<li><p>内存管理与垃圾回收<br>首先要看的是，我们有没有因为太多无用的对象以及创建更多对象时仍保留这些无用对象而导致浏览器的内存分配被阻塞。<br>随着时间的推移，我们是否有什么机制限制JS中的对象创建，或应用用的越多越久时，内存消耗是否也越多，是否存在内存泄露？<br>回收无用对象可能会导致浏览器在渲染或播放动画的时候暂停，容易在用户体验上出现锯齿现象。我们可以通过减少创建的对象数量以及可能重用已有对象来将垃圾回收次数降到最少。</p>
</li>
<li><p>布局<br>我们更新DOM的时候是否引发了页面重绘？这一般是由于大范围的样式变化，需要渲染引擎重新计算页面元素的大小和位置。</p>
</li>
<li><p>高代价的绘制<br>当用户滚动页面时，我们有没有因为绘制一些区域而加重浏览器的负担？动画效果或是更新除了位置、缩放、旋转或透明度之外的任意元素属性，都将引起渲染引擎重绘对应元素并消耗时间。位置、缩放、旋转以及透明度是渲染引擎最后配置的元素属性，所以，更新这些属性只需极小的开销。<br>如果我们在宽度、高度、背景或者其他属性上使用动画，渲染引擎就需要重新考虑页面的布局并且重绘那个元素，这就会在渲染和动画过程中消耗更多的时间。更糟的是，如果我们引起了父元素的重绘，渲染引擎就需要重绘所有的子元素，严重影响运行时性能。</p>
</li>
<li><p>同步调用</p>
</li>
<li><p>CPU占用率<br>我们要查看的Web运行时性能指标是每秒的帧数和CPU的占用率。</p>
</li>
</ul>
<p><strong>每秒帧数（FPS）</strong>：是系统重绘屏幕的速率。人类感觉动作平滑、逼真的理想帧率是60FPS。 FPS还是浏览器的一个重要性能指标，因为其反映出了动画运行以及窗口滚动的平滑程度。滚动时出现锯齿（卡顿）已经是Web性能问题的一个明显标志。<br><strong>内存分析</strong>：内存分析是监控我们应用所用到的内存消耗模式的一种方法，这对检测内存泄露与不会销毁的对象创建非常有用——JS中，当我们用程序为DOM对象指定事件处理器，而后又忘了将事件处理器移除时尤为常见。内存分析对优化内存占用也很有用。</p>
<p><img src="/images/window-performance.jpeg" alt="window.performance"></p>
<h3 id="千里之行始于计划"><a href="#千里之行始于计划" class="headerlink" title="千里之行始于计划"></a>千里之行始于计划</h3><h3 id="响应式服务端实现"><a href="#响应式服务端实现" class="headerlink" title="响应式服务端实现"></a>响应式服务端实现</h3><h4 id="Web栈"><a href="#Web栈" class="headerlink" title="Web栈"></a>Web栈</h4><p>Web栈是一系列栈的集合。<br><strong>网络栈</strong><br>网络栈是由不同网络系统相互通信的一系列协议的统称，它由下面一些层构成：</p>
<ol>
<li><strong>数据链路层</strong>： 数据链路层对应的是硬件连接到网络的标准方式。对我们而言，通常是以太网的形式，具体是支持IEEE 802.3标准的物理互联设备；或者也可以通过WiFi，即支持802.11标准的无线互联设备。</li>
<li><strong>网络层</strong>：网络层对应的是网络中不同网络节点之间相互识别和通信的标准，具体是IP协议或者互联网协议。它是通过IP地址在网络中识别网络节点，并且在主机之间通过数据包的形式传递数据。</li>
<li><strong>传输层</strong>：传输层通常相当于TCP，全称是Transmission Control Protocol，也就是传输控制协议。TCP是用来在主机之间建立链接的协议。IP协议负责将数据以数据包的形式进行传输，而TCP将数据包分成多个段，并且为每个段创建含有目标IP地址的header，重新组装并且对接收到的这些网络传输数据进行校验。</li>
<li><strong>应用层</strong>：应用层是这一系列协议的最上层，它对应的是像HTTP这样的协议，HTTP也成为超文本传输协议。HTTP的标准是IETF RFC2616。HTTP是一种Web语言，主要由Request/Response两个动作组成。</li>
</ol>
<p><strong>HTTP请求</strong><br>一个HTTP请求由两部分组成：请求正文和一系列请求header。其中，请求正文包括请求的HTTP方法或者动作，以及请求远程资源的URI。简单来说，它表明了当前要执行的动作（获取文件，发送文件或者获取一个文件的信息）以及这个动作在哪执行（文件或者资源的地址路径），下面是一些在HTTP1.1中支持的方法：</p>
<ol>
<li>OPTIONS：服务器支持的HTTP请求方法的功能选项。</li>
<li>GET：当你请求远程资源时，如果你在HTTP header中指定了If-Modified-Since/If-Unmodified-Since/If-Match/If-None-Match或者If-Range里的一项，那么它就变成一个有条件的GET了。因为在这个时候，服务器只返回符合这些请求条件的资源。一般来说，如果你想控制获取资源的方式，是获取最新的资源还是使用当前缓存的时候，就可以使用这种有条件的GET。</li>
<li>HEAD：只请求远程资源的HTTP header，它主要是用来检查最后更改的日期或者确认一个URI是否可用。</li>
<li>POST：请求服务器对一个资源进行更新或者修改。</li>
<li>PUT：请求服务器创建一个新的资源。</li>
<li>DELETE：请求服务器删除一个资源。</li>
</ol>
<p>一些请求header：</p>
<ol>
<li>Host：在URI中指定的域名名称</li>
<li>If-Modified-Since：这个参数在Request header中传给服务器，指示服务器只返回在指定的时间里有过更新的资源。如果资源已经更新过了，那么服务器就返回这个资源和200状态码。如果没有，那么服务器返回304状态码。</li>
<li>User-Agent：这个参数标识客户端的具体特征信息，</li>
</ol>
<p><strong>HTTP响应</strong><br>当服务器接收并处理了一个请求以后，它将会返回客户端一个响应信息，和HTTP请求一样，HTTP响应也由两个部分组成：状态行和响应header的属性。</p>
<p>状态行中有协议版本号（HTTP 1.1），状态码和描述请求状态的文本短语，状态码由三位数字组成，并且把响应分成了五个层次类别。状态码的第一位数字表示它的类别。具体类别如下所示：<br>1xx:信息 —— 请求已收到，正在处理中。<br>2xx:成功 —— 请求已经成功接收、解析并执行了。<br>3xx:重定向 —— 需要进一步的跳转和更多的操作来完成当前请求。<br>4xx:客户端错误 —— 请求包含了语法错误，不能被执行。<br>5xx:服务端错误 —— 服务端在处理一个有效的请求时失败。</p>
<p>响应header里的属性值和请求header里的属性值很像，服务端通过指定这一系列的键值对表明当前响应的具体信息。下面是一些常用的响应header：</p>
<ol>
<li>Age: 标识请求的资源从创建或更新时到请求发生时的大概时间。</li>
<li>ETag: 列出服务器为这个资源分配的唯一实体标记符，这个参数在一些需要额外匹配验证的时候非常有用。</li>
<li>Vary: 这个参数标明当前请求的哪个请求头用来表示该请求是否可以被缓存。这个参数很重要，因为它让我们可以将User Agent头信息作为一个请求是否可以被缓存的决定因素之一。</li>
</ol>
<p><strong>Web应用栈</strong><br>绝大部分情况下，Web应用是基于客户端-服务器模式的，也可以将其看成是一个分布式计算方式。用一句话来总结就是，客户端向服务器端请求数据，服务端处理请求和响应。通常情况下，为了可扩展性，这些服务器分布在整个网络中。</p>
<p>假设浏览器就是客户端，Web服务器就是server。当我们说Web服务器时，指的是像Apache和微软的IIS这样的应用软件，或者是运行这些软件的硬件。</p>
<p>这些Web服务器监听某些特定的端口——表示应用端口的数字，也就是HTTP请求的端口。通常情况下，HTTP请求的是80端口，HTTPS请求的是403端口。当Web服务器接收到这个请求的时候，它就会把这个请求发送给对应的资源。</p>
<p>类似于Ruby或者PHP，或者像HTML页面这样的静态内容，这些资源可以再服务端以代码的形式进行评估和解析。无论哪种方式，这个被发送的请求都会获得服务端的响应。</p>
<p>如果服务端响应的正文是HTML文件，HTML将在客户端设备上进行解析和渲染，如果内容中包含了任何JS文件，它们也会被客户端设备解释运行。</p>
<h4 id="服务端响应"><a href="#服务端响应" class="headerlink" title="服务端响应"></a>服务端响应</h4><p>在整个栈中，第一件事应该做的是判断出客户端的相关特性。现在，响应式设计是客户端获取服务端发送HTTP响应后，在客户端根据获取到的相应的客户端特性，然后根据这些特性对响应的内容进行接收、解析和渲染等一系列操作。<strong>在服务器端根据客户端特性发送针对设备专有的代码而不是全部的代码。</strong></p>
<p><strong>检查User Agent</strong><br>在发送请求时，请求的header里会自动添加user-agent属性<br><img src="/images/user-agent.jpeg" alt="user-agent"></p>
<p><strong>Wurfl</strong><br>Wurfl全称是无限通用资源文件（Wireless Universal Resource File）。<br>Wurfl Cloud —— 提供API访问设备数据库；<br>Wrufl Onsite —— 本地安装的设备数据库；<br>Wrufl Infuze —— 在服务端通过环境变量保证Wurfl数据库的可用性。</p>
<p>最好的解决方案是Wrufl Infuze，因为当查询设备数据时没有产生文件I/O和传输延迟的额外消耗。<br>然而门槛最低的解决方案是WurflCloud，因为它不需要内部主机，不需要安装基础设施，甚至还有免费的选项。</p>
<h4 id="缓存的影响"><a href="#缓存的影响" class="headerlink" title="缓存的影响"></a>缓存的影响</h4><p>在开发大型网站时，我们常常会依赖于缓存减轻我们的服务器压力。当我们把响应式移到服务端但又缓存了响应时，问题便出现了，无论从客户端传来什么样的User Agent信息，我们将只看到当前缓存的版本而无法看到最新的响应。</p>
<p>为了解决这个问题，我们可以在发送响应的时候使用Vary这个HTTP响应header参数。当有请求进来的时候，服务端会基于User Agent的值做一些判断，然后决定哪些响应需要缓存起来。</p>
<p><strong>大多数的CDN在使用Vary Response header的时候都不会缓存，如果你的CDN也会这样，你需要针对这种情况有相应的替代方案。可能需要使用Edge Side Includes将User Agent的检查逻辑移到CDN的边缘层。</strong></p>
<h4 id="Edge-Side-Include"><a href="#Edge-Side-Include" class="headerlink" title="Edge Side Include"></a>Edge Side Include</h4><p>CDN</p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>如何尽快从最早的请求中获取客户端设备功能？最重要的是如何尽快对响应进行处理？<br>为了回答这个文艺，我们重点对请求的HTTP请求中的UserAgent进行检测，甚至使用了第三方的设备检测服务，比如Wurlf。<br>不过这个解决方案的一个潜在的风险就是如何处理缓存内容。一个解决方式就是使用响应header中的Vary参数。缓存服务器通过UserAgent决定哪一种响应需要缓存起来。另外一种方式就是通过使用ESI，把我们的设备或者能力检测逻辑从我们的服务器移到CDN edge服务器上。</p>
<p>不管哪一种解决方案，只要我们将响应式的处理在服务端解决，避免客户端加载所有的响应式相关代码，避免提供两份相同内容或者无效内容的反模式，就可以减少向客户端传送的负载，取而代之的是一种更精简、更合理的响应方式，所以这种实现方式更好。</p>
<h3 id="响应式前端实现"><a href="#响应式前端实现" class="headerlink" title="响应式前端实现"></a>响应式前端实现</h3><p>上一章展示了如何将响应式规范从客户端迁移到服务端。这个过程包括两个方面：第一，从服务端加载符合设备特性的内容和提供专有的体验；第二，避免加载所有设备内容的反模式。这样做可以有效降低页面的父子啊，减少客户端设备渲染页面的整体时间。</p>
<p>如果基础设施、商业模式或者团队技术深度不能够有效地支持服务端的解决方案，那该如何做呢？<br>可以从单纯的客户端解决方案中获得相近的性能提升。</p>
<h4 id="图片操作"><a href="#图片操作" class="headerlink" title="图片操作"></a>图片操作</h4><p>调查表明，对页面负载影响最大的就是页面上的图片。所以，在客户端提高响应式性能，优化移动设备客户端的图片传输非常重要。</p>
<h5 id="SRCSET属性"><a href="#SRCSET属性" class="headerlink" title="SRCSET属性"></a>SRCSET属性</h5><p>通过srcset属性，<img>标签可以为不同客户端设备的不同像素比指定不同的图片。</p>
<p><strong>设备像素比</strong><br>设备像素比是指物理像素和设备独立像素之间的比例。典型的例子就是iPad Retina屏，包含更多信息的像素或者设备独立像素，实际上它的真是像素宽度是2048。所以iPad Retina屏显示的设备像素比的计算公式为：<br>【设备独立像素】/【物理像素】，即 2048/1024 = 2;</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"1x.jpg"</span> <span class="attr">srcset</span>=<span class="string">"2x.jpg 2x"</span>&gt;</span></div></pre></td></tr></table></figure>
<p>上面的代码中，<img>标签有个默认的图片1x.jpg，这主要是为了向后兼容，防止浏览器不支持srcset属性。如果设备像素比是2，那么我们设置的srcset属性和它指定的图片就会起作用。</p>
<p>浏览器使用的设备像素比的值，可以使用window.devicePixelRatio属性来获取。</p>
<p>使用srcset的缺点：<br>必须指定可能需要的所有不同的图片，这会额外增加发送的字节数，从而增加额外的负载。但是可以把像素比的映射关系放到服务端来完成来针对这个问题进行优化。</p>
<p>使用srcset的优点：<br>除了可以让你指定设备的特定使用的多个图像，而无需加载多余的图像之外，还有就是现代的浏览器已经开始支持这个属性了。</p>
<h5 id="picture属性"><a href="#picture属性" class="headerlink" title="picture属性"></a>picture属性</h5><p>处理响应式图片的另外一个可选性技术是使用<picture>元素。<picture>元素是HTML5中新增的一个元素。从概念上讲，它是一个容器元素，包含了多种不同的源标签，基于不同的视口宽度像素密度指定不同的图片，它也可以容纳一个img标签进行优雅降级。</picture></picture></p>
<p><source>属性支持media属性，使用它可以指明要关注的媒体类型和目标CSS属性。source元素还有src属性，使用这个属性来指明针对目标的媒体类型和CSS属性所随影要下载的图片。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">picture</span>&gt;</span></div><div class="line">	<span class="tag">&lt;<span class="name">source</span> <span class="attr">media</span> = <span class="string">"(min-width: 640px, min-device-pixel-ratio:2)"</span> <span class="attr">src</span>=<span class="string">"hi-res_small.jpg"</span>&gt;</span></div><div class="line">	<span class="tag">&lt;<span class="name">source</span> <span class="attr">media</span> = <span class="string">"(min-width: 2048px, min-device-pixel-ratio:2)"</span> <span class="attr">src</span>=<span class="string">"hi-res_large.jpg"</span>&gt;</span></div><div class="line">	<span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"1x.png"</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">picture</span>&gt;</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">&lt;!--&lt;picture&gt;同样可以支持srcset属性--&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">picture</span>&gt;</span></div><div class="line">	<span class="tag">&lt;<span class="name">source</span> <span class="attr">srcset</span>=<span class="string">"big.jpg 1x, big-2x.jpg 2x, big-3x.jpg 3x"</span> <span class="attr">type</span>=<span class="string">"image/jpeg"</span> <span class="attr">media</span> = <span class="string">"(min-width: 40em)"</span>&gt;</span></div><div class="line">	<span class="tag">&lt;<span class="name">source</span> <span class="attr">srcset</span>=<span class="string">"big.jpg 1x, big-2x.jpg 2x, big-3x.jpg 3x"</span> <span class="attr">type</span>=<span class="string">"image/jpeg"</span>&gt;</span></div><div class="line">	<span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"1x.png"</span> <span class="attr">alt</span>=<span class="string">"fancy pants"</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">picture</span>&gt;</span></div></pre></td></tr></table></figure>
<h5 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h5><p>不管是srcset属性还是<picture>元素，它们都是我们可能用到的解决方案。如果从性能的角度来比较两种方案，我们会发现，在理论上，它们只会下载最适合客户端设备特性的资源，但是<picture>元素很明显比使用了srcset属性的<img>标签更冗长。</picture></picture></p>
<p>如果我们想对它们使用的字节数进行量化比较，以上述代码为例，使用srcset属性的<img>标签使用了95个字节，而<picture>元素使用了231个字节，srcset属性的方式比<picture>元素的方式节约了近60%的字节数。所以当页面中<img>标签很多时，这种差距是不能忽视的。</picture></picture></p>
<h4 id="延迟加载"><a href="#延迟加载" class="headerlink" title="延迟加载"></a>延迟加载</h4><p>如何在客户端使用某一个策略——在页面渲染时只加载适用于该设备的资源？<br>答案是使用延迟加载。</p>
<p>使用延迟加载，它会在真正需要的时候才会去加载相关的内容。一个延迟加载的例子就是无限滚动：只有真正需要显示的内容才会被显示到“显著位置”（设备中展示在屏幕范围内的内容），当用户向下滑动后，更多的内容才会被下载并渲染显示到屏幕上。<br>因此，我们第一次需要加载HTML语义结构的股价，然后根据客户端的特性，延迟加载相应的CSS和JS。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">&lt;script&gt;</div><div class="line">	<span class="built_in">window</span>.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">		<span class="keyword">var</span> client = determineClient();</div><div class="line">		<span class="keyword">var</span> section = [<span class="string">"head"</span>,<span class="string">"body"</span>,<span class="string">"client"</span>];</div><div class="line">		<span class="keyword">for</span>(<span class="keyword">var</span> n = <span class="number">0</span>; n &lt; sections.length; n++) &#123;</div><div class="line">			loadSection(n,client);</div><div class="line">		&#125;</div><div class="line">		</div><div class="line">		<span class="function"><span class="keyword">function</span> <span class="title">loadSection</span>(<span class="params">n,client</span>) </span>&#123;</div><div class="line">			<span class="keyword">var</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</div><div class="line">			xhr.open(<span class="string">"get"</span>,client.sectionURLs[section],<span class="literal">true</span>);</div><div class="line">			xhr.send();</div><div class="line">			xhr.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">				<span class="built_in">document</span>.getElementById(xhr.section).innerHTML = xhr.responseText;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		</div><div class="line">		<span class="function"><span class="keyword">function</span> <span class="title">determineClient</span>(<span class="params"></span>)</span>&#123;</div><div class="line">		 ...</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&lt;<span class="regexp">/script&gt;</span></div></pre></td></tr></table></figure>
<p><strong>浏览器默认的延迟加载项</strong><br>浏览器将自动延迟加载CSS背景图。如果display属性被设置成none,那么背景图片只有当display属性设置成visible的时候才会被加载。这是页面中延迟加载默认图片的另外一种使用策略。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;响应式设计现状&quot;&gt;&lt;a href=&quot;#响应式设计现状&quot; class=&quot;headerlink&quot; title=&quot;响应式设计现状&quot;&gt;&lt;/a&gt;响应式设计现状&lt;/h3&gt;&lt;h4 id=&quot;反模式&quot;&gt;&lt;a href=&quot;#反模式&quot; class=&quot;headerlink&quot; title=
    
    </summary>
    
      <category term="读书笔记" scheme="http://lijingjing.top/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="性能优化" scheme="http://lijingjing.top/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>Angular服务</title>
    <link href="http://lijingjing.top/blog/2017/04/08/Angular%E6%9C%8D%E5%8A%A1/"/>
    <id>http://lijingjing.top/blog/2017/04/08/Angular服务/</id>
    <published>2017-04-08T04:12:32.000Z</published>
    <updated>2017-04-09T12:49:05.000Z</updated>
    
    <content type="html"><![CDATA[<p>服务提供了一种能在应用的整个生命周期内保持数据的方法，它能够在控制器之间进行通信，并且能保证数据的一致性。</p>
<p>服务是一个<strong>单例对象</strong>，在每个应用中只会被实例化一次（被$injector实例化），并且是延迟加载的（需要时才会被创建）。实例化后，injector会一直缓存创建好的实例对象的引用以便之后的使用。服务提供了把与特定功能相关联的方法集中在一起的接口。</p>
<p>在Angular中创建自己的服务很容易，只需要注册这个服务即可。服务被注册后，AngularJS编译器就可以引用它，并且在运行时把它当作依赖加载进来。服务名称的注册表使得在测试中伪造和剔除相互隔离的应用依赖变得非常容易。</p>
<p>可以在控制器、指令、过滤器或另外一个服务中通过依赖声明的方式来使用服务。Angular会像平时一样在运行期自动处理实例化和依赖加载的相关事宜。<br>将服务的名字当作参数传递给控制器函数，可以将服务注入到控制器中。当服务成为了某个控制器的依赖，就可以在控制器中调用任何定义在这个服务对象上的方法。eg:在所有页面之间共享用户名等数据，可以创建一个service在每个controller里注册这个service，添加对其的依赖，就可以获取之前设置过的用户名等数据。</p>
<h3 id="创建服务"><a href="#创建服务" class="headerlink" title="创建服务"></a>创建服务</h3><p>在Angular中，factory()是用来注册服务最常规的方式，公有5种方法用来创建服务：</p>
<ol>
<li>factory()</li>
<li>service()</li>
<li>constant()</li>
<li>value()</li>
<li>provider()<h4 id="factory"><a href="#factory" class="headerlink" title="factory()"></a>factory()</h4>factory()方法是创建和配置服务最快捷的方式，其接收两个参数：</li>
</ol>
<p><strong>name(String)</strong>:需要注册的服务名；<br><strong>getFn(Function)</strong>:这个函数会在AngularJS创建服务实例时被调用。可以返回简单类型、函数，甚至对象等任意类型的数据。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">angular.module(<span class="string">"myApp"</span>)</div><div class="line">.factory(<span class="string">'myService'</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">	<span class="keyword">return</span> &#123;</div><div class="line">		<span class="string">'username'</span> : <span class="string">'auser'</span></div><div class="line">	&#125;;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>因为服务是单例对象，getFn在应用的生命周期内只会被调用一次。<br>同其他AngularJS的服务一样，在定义服务时，getFn可以接受一个包含可被注入对象的数组或函数。</p>
<h4 id="service"><a href="#service" class="headerlink" title="service()"></a>service()</h4><p>使用service()可以注册一个<strong>支持构造函数</strong>的服务，它允许我们为服务对象注册一个构造函数。<br>service()接受两个参数：<br><strong>name(String)</strong>:要注册的服务名称<br><strong>constructor(Function)</strong>:构造函数，我们调用它来实例化服务对象</p>
<p>service()函数会在创建实例时通过new关键字来实例化服务对象。遵循constructor injection的设计模式。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> Person = <span class="function"><span class="keyword">function</span>(<span class="params">$http</span>) </span>&#123;</div><div class="line">	<span class="keyword">this</span>.getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">		<span class="keyword">return</span> $http (&#123;<span class="attr">method</span>: <span class="string">'GET'</span>, <span class="attr">url</span>: <span class="string">'/api/user'</span>&#125;);</div><div class="line">	&#125;</div><div class="line">&#125;;</div><div class="line">angular.service(<span class="string">'personService'</span>, Person);</div><div class="line"></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">UnicornLauncher</span>(<span class="params">apiToken</span>) </span>&#123;</div><div class="line"></div><div class="line">  <span class="keyword">this</span>.launchedCount = <span class="number">0</span>;</div><div class="line">  <span class="keyword">this</span>.launch = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="comment">// Make a request to the remote API and include the apiToken</span></div><div class="line">    ...</div><div class="line">    this.launchedCount++;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">//使用factory()</span></div><div class="line">myApp.factory(<span class="string">'unicornLauncher'</span>, [<span class="string">"apiToken"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">apiToken</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="keyword">new</span> UnicornLauncher(apiToken);</div><div class="line">&#125;]);</div><div class="line"><span class="comment">//使用service()是最合适的，创建实例时会自动通过new操作符来实例化对象</span></div><div class="line">myApp.service(<span class="string">'unicornLauncher'</span>, [<span class="string">"apiToken"</span>, UnicornLauncher]);<span class="comment">//需要的参数可以通过依赖来添加</span></div></pre></td></tr></table></figure>
<h4 id="provider"><a href="#provider" class="headerlink" title="provider()"></a>provider()</h4><p>所有服务工厂都是由<code>$provide</code>服务创建的，<code>$provide</code>服务负责在运行时初始化这些提供者。</p>
<p>提供者是一个具有<code>$get()</code>方法的对象，<code>$injector</code>通过调用<code>$get</code>方法创建服务实例。<code>$provide</code>提供了数个不同的API用于创建服务，每个方法都有各自的特殊用途。</p>
<p>所有创建服务的方法都构建在provider方法智商。provide()方法负责在<code>$providerCache</code>中注册服务。</p>
<p>从技术上来说，当我们假定传入的函数就是$get()时，factory()函数就是用provider()方法注册服务的简略形式。</p>
<p>下面两种方法的作用完全一样，并且会创建同一个服务。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">angular.module(<span class="string">'myApp'</span>)</div><div class="line">.factory(<span class="string">'myService'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">	<span class="keyword">return</span> &#123;</div><div class="line">		<span class="string">'username'</span> : <span class="string">'auser'</span></div><div class="line">	&#125;</div><div class="line">&#125;)</div><div class="line"></div><div class="line">.provider(<span class="string">'myService'</span>, &#123;</div><div class="line">	<span class="attr">$get</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">		<span class="keyword">return</span> &#123;</div><div class="line">			<span class="string">'username'</span> : <span class="string">'auser'</span></div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>是否可以一直使用.factory()方法来替代.provider()？<br>答案取决于你是否需要用AngularJS的.config()函数来对.provider()方法返回的服务进行额外的扩展配置。同其他创建服务的方法不同，config()方法可以被注入特殊的参数。</p>
<p>比如，我们希望在应用启动前配置githubService的URL：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">angular.module(<span class="string">'myApp'</span>, [])</div><div class="line">.provider(<span class="string">'githubService'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">$http</span>) </span>&#123;</div><div class="line"><span class="comment">//默认的，私有状态</span></div><div class="line">	<span class="keyword">var</span> githubUrl = <span class="string">'http://github.com'</span></div><div class="line">	</div><div class="line">	setGithubUrl: <span class="function"><span class="keyword">function</span>(<span class="params">url</span>) </span>&#123;</div><div class="line">	<span class="comment">//通过.config改变默认属性</span></div><div class="line">		<span class="keyword">if</span>(url) &#123;</div><div class="line">			githubUrl = url;</div><div class="line">		&#125;</div><div class="line">	&#125;,</div><div class="line">	<span class="attr">method</span>: JSONP,<span class="comment">//如果需要可以重写</span></div><div class="line">	</div><div class="line">	$get: <span class="function"><span class="keyword">function</span>(<span class="params">$http</span>) </span>&#123;</div><div class="line">		self = <span class="keyword">this</span>;</div><div class="line">		<span class="keyword">return</span> $http(&#123;</div><div class="line">			<span class="attr">method</span>: self.method,</div><div class="line">			<span class="attr">url</span>: githubUrl + <span class="string">'/events'</span></div><div class="line">		&#125;);</div><div class="line">	&#125;</div><div class="line">&#125;)</div></pre></td></tr></table></figure></p>
<p>在上面的例子中，provider()方法在文本githubService后添加Provider生成了一个新的提供者，githubServiceProvider可以被注入到config()函数中。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">angular.module(<span class="string">'myApp'</span>,[])</div><div class="line">.config(<span class="function"><span class="keyword">function</span>(<span class="params">githubServiceProvider</span>)</span>&#123;</div><div class="line">	githubServiceProvider.setGithubUrl(<span class="string">"git@github.com"</span>);</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p><strong>如果希望在config()函数中可以对服务进行配置，必须用provider()来定义服务。</strong></p>
<p>通过使用.provider()方法，可以在多个应用使用同一个服务时获得更强的扩展性，特别是在不同应用或开源社区之间共享服务时。</p>
<p>provider()方法为服务注册提供者。可以接受两个参数：<br><strong>name(String)</strong>:name参数在providerCache中是注册的名字。nameProvider会成为服务的提供者，同时name也是服务实例的名字。eg: 如果定义了一个githubService,那么它的提供者就是githubServiceProvider。<br><strong>aProvider</strong>:如果aProvider是<strong>函数</strong>，那么它会通过依赖注入被调用，并且负责通过<code>$get</code>方法返回一个对象；如果aProvider是<strong>数组</strong>，会被当作一个带有行内依赖注入声明的函数来处理。数组的最后一个元素应该是函数，可以返回一个带有<code>$get</code>方法的对象；如果aProvider是<strong>对象</strong>，它应该带有<code>$get</code>方法。<br>provider()函数返回一个已经注册的提供者实例。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">angular.module(<span class="string">'myApp'</span>,[])</div><div class="line">.provider(<span class="string">'userService'</span>,&#123;</div><div class="line">	<span class="attr">favoriteColor</span>: <span class="literal">null</span>,</div><div class="line">	<span class="attr">setFavoriteColor</span> : <span class="function"><span class="keyword">function</span>(<span class="params">newColor</span>) </span>&#123;</div><div class="line">		<span class="keyword">this</span>.favoriteColor = newColor;</div><div class="line">	&#125;,</div><div class="line">	<span class="attr">$get</span>: <span class="function"><span class="keyword">function</span>(<span class="params">$http</span>) </span>&#123;</div><div class="line">		<span class="keyword">return</span> &#123;</div><div class="line">			<span class="string">'name'</span> : <span class="string">'Ari'</span>,</div><div class="line">			<span class="attr">getFavoriteColor</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">				<span class="keyword">return</span> <span class="keyword">this</span>.favoriteColor || <span class="string">'unknown'</span>;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p>直接使用provider()API是最原始的创建服务的方法，用provider()方法必须返回一个定义有<code>$get()</code>函数的对象，否则会导致错误。</p>
<p>可以通过注入器来实例化服务(由于AngularJS会处理服务的实例化，我们不用自己手动实例化)。</p>
<h4 id="constant"><a href="#constant" class="headerlink" title="constant()"></a>constant()</h4><p>可以将一个已经存在的变量值注册为服务，并将其注入到应用的其他部分中。在AngularJS生命周期的配置阶段和运行阶段均可以被访问。其余服务要在运行阶段才可以被访问，即在配置阶段config()是不可以访问其他服务。</p>
<p>constant()接受两个参数。<br><strong>name(String)</strong>:需要注册的常量的名字<br><strong>value(constant)</strong>:需要注册的常量的值（值或者对象）<br>constant()方法返回一个注册后的服务实例。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">angular.module(<span class="string">'myApp'</span>)</div><div class="line">.constant(<span class="string">'apiKey'</span>,<span class="string">'123123123'</span>);</div></pre></td></tr></table></figure>
<p>这个常量服务可以像其他服务一样被注入到配置函数中。</p>
<p><strong>常量不能被装饰器拦截。</strong></p>
<h4 id="value"><a href="#value" class="headerlink" title="value()"></a>value()</h4><p>如果服务的<code>$get</code>方法返回的是一个常量，那就没必要定义一个包含复杂功能的完成服务，可以通过value()函数方便地注册服务。</p>
<p>value()接受两个参数：<br><strong>name(String)</strong>:需要注册的服务名<br><strong>value(value)</strong>:这个值将作为注入的实例返回<br>value()方法返回以name参数的值为名的注册后的服务实例。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">angular.module(<span class="string">'myApp'</span>,[])</div><div class="line">.value(<span class="string">'apiKey'</span>,<span class="string">'123123123'</span>);</div></pre></td></tr></table></figure>
<h5 id="何时使用value-和constant"><a href="#何时使用value-和constant" class="headerlink" title="何时使用value()和constant()"></a>何时使用value()和constant()</h5><p>value()和constant()的最主要区别是：常量可以注入到配置函数中，而值不行。<br>通常情况下，可以通过value()来注册服务对象或函数，用constant()来配置数据。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">angular.module(<span class="string">'myApp'</span>,[])</div><div class="line">.constant(<span class="string">'apiKey'</span>,<span class="string">'123123123'</span>)</div><div class="line">.config(<span class="function"><span class="keyword">function</span>(<span class="params">apiKey</span>)</span>&#123;</div><div class="line">	<span class="comment">//可拿到apiKey的值</span></div><div class="line">&#125;)</div><div class="line"></div><div class="line">.value(<span class="string">'FBid'</span>,<span class="string">'231231'</span>)</div><div class="line">.config(<span class="function"><span class="keyword">function</span>(<span class="params">FBid</span>)</span>&#123;</div><div class="line">	<span class="comment">//抛出一个错误，未知的provider:FBid</span></div><div class="line">	<span class="comment">//因为在config函数内部无法访问这个值</span></div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<h3 id="decorator"><a href="#decorator" class="headerlink" title="decorator()"></a>decorator()</h3><p><code>$provider</code>服务提供了在服务实例创建时对其进行拦截的功能，可以对服务进行扩展，或者用其他的内容完全替代它。</p>
<p>装饰器的功能非常强大，不仅可以应用在我们自己的服务上，也可以对AngularJS的核心服务进行拦截、中断甚至替换功能的操作。事实上，AngularJS中很多功能的测试就是借助<code>$provider.decorator()</code>建立的。</p>
<p>对服务进行装饰的场景很多，比如对服务进行扩展，将外部数据缓存进localStorage的功能，或者对服务进行封装以便在开发中进行调试和跟踪等。</p>
<p>例如，我们想给之前定义的gitHubService服务加入日志功能，可以借助decorator()函数方便地实现这个功能，而不需要对原始的服务进行修改。<br>decorator()函数可以接受两个参数：<br><strong>name(String)</strong>: 将要拦截的服务名称<br><strong>decoratorFn(Function)</strong>:在服务实例化时调用该函数，这个函数由injector.invoke调用，可以将服务注入这个函数中。</p>
<p>$delegate是可以进行装饰的最原始的服务，为了装饰其他服务，需要将其注入进装饰器。</p>
<p>下面的代码展示了如何给githubService添加装饰器，从而为每个请求都加上一个时间戳：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> githubDecorator = <span class="function"><span class="keyword">function</span>(<span class="params">$delegate, $log</span>) </span>&#123;</div><div class="line">	<span class="keyword">var</span> events = <span class="function"><span class="keyword">function</span>(<span class="params">path</span>) </span>&#123;</div><div class="line">		<span class="keyword">var</span> startedAt = <span class="keyword">new</span> <span class="built_in">Date</span>();</div><div class="line">		<span class="keyword">var</span> events = $delegate.events(path);</div><div class="line">		<span class="comment">//事件是一个promise</span></div><div class="line">		events.finally(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">			$log.info(<span class="string">"Fetching events took"</span> + (<span class="keyword">new</span> <span class="built_in">Date</span>() - startedAt) + <span class="string">"ms"</span>);</div><div class="line">		&#125;);</div><div class="line">		</div><div class="line">		<span class="keyword">return</span> events;</div><div class="line">	&#125;;</div><div class="line">	<span class="keyword">return</span> &#123;</div><div class="line">		<span class="attr">events</span>: events</div><div class="line">	&#125;;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">angular.module(<span class="string">'myApp'</span>)</div><div class="line">.config(<span class="function"><span class="keyword">function</span>(<span class="params">$provide</span>) </span>&#123;</div><div class="line">	$provider.decorator(<span class="string">'githubService'</span>, githubDecorator);</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;服务提供了一种能在应用的整个生命周期内保持数据的方法，它能够在控制器之间进行通信，并且能保证数据的一致性。&lt;/p&gt;
&lt;p&gt;服务是一个&lt;strong&gt;单例对象&lt;/strong&gt;，在每个应用中只会被实例化一次（被$injector实例化），并且是延迟加载的（需要时才会被创建）。
    
    </summary>
    
      <category term="AngularJS" scheme="http://lijingjing.top/categories/AngularJS/"/>
    
    
      <category term="Service" scheme="http://lijingjing.top/tags/Service/"/>
    
  </entry>
  
  <entry>
    <title>JS复习（一）</title>
    <link href="http://lijingjing.top/blog/2017/03/31/JS%E5%A4%8D%E4%B9%A0/"/>
    <id>http://lijingjing.top/blog/2017/03/31/JS复习/</id>
    <published>2017-03-31T13:41:13.000Z</published>
    <updated>2017-04-16T13:57:58.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="lt-script-gt"><a href="#lt-script-gt" class="headerlink" title="&lt;script&gt;"></a><code>&lt;script&gt;</code></h2><p><code>&lt;script&gt;</code>标签可以引入外部资源，也可以在页面中直接包含一段JS代码，包含内容默认是<code>type=&quot;text/javascript&quot;</code>。引入外部资源时，要使用<code>src</code>属性，引入的外部资源不一定是当前域中的JS文件。（所以一般要引入属于自己的域中的文件或是某个受信任的域的文件，否则某个域中的JS文件被恶意修改后，你会引入恶意JS代码）。</p>
<h3 id="延迟加载"><a href="#延迟加载" class="headerlink" title="延迟加载"></a>延迟加载</h3><p>一般JS加载是解析执行完之后才去解析执行之后的内容，所以，如果你的JS文件很大，逻辑很复杂，会造成后面的内容无法解析，这也是为什么一般把JS文件放到<code>&lt;/body&gt;</code>前的原因。</p>
<p>可以在<code>&lt;script&gt;</code>标签内引入defer属性，这会让你引入的JS文件延迟加载，在遇到之后才开始加载含有defer属性的<code>&lt;script&gt;</code>标签引入的外部资源。</p>
<p>虽然H5要求含有defer属性的<code>&lt;script&gt;</code>标签按照它们的属性执行，即第一个延迟脚本会先于第二个延迟脚本执行，而这两个脚本的执行会先于DOMContentLoaded事件。但实际上，<strong>延迟脚本并不一定会按照顺序执行，也不一定在DOMContentLoaded事件触发前执行，因此最好只包含一个延迟脚本（如果脚本之间有依赖关系的话吧。。）</strong>为了保持兼容性，把延迟脚本放在页面底部仍然是最佳选择。</p>
<h3 id="异步加载"><a href="#异步加载" class="headerlink" title="异步加载"></a>异步加载</h3><p>异步加载是说JS加载不阻塞页面渲染，但是会立即被执行。但是异步加载不能保证JS脚本的执行顺序，也就是不保证按照<code>&lt;script&gt;</code>标签的顺序执行。所以在加载期间修改DOM的文件不建议使用asyn属性。</p>
<p>异步脚本一定会在页面的load事件前执行。但是不能保证与DOMContentLoaded事件之间的执行顺序。</p>
<h3 id="XHTML"><a href="#XHTML" class="headerlink" title="XHTML"></a>XHTML</h3><p>XHTML(Extensible HyperText Markup Language)，可扩展超文本标记语言，是将HTML作为XML的应用而重新定义的一个标准。</p>
<p><a href="http://www.w3school.com.cn/xhtml/xhtml_html.asp" target="_blank" rel="external">HTML与XHTML之间的差异</a></p>
<ol>
<li>XHTML必须被正确地嵌套</li>
<li>XHTML元素必须关闭</li>
<li>标签名必须用小写字母</li>
<li>XHTML文档必须拥有根元素</li>
</ol>
<h3 id="嵌入代码与外部文件"><a href="#嵌入代码与外部文件" class="headerlink" title="嵌入代码与外部文件"></a>嵌入代码与外部文件</h3><p>外部文件有以下优点：</p>
<ol>
<li>可维护性：可在不触及HTML标记的情况下，集中精力编辑JS代码</li>
<li>可缓存：浏览器能够根据具体的设置缓存链接的所有外部JS文件。也就是说，如果有两个页面都使用同一个文件，那么这个文件只需下载一次。因此，最终结果就是能够加快页面加载的速度。</li>
<li>适应未来</li>
</ol>
<h3 id="文档模式"><a href="#文档模式" class="headerlink" title="文档模式"></a>文档模式</h3><p>通过文档类型（doctype）切换实现不同的文档模式。<br>最初的两种文档是：混杂模式（quirks mode）和标准模式（standards mode）。<br>混杂模式会让IE的行为与（包含非标准特性的）IE5相同，而标准模式则让IE的行为更接近标准行为。<br><strong>虽然这两种模式主要影响CSS内容的呈现，但在某些情况下也会影响到JS的解释执行。</strong><br>之后IE又提出一种<strong>准标准模式（almost standards mode）</strong>。这种模式下的浏览器特性有很多都是符合标准的，不标准的地方主要体现在处理图片间隙的时候（在表格使用图片时问题最明显。）<br><strong>如果再文档开始处没有发现文档类型声明，则所有的浏览器都会默认开启混杂模式。</strong>采用混杂模式并不值得推荐，因为不同浏览器在这种模式下的行为差异非常大。 </p>
<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><h4 id="严格模式"><a href="#严格模式" class="headerlink" title="严格模式"></a>严格模式</h4><p>ECMAScript5引入了严格模式（strict mode）的概念。严格模式是为JS定义了一种不同的解析与执行模型。在严格模式下，ECMAScript3中的一些不确定的行为将得到处理，而且对某些不安全的操作也会抛出错误。要在整个脚本中启用严格模式，可以在顶部添加：<code>&quot;use strict&quot;;</code> 这是一个编译指示（pragma）,用于告诉支持的JS引擎切换到严格模式。</p>
<p>在函数内部的上方包含<code>&quot;use strict&quot;;</code>，则是指定函数在严格模式下执行。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">doSomething</span>(<span class="params"></span>)</span>&#123;</div><div class="line"><span class="meta">	"use strict"</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="语句"><a href="#语句" class="headerlink" title="语句"></a>语句</h4><p>ECMAScript中的语句以一个分号结尾；如果省略分号，则由解析器确定语句的结尾。</p>
<h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><p>ECMAScript的变量时松散类型的。所谓松散类型就是可以保存任何类型的数据。换句话说，每个变量仅仅是一个<strong>用于保存值的占位符而已</strong>。</p>
<p>用var定义的变量将成为定义该变量的作用域中的局部变量。即如果在函数中使用var定义一个变量，那么这个变量在函数退出后就会被销毁。（JS的作用域是函数作用域）</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>)</span>&#123;</div><div class="line">	<span class="keyword">var</span> message = <span class="string">"hi"</span>;<span class="comment">//局部变量</span></div><div class="line">&#125;</div><div class="line">test();</div><div class="line">alert(message);<span class="comment">//message已被销毁</span></div></pre></td></tr></table></figure>
<p>未声明的变量会创建一个全局变量，但是给未声明的变量赋值，在严格模式下会导致ReferenceError错误。</p>
<h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><p>基本数据类型或简单数据类型：Undefined、Null、Boolean、Number和String。<br>复杂数据类型：Object，Object本质上是由一组无需的名值对组成的。<br>ECMAScript不支持任何创建自定义类型的机制，所有的值最终都是上述六中数据类型之一。</p>
<h4 id="typeof操作符"><a href="#typeof操作符" class="headerlink" title="typeof操作符"></a>typeof操作符</h4><p>typeof用来检测给定变量的数据类型，typeof操作符可能返回以下某个字符串：<br>“undefined”- 如果这个值未定义；<br>“boolean”- 如果这个值是布尔；<br>“string”- 如果这个值是字符串；<br>“number”- 如果这个值是数字；<br>“object”- 如果这个值是对象或null；<br>“function”- 如果这个值是函数。<br>typeof是一个操作符，而不是函数，所以判断一个变量的时候，圆括号可以使用但不是必需的。<br><strong>函数在ECMAScript中是对象，不是一种数据类型。然而，函数有一些特殊的属性，因此通过typeof操作符来区分函数和其他对象是有必要的。</strong><br>使用未经声明的变量会报错，但是用typeof操作符来判断一个未经声明的变量返回的是undefined。</p>
<h4 id="Undefined-和-Null"><a href="#Undefined-和-Null" class="headerlink" title="Undefined 和 Null"></a>Undefined 和 Null</h4><p>实际上，undefined值派生自null值。因此，<code>alert(null == undefined);//true</code><br>在任何时候，都没有必要把一个变量的值显示地设置为undefined，可是如果定义的变量准备在将来用于保存对象，那么最好将该变量初始化为null。</p>
<h4 id="Boolean"><a href="#Boolean" class="headerlink" title="Boolean"></a>Boolean</h4><p>Boolean类型只有两个字面值：true和false。这两个值与数字值不是一回事，因此true不一定等于1，而false也不一定等于0。<br><strong>true和false是区分大小写的，即True和False都不是Boolean的值，只是标识符。</strong><br>要将一个值转换为其对应的Boolean值，可以调用转型函数Boolean()。<br><code>Boolean(TRUE);// Reference error</code></p>
<table>
<thead>
<tr>
<th>数据类型</th>
<th>转换为true的值</th>
<th>转换为false的值</th>
</tr>
</thead>
<tbody>
<tr>
<td>Boolean</td>
<td>true</td>
<td>false</td>
</tr>
<tr>
<td>String</td>
<td>任何非空字符串</td>
<td>”“空字符串</td>
</tr>
<tr>
<td>Number</td>
<td>任何非零数字值（包括无穷大）</td>
<td>0和NaN</td>
</tr>
<tr>
<td>Object</td>
<td>任何对象</td>
<td>null</td>
</tr>
<tr>
<td>Undefined</td>
<td>n/a</td>
<td>undefined</td>
</tr>
</tbody>
</table>
<h3 id="Number"><a href="#Number" class="headerlink" title="Number"></a>Number</h3><p>Number类型使用IEEE754格式来表示整数和浮点数值（浮点数值在某些语言中也被称为双精度数值）。<br>除了十进制外，整数还可以通过八进制（以8为基数）或十六进制（以16为基数）的字面值来表示。<br>其中，八进制的第一位必须是0，然后是（0~7），如果字面值中的数值超过了范围，那么前导零将被忽略，后面的数值将被当做十进制数值解析。<br><strong>八进制在严格模式下是无效的，会导致支持的JS引擎抛出错误。</strong><br>十六进制字面值的前两位必须是0x，后跟任何十六进制数字（0~9及A~F/a~f）。<br>在进行算术计算的时候，所有以八进制或十六进制表示的数值都将被转换成十进制数值。<br>JS可以保存+0和-0。+0和-0被认为相等。</p>
<h4 id="浮点数值"><a href="#浮点数值" class="headerlink" title="浮点数值"></a>浮点数值</h4><p>所谓浮点数值，就是该数值中必须包含一个小数点，并且小数点后面必须至少有一个数字。<br>由于保存浮点数值需要的内存空间是保存整数值的两倍，因此ECMAScript会将小数点后没有任何数字的数值作为整数值来保存。如果浮点数值本身表示的就是一个整数（eg: 1.0），那么该值也会被转换为整数。<br>可以使用e/E来表示极大或极小的值。<br>浮点数值的最高精度是17位小数，但在进行算术计算时其精确度远远不如整数,所以不要测试某个特定的浮点数值，因为关于浮点数值计算会产生舍入误差问题，这是基于IEEE754数值的浮点计算的通病。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">console</span>.log(<span class="number">0.1</span>+<span class="number">0.2</span>);<span class="comment">//0.30000000000000004</span></div></pre></td></tr></table></figure></p>
<h4 id="数值范围"><a href="#数值范围" class="headerlink" title="数值范围"></a>数值范围</h4><p>由于内存的限制，ECMAScript并不能保存世界上所有的数值，能够表示的最小数值保存在Number.MIN_VALUE中（大多数浏览器中，这个数值是5e-324），能够表示的最大数值保存在Number.MAX_VALUE中（大多数浏览器中，这个数值是1.7976931348623157e+308）。</p>
<p>如果某次计算的结果得到了一个超出JS数值范围的值，那么这个数值会被自动转换成特殊的Infinity值。具体来说，如果这个值是负数，会被转换成-Infinity(负无穷)，如果这个数值是正数，则会被转换成Infinity(正无穷)。</p>
<p>如果某次运算返回了正或负的Infinity值，那么该值将无法继续参与下一次的运算，因为Infinity不是能够参与计算的数值。</p>
<p>要想确定一个数值是不是有穷的，可以使用isFinite()函数，这个函数在参数处于最小与最大数值之间时会参会true。</p>
<h4 id="NaN"><a href="#NaN" class="headerlink" title="NaN"></a>NaN</h4><p>NaN,即非数值（Not a Number）是一个特殊的数值，这个数值用来表示一个本来要返回数值的操作数未返回数值的情况。</p>
<p>0除以0会返回NaN，正数除以0返回Infinity，负数除以0返回-Infinity。因此不会影响其他代码的运行。</p>
<p>任何涉及NaN的操作都会返回NaN；<br>NaN与任何值都不相等，包括NaN本身。 <code>alert(NaN == NaN);//false</code></p>
<p>isNaN()在接收到一个值之后，会尝试将这个值转换为数值，某些不是数值的值会直接转换为数值，eg：字符串”10“或Boolean值。而任何不能被转换为数值的值都会导致这个函数返回true。</p>
<p>isNaN()同样适用于对象，在基于对象调用isNaN()函数时，会首先调用对象饿valueOf()方法，然后确定该方法返回的值是否可以转换为数值，如果不能，则基于这个返回值再调用toString()方法，再测试返回值。</p>
<h4 id="数值转换"><a href="#数值转换" class="headerlink" title="数值转换"></a>数值转换</h4><p>有三个函数可以把非数值转换为数值： Number()、parseInt()和parseFloat();<br>Number()可以把任何数据类型进行转换；<br>parseInt()和parseFloat()是专门用于把字符串转换成数值。<br>parseFloat()只解析十进制值。而且如果字符串包含的是一个可解析为整数的数，函数返回的是整数。</p>
<h3 id="String"><a href="#String" class="headerlink" title="String"></a>String</h3><p>用于表示由零或多个16位Unicode字符组成的字符序列，即字符串。<br>ECMAScript中的字符串时不可变的，也就是说，字符串一旦创建，它们的值就不能改变。要改变某个变量保存的字符串，首先要销毁原来的字符串，然后再用另一个包含新值的字符串填充该变量。</p>
<h4 id="toString（）"><a href="#toString（）" class="headerlink" title="toString（）"></a>toString（）</h4><p>在调用数值的toString()方法时，可以传递一个参数：输出数值的基数。默认情况下，toString()方法以十进制格式返回数值的字符串表示。而通过传递基数，toString()可以输出以二进制、八进制、十六进制。乃至其他任意有效进制格式表示的字符串值。</p>
<p>null和undefined没有toString()方法，转换为字符串可是使用String();</p>
<h3 id="object类型"><a href="#object类型" class="headerlink" title="object类型"></a>object类型</h3><p>ECMAScript中的对象其实就是一组数据和功能的集合。对象可以通过执行new操作符后跟要创建的对象类型的名称来创建。 而创建Object类型的实例并为其添加属性和方法，就可以创建自定义对象。<br><code>var o = new Object();</code></p>
<p><strong>在ECMAScript中，Object类型时所有它的实例的基础，Object类型所具有的任何属性和方法也同样存在于更具体的对象中。</strong></p>
<p>每个Object实例都具有以下属性和方法：</p>
<ol>
<li>constructor：保存着用于创建当前对象的函数。对于<code>var o = new Object();</code> 构造函数（constructor）就是Object();</li>
<li>hasOwnProperty(propertyName)：用于检查给定的属性在当前对象实例中（而不是在实例的原型中）是否存在。其中参数的属性名必须以<strong>字符串</strong>的形式指定。</li>
<li>isPrototypeOf(object)：用于检查传入的对象是否是传入对象的原型.</li>
<li>toLocaleString()：返回对象的字符串表示，该字符串与执行环境的地区对应。</li>
<li>toString()：返回对象的字符串表示；</li>
<li>valueOf()：返回对象的字符串、数值或布尔值表示，通常与toString()方法的返回值相同。</li>
</ol>
<h3 id="操作符"><a href="#操作符" class="headerlink" title="操作符"></a>操作符</h3>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;lt-script-gt&quot;&gt;&lt;a href=&quot;#lt-script-gt&quot; class=&quot;headerlink&quot; title=&quot;&amp;lt;script&amp;gt;&quot;&gt;&lt;/a&gt;&lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt;&lt;/h2&gt;&lt;p&gt;&lt;code&gt;&amp;lt;scr
    
    </summary>
    
      <category term="JavaScript" scheme="http://lijingjing.top/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="http://lijingjing.top/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript面向对象精要</title>
    <link href="http://lijingjing.top/blog/2017/03/31/JavaScript%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%B2%BE%E8%A6%81/"/>
    <id>http://lijingjing.top/blog/2017/03/31/JavaScript面向对象精要/</id>
    <published>2017-03-31T05:40:43.000Z</published>
    <updated>2017-03-31T13:40:36.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="原始类型和引用类型"><a href="#原始类型和引用类型" class="headerlink" title="原始类型和引用类型"></a>原始类型和引用类型</h3><p>原始类型保存为简单数据值。引用类型则保存为对象，其本质是指向内存位置的引用。</p>
<p>其他语言用栈储存原始类型，用堆储存引用类型，JS则不同，它使用一个变量对象追踪变量的生存期，原始值被直接保存在变量对象内，而引用值则作为一个指针保存在变量对象内，该指针指向实际对象在内存中的存储位置。</p>
<h4 id="原始类型"><a href="#原始类型" class="headerlink" title="原始类型"></a>原始类型</h4><p>原始类型代表照原样保存的一些简单数据。JS一共有五种原始类型：</p>
<table>
<thead>
<tr>
<th>类型</th>
</tr>
</thead>
<tbody>
<tr>
<td>boolean</td>
<td>布尔，值为true或false</td>
</tr>
<tr>
<td>number</td>
<td>数字，值为任何整型或浮点数值</td>
</tr>
<tr>
<td>string</td>
<td>字符串，值为由单引号或双引号括出的单个字符或连续字符（JS不区分字符类型）</td>
</tr>
<tr>
<td>null</td>
<td>空类型，该原始类型仅有一个值： null</td>
</tr>
<tr>
<td>undefined</td>
<td>未定义，该原始类型仅有一个值： undefined（undefined会被赋给一个还没有初始化的变量）</td>
</tr>
</tbody>
</table>
<p>每个含有原始值的变量使用自己的存储空间，一个变量的改变不会影响到其他变量。</p>
<p>鉴别原始类型的最佳方法是使用typeof操作符，返回一个说明数据类型的<strong>字符串</strong>。<br><code>typeof(null)</code>返回’object’。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span>(<span class="number">4</span>)); <span class="comment">// number</span></div><div class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span>(<span class="string">"aaa"</span>));<span class="comment">// string</span></div><div class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span>(<span class="literal">true</span>)); <span class="comment">// boolean</span></div><div class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span>(<span class="literal">undefined</span>)); <span class="comment">// undefined</span></div><div class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span>(<span class="literal">null</span>)); <span class="comment">// object</span></div><div class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span>(<span class="keyword">typeof</span>(<span class="number">4</span>))); <span class="comment">// string</span></div></pre></td></tr></table></figure>
<p>判断一个值是不是空类型的最佳方法是直接和null比较，<code>console.log(value === null); //true or false</code><br><strong><code>console.log(undefined == null); //true</code></strong><br>尽管原始类型拥有方法，但它们不是对象。</p>
<h4 id="引用类型"><a href="#引用类型" class="headerlink" title="引用类型"></a>引用类型</h4><p>引用值是引用类型的实例。对象是属性的无序列表。属性包含键（始终是字符串）和值。如果一个属性的值是函数，它就成为方法。JS中的函数其实是引引用值，除了函数可以运行外，一个包含数组的属性和一个包含函数的属性没有什么区别。<br>在使用对象前，你必须先创建它们。</p>
<h5 id="创建对象"><a href="#创建对象" class="headerlink" title="创建对象"></a>创建对象</h5><p>使用new操作符和构造函数。 构造函数就是通过new操作符来创建对象的函数——任何函数都可以是构造函数。 </p>
<p>JS的构造函数用首字母大写来跟非构造函数进行区分。</p>
<p>引用类型不在变量中直接保存对象，而是包含一个指向内存中实际对象所在位置的指针（引用），这是对象和原始值之间的一个基本差别，原始值是直接保存在变量中的。</p>
<p>当你将一个对象赋值给变量时，实际是赋值给这个变量一个指针，这意味着，将一个变量赋值给另一个变量时，两个变量各获得了一份指针的拷贝，指向内存中的同一个对象。</p>
<h5 id="对象引用接触"><a href="#对象引用接触" class="headerlink" title="对象引用接触"></a>对象引用接触</h5><p>JS有垃圾收集功能，因此当你使用引用类型时无需担心内存分配。但最好在不适用对象时将其引用解除。将对象变量置为null，让垃圾收集器对那块内存进行释放。</p>
<h5 id="添加和删除属性"><a href="#添加和删除属性" class="headerlink" title="添加和删除属性"></a>添加和删除属性</h5><p>JS可以随时添加和删除属性。</p>
<h4 id="内建类型实例化"><a href="#内建类型实例化" class="headerlink" title="内建类型实例化"></a>内建类型实例化</h4><table>
<thead>
<tr>
<th>内建类型</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>Array</td>
<td>数组类型，以数字为索引的一组值的有序列表</td>
</tr>
<tr>
<td>Date</td>
<td>日期和时间类型</td>
</tr>
<tr>
<td>Error</td>
<td>运行期错误类型（还有一些更特别的错误的子类型）</td>
</tr>
<tr>
<td>Function</td>
<td>函数类型</td>
</tr>
<tr>
<td>Object</td>
<td>通用对象类型</td>
</tr>
<tr>
<td>RegExp</td>
<td>正则表达式类型</td>
</tr>
</tbody>
</table>
<h5 id="字面形式"><a href="#字面形式" class="headerlink" title="字面形式"></a>字面形式</h5><p>内建引用类型有字面形式。字面形式允许你在不需要使用new操作符和构造函数显示创建对象的情况下生成引用值。（JS引擎背后做的工作和使用new操作符来创建对象是一样的 ）</p>
<h4 id="访问属性"><a href="#访问属性" class="headerlink" title="访问属性"></a>访问属性</h4><p>两种方式，<code>object.attr</code>和<code>object[attr]</code></p>
<h4 id="鉴别引用类型"><a href="#鉴别引用类型" class="headerlink" title="鉴别引用类型"></a>鉴别引用类型</h4><p>函数可以直接用typeof来识别，如果是函数，会直接返回<code>function</code><br>对其他引用类型的鉴别，使用typeof来鉴别会返回object,可以使用instanceof来判断实例与对象之间的关系，也可以鉴别继承关系。</p>
<p><strong>鉴别数组最好的方法是使用Array.isArray(object);</strong></p>
<h4 id="原始封装类型"><a href="#原始封装类型" class="headerlink" title="原始封装类型"></a>原始封装类型</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> name = <span class="string">"Nicholas"</span>;</div><div class="line"><span class="keyword">var</span> firstChar = name.charAt(<span class="number">0</span>);</div><div class="line"><span class="built_in">console</span>.log(firstChar);</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">//背后发生的事情如下</span></div><div class="line"><span class="keyword">var</span> name = <span class="string">"Nicholas"</span>;</div><div class="line"><span class="keyword">var</span> temp = <span class="keyword">new</span> <span class="built_in">String</span>(name);</div><div class="line"><span class="keyword">var</span> firstChar = temp.charAt(<span class="number">0</span>);<span class="comment">//字符串对象的存在仅用于该语句，并在随后被销毁（一种被称为自动打包的过程）</span></div><div class="line">temp = <span class="literal">null</span>;</div><div class="line"><span class="built_in">console</span>.log(firstChar);</div><div class="line"></div><div class="line"><span class="keyword">var</span> name = <span class="string">"Nicholas"</span>;</div><div class="line">name.last = <span class="string">"Zakas"</span>;</div><div class="line"><span class="built_in">console</span>.log(name.last);<span class="comment">// undefined, 原始封装类型的属性会消失，是因为被添加的属性的对象立刻就被销毁了</span></div><div class="line"></div><div class="line"><span class="comment">//JS引擎实际发生的事情</span></div><div class="line"><span class="keyword">var</span> name = <span class="string">"Nicholas"</span>;</div><div class="line"><span class="keyword">var</span> temp = <span class="keyword">new</span> <span class="built_in">String</span>(name);</div><div class="line">temp.last = =<span class="string">"Zakas"</span>;<span class="comment">//实际是在一个理科就被销毁的临时对象上而不是字符串上添加了新的属性</span></div><div class="line">temp = <span class="literal">null</span>;  </div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(name <span class="keyword">instanceof</span> <span class="built_in">String</span>);<span class="comment">//false</span></div></pre></td></tr></table></figure>
<p>手动创建的原始封装类型在某些时候会让人误解，在大多数情况下只会导致错误。除非有特殊情况，一般应该避免使用原始封装类型。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> found = <span class="keyword">new</span> <span class="built_in">Boolean</span>(<span class="literal">false</span>);<span class="comment">//布尔表达式中的所有对象都会被转换为true</span></div><div class="line"><span class="keyword">if</span>(found) &#123;<span class="comment">//只是在判断对象是否存在</span></div><div class="line">	<span class="built_in">console</span>.log(<span class="string">"Found"</span>);<span class="comment">//会被执行</span></div><div class="line">&#125;</div><div class="line"><span class="keyword">if</span>(found.valueOf()) &#123;<span class="comment">//false</span></div><div class="line">	<span class="built_in">console</span>.log(<span class="string">"Found"</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p></p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;原始类型和引用类型&quot;&gt;&lt;a href=&quot;#原始类型和引用类型&quot; class=&quot;headerlink&quot; title=&quot;原始类型和引用类型&quot;&gt;&lt;/a&gt;原始类型和引用类型&lt;/h3&gt;&lt;p&gt;原始类型保存为简单数据值。引用类型则保存为对象，其本质是指向内存位置的引用。&lt;/p&gt;
    
    </summary>
    
      <category term="JavaScript Object-oriented" scheme="http://lijingjing.top/categories/JavaScript-Object-oriented/"/>
    
    
      <category term="JavaScript" scheme="http://lijingjing.top/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>AngularJS Compiler</title>
    <link href="http://lijingjing.top/blog/2017/03/15/AngularJS-directive%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"/>
    <id>http://lijingjing.top/blog/2017/03/15/AngularJS-directive生命周期/</id>
    <published>2017-03-15T12:44:27.000Z</published>
    <updated>2017-03-16T13:34:34.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="AngularJS-Compiler"><a href="#AngularJS-Compiler" class="headerlink" title="AngularJS Compiler"></a>AngularJS Compiler</h1><p>在AngularJS应用启动之前，它们以HTML文本的形式保存在文本编辑器中。应用启动后进行编译和链接，作用域会和对应的HTML进行绑定，应用可以对用户在HTML中进行的操作进行实时响应。</p>
<p>上述过程主要包括两个阶段：</p>
<h2 id="编译阶段"><a href="#编译阶段" class="headerlink" title="编译阶段"></a>编译阶段</h2><p>在编译阶段，AngularJS会遍历整个HTML文档并根据JS中的指令定义来处理页面上声明的指令。</p>
<p>每个指令的模板中都可能含有另外一个指令，另外一个指令也可能会有自己的模板。当AngularJS调用HTML文档根部的指令时，会遍历其中所有的模板，模板中也可能包含带有模板的指令，最终会有一个<strong>模板树</strong>。</p>
<p>虽然模板中可以包含其他指令，其他指令中也会有模板，模板树可能又大又深，但是一个元素如果有多个指令修饰，只有处于最高优先级指令的模板会被解析并添加到模板树中。所以，要将包含模板的指令和添加行为的指令分离开来，如果一个元素已经有一个含有模板的指令了，永远不要对其用另一个指令进行修饰。对于不包含模板的指令进行优先级排序，每个指令的编译函数都有一次机会来调整DOM并且最后都会返回一个链接函数，这些返回的链接函数组成一个”combined”链接函数。之后将”combinded”link functin和scope进行链接，链接过程中会分别调用单独指令对应的链接函数，为元素注册监听器和对相应的scope属性设置$watch函数。</p>
<p>利用Angular提供的$compile服务，以下举例说明Angular内部编译的实现：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> $compile = ...; <span class="comment">// injected into your code</span></div><div class="line"><span class="keyword">var</span> scope = ...;</div><div class="line"></div><div class="line"><span class="keyword">var</span> html = <span class="string">'&lt;div ng-bind="exp"&gt;&lt;/div&gt;'</span>;</div><div class="line"></div><div class="line"><span class="comment">// Step 1: parse HTML into DOM element</span></div><div class="line"><span class="keyword">var</span> template = angular.element(html);</div><div class="line"></div><div class="line"><span class="comment">// Step 2: compile the template</span></div><div class="line"><span class="keyword">var</span> linkFn = $compile(template);</div><div class="line"></div><div class="line"><span class="comment">// Step 3: link the compiled template with the scope.</span></div><div class="line">linkFn(scope);</div></pre></td></tr></table></figure>
<p>一旦对一个元素中的指令和其中的子模板进行遍历或编译，编译后的模板会返回一个叫做<strong>模板函数</strong>的函数。我们有机会在指令的模板函数被返回前，对编译后的DOM树进行修改。因为这个时间点DOM树还没有进行数据绑定，所以对DOM树的操作的性能开销会很小。内置指令ng-repeat和ng-transclude就是在这个时候对DOM进行操作的。<strong>所以对DOM的操作要放在指令的compile属性中。</strong></p>
<h3 id="compile"><a href="#compile" class="headerlink" title="compile"></a>compile</h3><p>compile选项可以返回一个对象或函数。compile和link相比，link的使用频率会更高。</p>
<p>如果设置了compile函数，说明我们希望指令和实时数据进行绑定之前，即实时数据被放到DOM中之前，进行DOM操作。在这个函数中进行诸如添加和删除节点等DOM操作是安全的。</p>
<p><strong>compile和link函数是互斥的。</strong>如果同时设置了这两项，那么会把compile所返回的函数当做链接函数，而link本身被忽略。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//...</span></div><div class="line">compile: <span class="function"><span class="keyword">function</span>(<span class="params">tEle, tAttrs, transcludeFn</span>)</span>&#123;</div><div class="line">    <span class="keyword">var</span> tplEl = angular.element(<span class="string">'&lt;div&gt;'</span>+</div><div class="line">        <span class="string">'&lt;h2&gt;&lt;/h2&gt;'</span>+</div><div class="line">        <span class="string">'&lt;/div&gt;'</span></div><div class="line">    );</div><div class="line">    <span class="keyword">var</span> h2 = tplEl.find(<span class="string">'h2'</span>);</div><div class="line">    h2.attr(<span class="string">'type'</span>,tAttrs.type);</div><div class="line">    h2.attr(<span class="string">'ng-model'</span>,tAttrs.ngModel);</div><div class="line">    h2.val(<span class="string">"hello"</span>);</div><div class="line">    tEle.replaceWith(tplEl);</div><div class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">scope, ele, attrs</span>)</span>&#123;</div><div class="line">    <span class="comment">//链接函数</span></div><div class="line">    &#125;    </div><div class="line">&#125;</div><div class="line"><span class="comment">//...</span></div></pre></td></tr></table></figure>
<p>一个指令的表现一旦编译完成，马上就可以通过编译函数对其进行访问，编译函数的签名包含访问指令声明所在元素（tElement）及该元素其他属性（tAttrs），编译函数返回前面提到的模板函数，其中含有完整的解析树。</p>
<p>在编译函数内部，不要进行DOM事件监听器的注册，这个操作应该在链接函数中完成。</p>
<p>编译过程就是遍历DOM，并收集所有diretives的过程，返回的结果是一个链接函数（linking function）。</p>
<p><strong>编译函数负责对模板DOM进行转换。</strong>链接函数则负责将作用域和DOM进行链接。</p>
<h2 id="链接阶段"><a href="#链接阶段" class="headerlink" title="链接阶段"></a>链接阶段</h2><p>以ng-repeat为例，它会遍历指定的数组或对象，在数据绑定之前构建出对应的DOM结构。ng-repeat只需将集合中的每个元素clone出来，将编译后的DOM传递给指令的下一个阶段—-链接阶段。</p>
<p>一个指令一旦被编译完成，马上就可以通过编译函数对其进行访问，编译函数含有访问指令声明所在元素及该元素其他属性的方法。这个函数返回前面提到的模板函数，其中含有完整的解析树。由于每个指令都可以有自己的模板和编译函数，每个模板返回的也是自己的模板函数。链条顶部的指令会将内部子指令的模板合并在一起成为一个模板函数并返回，在树的内部，只能通过模板函数访问其所在的分支。</p>
<p>链接函数会在模板编译并同作用域进行链接时被调用，因此它负责设置事件监听器，监视数据变化和实时的操作DOM。链接函数对绑定了实时数据的DOM具有控制能力。  </p>
<h3 id="link"><a href="#link" class="headerlink" title="link"></a>link</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">link: <span class="function"><span class="keyword">function</span>(<span class="params">scope, element, attrs</span>)</span>&#123;</div><div class="line">    <span class="comment">//...</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果指令中有require选项，函数签名会有第四个参数，代表控制器或者所依赖的指令的控制器。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//require 'SomeController'</span></div><div class="line">link: <span class="function"><span class="keyword">function</span>(<span class="params">scope, element, attrs, SomeController</span>)</span>&#123;</div><div class="line">    <span class="comment">//...</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>链接函数完成DOM和作用域的绑定，并设置事件监听器等。</strong></p>
<h2 id="Compile和Link区别"><a href="#Compile和Link区别" class="headerlink" title="Compile和Link区别"></a>Compile和Link区别</h2><p>将整个编译过程分为compile和link两个阶段，是因为有时候会提升性能。compile规定之后实例的共同特性，不包括对数据的操作部分，主要针对DOM转换方面；link函数会将template的实例与数据进行绑定，并操作template实例。</p>
<p>很少有指令值包含一个compile函数，因为大多数指令更关心如何在指定的DOM元素实例上进行操作，而不是改变它的整个结构。指令往往会包含link function,因为link function允许指令在指定的克隆template的DOM实例元素上注册事件监听器，从scope中为DOM绑定数据。</p>
<p>以ng-repeat为例说明：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">Hello &#123;&#123;user&#125;&#125;, you have these actions:</div><div class="line"><span class="xml"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span></div><div class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">ng-repeat</span>=<span class="string">"action in user.actions"</span>&gt;</span></div><div class="line">        &#123;&#123;action.description&#125;&#125;</div><div class="line">  <span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></div></pre></td></tr></table></figure>
<p>当上面的代码被编译时，编译器首先访问每一个node并寻找对应的directives。</p>
<p><code></code>匹配interpolation directive，ng-repeat匹配ngRepeat directive。</p>
<p>之后为user.actions中的每个action clone一个新的<code>&lt;li&gt;</code>元素。</p>
<p>为了支持之后可以有新的元素添加到user.actions中，要保存一个干净的&lt;li&gt;拷贝，目的是为了之后可以进行模板的clone并将其添加到DOM中。新的actions被插入后，模板元素<code>&lt;li&gt;</code>被clone并插入到ul中。但是仅仅clone<code>&lt;li&gt;</code>是不够的，还要编译<code>&lt;li&gt;</code>，这样像<code></code>这样的指令才会在正确的scope下执行。</p>
<p>一种简单的解决方法就是将<code>&lt;li&gt;</code>元素的拷贝插入DOM后并编译它，但是编译我们clone的每个<code>&lt;li&gt;</code>元素会造成大量的重复工作。尤其是我们每次都不得不遍历<code>&lt;li&gt;</code>并找到它对应的directives，这样会使整个编译过程非常慢，结果就是当有新的节点插入时，整个应用的响应就会变得很差。</p>
<p>将编译过程分为两个阶段可以解决上面的问题，在compile阶段，所有的指令都会被识别，并且按照指令的priority进行排序，在Link阶段，将所有对应的scope实例和对应的<code>&lt;li&gt;</code>元素实例进行链接。Link阶段会为DOM元素设定监听器，同时在Scope上设置$watch函数来保持View和Model中数据的一致性。</p>
<p>ngRepeat在编译的时候不会分开编译每个<code>&lt;li&gt;</code>元素，<code>&lt;li&gt;</code>元素编译返回的结果是一个链接函数，在链接函数中会对所有克隆出的<code>&lt;li&gt;</code>元素进行处理，链接函数会将相应的scope和指定的克隆<code>&lt;li&gt;</code>元素进行attach。</p>
<p>运行时，ngRepeat会watch表达式，当有items被添加时，会创建新的clone <code>&lt;li&gt;</code>元素，并为新的克隆元素创建新的scope，调用链接函数将新的scope与新clone的元素进行绑定。</p>
<p>为了提高效率，ng-repeat 只有在有新元素添加或删除旧元素的时候，才会创建或删除DOM元素，其余时候，并不会对DOM结构做出改变，对象属性值的改变并不会为其重新创建DOM，而只是改变相应DOM中属性的值。原有arr中对象排列顺序的变化会使DOM reorder，也不会删除DOM重新创建DOM节点。这样就提高了页面的渲染速度。</p>
<p>当有新的对象创建时，会根据template的内容clone新的DOM元素，将其加入到DOM树相应的位置，调用link function将相应的scope绑定到clone出的元素上。</p>
<p>在stackoverflow上看到一个提问者画的图，虽然没有人回复他，但是我感觉他的思路还挺清晰的,链接为<a href="http://stackoverflow.com/questions/28744328/how-does-ngrepeat-work" target="_blank" rel="external">how-does-ngRepeat-work</a><br>如下图： <img src="/images/ng-repeat.png" alt="ng-repeat"></p>
<p>具体理解可以参考下面的链接：</p>
<p> <a href="https://www.bennadel.com/blog/2443-rendering-dom-elements-with-ngrepeat-in-angularjs.htm" target="_blank" rel="external">Rendering DOM Elements With ngRepeat In AngularJS</a> </p>
<p> <a href="http://jsbin.com/tigejaw/edit?html,css,js,console,output" target="_blank" rel="external">在线Demo</a> </p>
<p> <a href="http://liamkaufman.com/blog/2013/05/13/understanding-angularjs-directives-part1-ng-repeat-and-compile/" target="_blank" rel="external">ng-repeat and compile</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;AngularJS-Compiler&quot;&gt;&lt;a href=&quot;#AngularJS-Compiler&quot; class=&quot;headerlink&quot; title=&quot;AngularJS Compiler&quot;&gt;&lt;/a&gt;AngularJS Compiler&lt;/h1&gt;&lt;p&gt;在Angul
    
    </summary>
    
      <category term="AngularJS" scheme="http://lijingjing.top/categories/AngularJS/"/>
    
    
      <category term="directive" scheme="http://lijingjing.top/tags/directive/"/>
    
  </entry>
  
  <entry>
    <title>AngularJS Directive transclude</title>
    <link href="http://lijingjing.top/blog/2017/03/15/AngularJS-Directive-transclude/"/>
    <id>http://lijingjing.top/blog/2017/03/15/AngularJS-Directive-transclude/</id>
    <published>2017-03-15T10:54:54.000Z</published>
    <updated>2017-03-15T11:36:20.000Z</updated>
    
    <content type="html"><![CDATA[<p>transclude是一个可选的参数，如果设置了，其值必须为true,默认值为false。<br>使用嵌入会很好地扩充我们的工具集，特别是在创建可以共享的代码片段时。<br>嵌入通常用来创建可复用的组件。典型的例子是模态对话框或导航栏。<br>嵌入使我们可以将一个模板或另一个指令全部嵌入到另一个指令中，这样可以将任意内容和作用域传递给此指令。指令的内部可以访问外部指令的作用域，并且模板也可以访问外部的作用域对象。<br>为了将外部作用域传递过去，外部指令的scope参数的值必须通过{}或true来设置，创建自己的作用域。如果没有设置scope参数，那么指令内部的作用域将作为传入模板的作用域。</p>
<p><strong>当创建一个可以包含任意内容的指令时，才使用transclude:true</strong><br><strong>如果指令使用了transclude参数，那么在控制器中就无法正常监听数据模型的变化了，最佳实践建议在链接函数中使用$watch服务</strong></p>
<p>嵌入允许使用指令的人方便地提供自己的HTML模板，其中可以包含独特的状态和行为，并对指令的各方面进行自定义。</p>
<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p>创建一个可以复用的侧边栏（为了保持CSS样式的一致，同时希望在复用的时候尽量少写HTML代码）</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">sideboxtitle</span>=<span class="string">"Links"</span>&gt;</span></div><div class="line">	<span class="tag">&lt;<span class="name">ul</span>&gt;</span></div><div class="line">		<span class="tag">&lt;<span class="name">li</span>&gt;</span>First link<span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line">		<span class="tag">&lt;<span class="name">li</span>&gt;</span>Second link<span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line">	<span class="tag">&lt;/<span class="name">ul</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div></pre></td></tr></table></figure>
<p>为上面的侧边栏创建一个简单的指令，并将transclude参数的值设为true。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">angular.module(<span class="string">'myApp'</span>,[])</div><div class="line">.directive(<span class="string">'sidebox'</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">	<span class="keyword">return</span> &#123;</div><div class="line">		<span class="attr">restrict</span>: <span class="string">"EA"</span>,</div><div class="line">		<span class="attr">scope</span>: &#123;</div><div class="line">			<span class="attr">title</span>: <span class="string">'@'</span></div><div class="line">		&#125;,</div><div class="line">		<span class="attr">transclude</span>: <span class="literal">true</span>,</div><div class="line">		<span class="attr">template</span>: <span class="string">'&lt;div class="sidebox"&gt;\</span></div><div class="line">			&lt;div class="content"&gt;\</div><div class="line">				&lt;h2 class="header"&gt;&#123;&#123;title&#125;&#125;&lt;/h2&gt;\</div><div class="line">				&lt;span class="content" ng-transclude&gt;\</div><div class="line">				&lt;/span&gt;\</div><div class="line">			&lt;/div&gt;\</div><div class="line">		&lt;/div&gt;'</div><div class="line">	&#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>上述代码告诉AngularJS编译器，将指令从DOM元素中包含获取的内容放到它发现ng-transclude指令的地方。借助transclude属性，可以将指令进行复用，而不必重写样式和布局部分的代码。如下所示：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">sidebox</span> <span class="attr">title</span>=<span class="string">"Links"</span>&gt;</span></div><div class="line">	<span class="tag">&lt;<span class="name">ul</span>&gt;</span></div><div class="line">		<span class="tag">&lt;<span class="name">li</span>&gt;</span>First link<span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line">		<span class="tag">&lt;<span class="name">li</span>&gt;</span>Second link<span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line">	<span class="tag">&lt;/<span class="name">ul</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">sidebox</span> <span class="attr">title</span>=<span class="string">"TagCloud"</span>&gt;</span></div><div class="line">	<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"tagcloud"</span>&gt;</span></div><div class="line">		<span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">""</span>&gt;</span>Graphics<span class="tag">&lt;/<span class="name">a</span>&gt;</span></div><div class="line">		<span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">""</span>&gt;</span>AngularJS<span class="tag">&lt;/<span class="name">a</span>&gt;</span></div><div class="line">		<span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">""</span>&gt;</span>D3<span class="tag">&lt;/<span class="name">a</span>&gt;</span></div><div class="line">	<span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>输出结果；<br><img src="/images/directive-transclude.png" alt="directive-transclude.png"></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;transclude是一个可选的参数，如果设置了，其值必须为true,默认值为false。&lt;br&gt;使用嵌入会很好地扩充我们的工具集，特别是在创建可以共享的代码片段时。&lt;br&gt;嵌入通常用来创建可复用的组件。典型的例子是模态对话框或导航栏。&lt;br&gt;嵌入使我们可以将一个模板或另一
    
    </summary>
    
      <category term="AngularJS" scheme="http://lijingjing.top/categories/AngularJS/"/>
    
    
      <category term="directive" scheme="http://lijingjing.top/tags/directive/"/>
    
  </entry>
  
  <entry>
    <title>Angular Directive scope属性</title>
    <link href="http://lijingjing.top/blog/2017/03/15/Angular-Directive-scope%E5%B1%9E%E6%80%A7/"/>
    <id>http://lijingjing.top/blog/2017/03/15/Angular-Directive-scope属性/</id>
    <published>2017-03-15T09:29:40.000Z</published>
    <updated>2017-03-15T11:57:27.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="指令作用域"><a href="#指令作用域" class="headerlink" title="指令作用域"></a>指令作用域</h2><p>首先在DOM中声明ng-app时，会创建$rootScope这个特殊的对象, 它是之后所有scope的父作用域。</p>
<p>DOM中每个指令在调用时的作用域会有以下三种情况：</p>
<ol>
<li>直接调用相同的作用域对象，即和外面的作用域相同，没有创建新的作用域</li>
<li>从当前作用域对象继承一个新的作用域对象</li>
<li>创建一个同当前作用域对象相隔离的作用域对象</li>
</ol>
<h2 id="scope参数"><a href="#scope参数" class="headerlink" title="scope参数"></a>scope参数</h2><h3 id="scope-false"><a href="#scope-false" class="headerlink" title="scope: false"></a>scope: false</h3><p>scope参数是可选的，默认情况下，为false，并不为指令创建新的作用域，和其他对象共享作用域。<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&lt;!doctype html&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">ng-app</span>=<span class="string">"myApp"</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://ajax.googleapis.com/ajax/libs/angularjs/1.2.0-rc.3/angular.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></div><div class="line"></div><div class="line">  Outside myDirective: &#123;&#123; myProperty &#125;&#125;</div><div class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">my-directive</span> <span class="attr">ng-init</span>=<span class="string">"myProperty = 'wow, this is cool'"</span>&gt;</span>  </div><div class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">  </div><div class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="xml"></span></div><div class="line">    angular.module('myApp', [])</div><div class="line">    .directive('myDirective', function() &#123;</div><div class="line">      return &#123;</div><div class="line">        restrict: 'A',</div><div class="line">        scope: false,</div><div class="line">        template: '<span class="tag">&lt;<span class="name">div</span>&gt;</span> Inside myDerective &#123;&#123;myProperty&#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span>'</div><div class="line">      &#125;;</div><div class="line">    &#125;)</div><div class="line">  <span class="tag">&lt;/<span class="name">script</span>&gt;</span></div><div class="line">  </div><div class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>上述myProperty定义在$rootScope上，所以指令外部和内部的变量都可以共享init出的值。<br>输出结果为：<br><img src="/images/scope-false.png" alt="scope-false.png"></p>
<h3 id="scope-true"><a href="#scope-true" class="headerlink" title="scope: true"></a>scope: true</h3><p>scope为true时，会为指令创建继承父作用域的新作用域对象，且新的作用域从指令模板的根元素开始包含，即包含指令的根元素，不是指令template里的根元素，是包含指令属性的元素，或指令标签元素。<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&lt;!doctype html&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">ng-app</span>=<span class="string">"myApp"</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://ajax.googleapis.com/ajax/libs/angularjs/1.2.0-rc.3/angular.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></div><div class="line"></div><div class="line">  Outside myDirective: &#123;&#123; myProperty &#125;&#125;</div><div class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">my-directive</span> <span class="attr">ng-init</span>=<span class="string">"myProperty = 'wow, this is cool'"</span>&gt;</span> </div><div class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line"></div><div class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="xml"></span></div><div class="line">    angular.module('myApp', [])</div><div class="line">    .directive('myDirective', function() &#123;</div><div class="line">      return &#123;</div><div class="line">        restrict: 'A',</div><div class="line">        scope: true,</div><div class="line">        template: '<span class="tag">&lt;<span class="name">div</span>&gt;</span> Inside myDerective &#123;&#123;myProperty&#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span>'</div><div class="line">      &#125;;</div><div class="line">    &#125;)</div><div class="line">  <span class="tag">&lt;/<span class="name">script</span>&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>指令的scope属性为true，所以指令创建了自己的作用域，且创建的作用域继承父作用域。在指令上初始化的变量MyProperty只能在子作用域，即创建的指令中获取相应的值，父作用域不能对自作用域中的变量进行绑定，所以输出结果为：<br><img src="/images/scope-true.png" alt="scope-true.png"></p>
<h3 id="scope"><a href="#scope" class="headerlink" title="scope: {}"></a>scope: {}</h3><p>当scope的值是一个对象时，为指令创建的是隔离的作用域。即指令无法访问外面作用域中的对象，同时外部作用域也无法访问指令中的对象。且如果一个元素上有多个指令都使用了隔离作用域，只有一个可以生效。具有隔离作用域的指令最重要的使用场景是创建可复用的组件，组件可以在未知上下文中使用，并且可以避免污染所处的外部作用域。<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&lt;!doctype html&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">ng-app</span>=<span class="string">"myApp"</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://ajax.googleapis.com/ajax/libs/angularjs/1.2.0-rc.3/angular.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">body</span> <span class="attr">ng-init</span>=<span class="string">"myProperty = 'wow, this is cool'"</span>&gt;</span></div><div class="line"></div><div class="line">  Outside myDirective: &#123;&#123; myProperty &#125;&#125;</div><div class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">my-directive</span>&gt;</span>    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line"></div><div class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="xml"></span></div><div class="line">    angular.module('myApp', [])</div><div class="line">    .directive('myDirective', function() &#123;</div><div class="line">      return &#123;</div><div class="line">        restrict: 'A',</div><div class="line">        scope: &#123;&#125;,</div><div class="line">        template: '<span class="tag">&lt;<span class="name">div</span>&gt;</span> Inside myDerective &#123;&#123;myProperty&#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span>'</div><div class="line">      &#125;;</div><div class="line">    &#125;)</div><div class="line">  <span class="tag">&lt;/<span class="name">script</span>&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>在body上初始化变量myProperty，指令外部可以对其进行绑定，作用域为$rootScope，由于指令现在创建的是隔离的作用域，不能对外部的作用域继承，就无法对myProperty进行绑定，所以指令内部的myProperty绑定结果为空。输出结果如下：<br><img src="/images/scope-isolate.png" alt="scope.isolate.png"></p>
<h2 id="绑定策略"><a href="#绑定策略" class="headerlink" title="绑定策略"></a>绑定策略</h2><p>使用无数据的隔离作用域并不常见，AngularJS提供了几种方法能够将指令内部的隔离作用域，同指令外部的作用域进行数据绑定。</p>
<p>为了让新的指令作用域可以访问当前本地作用域中的变量，需要使用下面三种别名中的一种。</p>
<ol>
<li>@(or @attr):本地作用域属性，使用@符号将<strong>本地作用域</strong>同<strong>指令中DOM属性的值</strong>进行绑定，这样指令内部作用域可以访问使用外部作用域的变量，但并没有进行双向绑定。</li>
<li>=(or =attr):双向绑定，将本地作用域上的属性同父级作用域上属性进行双向绑定，本地属性会放映父数据模型中发生的改变。</li>
<li>&amp;(or &amp;attr):父级作用域绑定，为了在指令中运行父函数。对&amp;后的值进行设置后会生成一个指向父级作用域的包装函数。当要调用一个带有参数的父方法时，需要传递一个对象，对象的键是参数的名称，值是要传递给参数的内容。<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">ng-model</span>=<span class="string">"to"</span>/&gt;</span></div><div class="line"><span class="comment">&lt;!-- 调用指令 --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">scope-exapmle</span> <span class="attr">ng-model</span>=<span class="string">"to"</span> <span class="attr">on-send</span>=<span class="string">"sendMail(email)"</span> <span class="attr">from-name</span>=<span class="string">"air@fullstack.io"</span> /&gt;</span></div></pre></td></tr></table></figure>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">scope: &#123;</div><div class="line">	ngModel: &apos;=&apos;,// 将ngModel同指定的对象绑定</div><div class="line">	onSend: &apos;&amp;&apos;,// 将引用传递给这个方法</div><div class="line">	fromName: &apos;@&apos;// 储存与fromName相关联的字符串</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;指令作用域&quot;&gt;&lt;a href=&quot;#指令作用域&quot; class=&quot;headerlink&quot; title=&quot;指令作用域&quot;&gt;&lt;/a&gt;指令作用域&lt;/h2&gt;&lt;p&gt;首先在DOM中声明ng-app时，会创建$rootScope这个特殊的对象, 它是之后所有scope的父作用域。&lt;/
    
    </summary>
    
      <category term="AngularJS" scheme="http://lijingjing.top/categories/AngularJS/"/>
    
    
      <category term="directive" scheme="http://lijingjing.top/tags/directive/"/>
    
  </entry>
  
  <entry>
    <title>JS异步编程</title>
    <link href="http://lijingjing.top/blog/2017/03/13/JS%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/"/>
    <id>http://lijingjing.top/blog/2017/03/13/JS异步编程/</id>
    <published>2017-03-13T07:23:57.000Z</published>
    <updated>2017-03-13T09:39:54.000Z</updated>
    
    <content type="html"><![CDATA[<p>很多时候写代码，只是知道怎么写，并不知道为什么这么写，所以只能搬砖，并不能造轮子。现在处于疯狂扫盲状态，感觉每天都在发现新大陆，也越来越感受到自己知识的匮乏以及基础的不牢固。</p>
<h2 id="同步和异步"><a href="#同步和异步" class="headerlink" title="同步和异步"></a>同步和异步</h2><p>同步和异步的区别在于API或函数被调用后是否等它执行结束再调用之后的代码，也就是后面的代码是否要等前面的API或函数返回结果才能执行。</p>
<p>同步情况下，后面的代码必须要等前面的代码执行结束并返回结果才能执行。</p>
<p>异步情况下，后面的代码无需等待前面异步函数的执行结果，异步函数会在新的线程中去执行，执行结束后，结果会放在一个回调函数中进行处理，回调函数的作用是获取函数执行的结果，并进行之后的处理。异步函数的执行并不影响当前线程向下执行，所以后面的代码可以立即执行无需等待。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//一般异步函数的写法</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">asyncFun</span>(<span class="params">callback</span>)</span>&#123;</div><div class="line">	<span class="comment">// code can put here</span></div><div class="line">	<span class="comment">//asyncFunction是异步函数或异步API，执行会去开辟新的线程</span></div><div class="line">	asyncFunction(callback)&#123;</div><div class="line">		<span class="comment">// 异步函数要执行的代码</span></div><div class="line">		<span class="comment">// ...</span></div><div class="line">		<span class="keyword">var</span> result = 代码执行结果;</div><div class="line">		callback(result);</div><div class="line">	&#125;</div><div class="line">	<span class="comment">//code can put here</span></div><div class="line">	<span class="comment">//这里的函数不会等待asyncFunction的执行结果，result is undefined</span></div><div class="line">	<span class="keyword">return</span> result;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面的return语句中的result并不是异步函数的执行结果，首先从异步的概念来说，return语句会立即执行，并不会等待上面异步函数asyncFunction的执行结果；其次，函数中变量的作用域是函数作用域，asyncFucntion中的变量并不会被外面的函数访问到。</p>
<p>如果说，我把callback中要执行的代码放到asyncFunction中，并将其结果返回呢？ 那就变成同步啦。<br>下面的代码其实又变成同步函数了，外部声明的result会一直等待asyncFunction的执行结果给自己赋值，所以一般JS异步编程返回的都是回调函数，并不能直接返回结果。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//同步函数</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">asyncFun</span>(<span class="params">callback</span>)</span>&#123;</div><div class="line">	<span class="comment">// code can put here</span></div><div class="line">	<span class="comment">//asyncFunction是异步函数或异步API，执行会去开辟新的线程</span></div><div class="line">	<span class="keyword">var</span> result = asyncFunction(callback)&#123;</div><div class="line">		<span class="comment">// 异步函数要执行的代码</span></div><div class="line">		  ...</div><div class="line">		var result = 异步函数代码执行结果;</div><div class="line">		<span class="comment">//原来callback中的代码</span></div><div class="line">		  ...</div><div class="line">		var finalRes = 原来回调函数执行结果;</div><div class="line">		<span class="keyword">return</span> finalRes;</div><div class="line">	&#125;</div><div class="line">	<span class="comment">//code can put here</span></div><div class="line">	<span class="comment">//这里的函数不会等待asyncFunction的执行结果，result is undefined</span></div><div class="line">	<span class="keyword">return</span> result;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>或者你说在asyncFunction中返回最终处理结果finalRes不行吗，不赋值给外部变量。可以是可以，但是这样异步函数本身会变得非常臃肿，把数据处理逻辑等放到异步函数中去执行并不是好的设计，因为可能会有对数据不同的处理方式，这个时候怎么办，总不能写很多个异步函数，前面逻辑一样，只是后面处理逻辑有差别，这样对于代码复用来说太差了。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//同步函数</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">asyncFun</span>(<span class="params">callback</span>)</span>&#123;</div><div class="line">	<span class="comment">// code can put here</span></div><div class="line">	<span class="comment">//asyncFunction是异步函数或异步API，执行会去开辟新的线程</span></div><div class="line">	asyncFunction(callback)&#123;</div><div class="line">		<span class="comment">// 异步函数要执行的代码</span></div><div class="line">		<span class="comment">// ...</span></div><div class="line">		<span class="keyword">var</span> result = 代码执行结果;</div><div class="line">		<span class="comment">//原来callback中的代码</span></div><div class="line">		  ...</div><div class="line">		var finalRes = 原来回调函数执行结果;</div><div class="line">		<span class="keyword">return</span> finalRes;</div><div class="line">	&#125;</div><div class="line">	<span class="comment">//code can put here</span></div><div class="line">	<span class="comment">//这里的函数不会等待asyncFunction的执行结果，result is undefined</span></div><div class="line">	<span class="keyword">return</span> result;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="回调"><a href="#回调" class="headerlink" title="回调"></a>回调</h3><p>现在我才明白，我之前对回调的理解一直不正确，回调本身和同步异步没有任何关系，只是一般会通过回调对异步函数传参，用回调函数来处理异步函数的返回结果而已，同步编程的形式下，照样可以使用回调。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//同步函数</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">syncFun</span>(<span class="params">callback</span>)</span>&#123;</div><div class="line">	<span class="comment">// code can put here</span></div><div class="line">	 ...</div><div class="line">	var result = 代码执行结果；</div><div class="line">	<span class="keyword">var</span> res = callback(result);</div><div class="line">		</div><div class="line">	<span class="keyword">return</span> res;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>上面的代码是同步代码，但是也使用了回调函数，在一个函数中，将另一个函数作为参数，并在此函数中对其调用，这种函数调用形式成为回调。<br>所以，回调和异步同步并没有什么必然的因果关系。不能说使用了回调就是异步编程，除非你传入回调函数的函数本身是一个异步函数。但是异步函数会使用回调函数来对自己的执行结果进行相关的处理。</p>
<h2 id="阻塞与非阻塞"><a href="#阻塞与非阻塞" class="headerlink" title="阻塞与非阻塞"></a>阻塞与非阻塞</h2><p>阻塞和非阻塞是针对计算机资源的，单线程下，如果一段代码的执行长时间占用CPU，导致其他代码无法运行，那么对于其他代码来说此时的状态就是阻塞的，独占CPU一定要返回自己的执行结果而导致其他代码不能运行就会造成阻塞发生。</p>
<p>阻塞和非阻塞与同步和非同步没有什么关系，异步执行代码也会造成阻塞的发生，如果跑在异步线程上的代码是阻塞的，那么这段代码的执行仍会独占CPU，从而导致所有线程上的代码都不能执行，所以异步并不能消除阻塞。</p>
<p>Node.js里面的I/O是一种异步非阻塞的机制，其实实质是node底层开辟了新的线程去处理这些I/O，等结果返回后再通过回调函数回到Node的主线程中，Node本身只是单线程的，所有返回的结果也要在队列中等待顺序执行。Node利用事件轮询机制，来判断当前是否有任务需要处理。所以对于CPU密集型的操作，Node无法很好的进行处理，因为会阻塞主线程，导致队列中的任务一直等待主线程。所以对于CPU密集型操作，将其分为可重要执行的小块，通过process.nextTick将它分散开，让所有任务都有执行的机会。<br>其中node在执行任务的时候，会一次性把队列中的所有任务都拿出来，依次执行，如果全部顺利完成，则删除刚才取出的所有任务，等待下一次执行；如果中途出错，则删除已经完成的任务和出错的任务，等待下次执行；如果第一个就出错，则throw error.</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>同步就是阻塞，异步就是非阻塞，这种说法是不对的。同步异步是相对于后续代码的执行时间来讲，是立即执行后续代码还是等前一段代码返回执行结果后才执行；而阻塞和非阻塞是针对是否独占CPU导致所有代码都无法执行来定义，阻塞会导致所有线程上的代码都无法继续运行，都要进行等待。</p>
<p>以上是读过下面博客/回答之后自己的理解，可能理解还不是很正确，如果发现哪里表述不对，欢迎批评指正。<br>下面附参考内容链接：</p>
<ol>
<li><a href="http://www.cnblogs.com/chrischjh/p/4648395.html" target="_blank" rel="external">JavaScript异步编程</a></li>
<li><a href="http://www.ruanyifeng.com/blog/2012/12/asynchronous＿javascript.html" target="_blank" rel="external">JavaScript四种异步编程方法</a></li>
<li><a href="http://ju.outofmemory.cn/entry/86913" target="_blank" rel="external">Node.JS的单线程与异步的初步理解</a></li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;很多时候写代码，只是知道怎么写，并不知道为什么这么写，所以只能搬砖，并不能造轮子。现在处于疯狂扫盲状态，感觉每天都在发现新大陆，也越来越感受到自己知识的匮乏以及基础的不牢固。&lt;/p&gt;
&lt;h2 id=&quot;同步和异步&quot;&gt;&lt;a href=&quot;#同步和异步&quot; class=&quot;header
    
    </summary>
    
      <category term="JavaScript" scheme="http://lijingjing.top/categories/JavaScript/"/>
    
    
      <category term="异步编程" scheme="http://lijingjing.top/tags/%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>BOM</title>
    <link href="http://lijingjing.top/blog/2017/03/11/BOM/"/>
    <id>http://lijingjing.top/blog/2017/03/11/BOM/</id>
    <published>2017-03-11T03:25:33.000Z</published>
    <updated>2017-03-11T07:59:45.000Z</updated>
    
    <content type="html"><![CDATA[<p>BOM（Brower Object Model）为浏览器对象模型,提供了很多对象，用户访问浏览器的功能，功能与网页内容无关，因为浏览器厂商会按照各自的想法随意对其进行扩展，所以，浏览器之间公有的对象就成为了事实上的标准。这些对象在浏览器中得以存在，是由于它们提供了与浏览器的互操作性。W3C为了把浏览器中的JS最基本的部分标准化，已经将BOM的主要方面纳入了H5的规范中。</p>
<h2 id="window对象"><a href="#window对象" class="headerlink" title="window对象"></a>window对象</h2><p>BOM的核心对象是window，表示浏览器的一个实例，在浏览器中，window对象不仅是JS访问浏览器的一个接口，还是ECMAScript规定的Global对象。这意味着网页中定义的任何一个对象、变量和函数，都以window作为其Global对象，因此有权访问parseInt()等方法。</p>
<h3 id="全局作用域"><a href="#全局作用域" class="headerlink" title="全局作用域"></a>全局作用域</h3><p>由于window对象是ECMAScript中的Global对象，因此所有在全局作用域中声明的变量、函数都会成为window对象的属性和方法。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> age = <span class="number">29</span>;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayAge</span>(<span class="params"></span>)</span>&#123;</div><div class="line">	alert(<span class="keyword">this</span>.age);</div><div class="line">&#125;</div><div class="line"></div><div class="line">alert(<span class="built_in">window</span>.age); <span class="comment">//29</span></div><div class="line">sayAge(); <span class="comment">//29,由于sayAge()存在于全局作用域中，因此this.age被映射到window.age</span></div><div class="line"><span class="built_in">window</span>.sayAge(); <span class="comment">//29</span></div></pre></td></tr></table></figure></p>
<p><strong>定义全局变量和在window对象上直接定义属性还是有差别的：全局变量不能通过delete操作符删除，而直接定义在window对象上的属性，可以被其删除。</strong> 使用var语句添加的window属性有一个名为[[configurable]]的特性，这个特性的值为false，因此这样定义的属性不能通过delete操作符删除。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> age=<span class="number">29</span>;</div><div class="line"><span class="built_in">window</span>.color=<span class="string">"red"</span>;</div><div class="line"></div><div class="line"><span class="keyword">delete</span> <span class="built_in">window</span>.age;<span class="comment">//IE&lt;9时抛出异常，在其他浏览器中返回false</span></div><div class="line"></div><div class="line"><span class="keyword">delete</span> <span class="built_in">window</span>.color;<span class="comment">//在IE&lt;9时抛出异常，其他浏览器中返回true</span></div><div class="line"></div><div class="line">alert(<span class="built_in">window</span>.age);<span class="comment">// 29</span></div><div class="line">alert(<span class="built_in">window</span>.color);<span class="comment">// undefined</span></div></pre></td></tr></table></figure></p>
<p>尝试访问未声明的变量会抛出错误，但是通过查询window对象，可以知道某个可能为生命的变量是否存在。变量未声明去使用会抛出错误，但是对象中的属性没有声明去使用，返回undefined。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> newValue = oldValue;<span class="comment">//未声明oldValue抛出错误</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> newValue = <span class="built_in">window</span>.oldValue;<span class="comment">//由于这是一次属性查询，所以不会抛出错误</span></div></pre></td></tr></table></figure></p>
<h3 id="窗口关系及框架"><a href="#窗口关系及框架" class="headerlink" title="窗口关系及框架"></a>窗口关系及框架</h3><p>如果页面包含框架，那么每个框架都有自己的window对象，并且保存在frames集合中。在frame集合中，可以通过数值索引（从0开始，从左到右，从上到下）或者框架名称来访问相应的window对象。每个window对象都有一个name属性，其中包括框架的名称。<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></div><div class="line">	<span class="tag">&lt;<span class="name">head</span>&gt;</span></div><div class="line">		<span class="tag">&lt;<span class="name">title</span>&gt;</span>Frameset Examples<span class="tag">&lt;/<span class="name">title</span>&gt;</span></div><div class="line">	<span class="tag">&lt;/<span class="name">head</span>&gt;</span></div><div class="line">	<span class="tag">&lt;<span class="name">frameset</span> <span class="attr">rows</span>=<span class="string">"160,*"</span>&gt;</span></div><div class="line">		<span class="tag">&lt;<span class="name">frame</span> <span class="attr">sec</span>=<span class="string">"frame.htm"</span> <span class="attr">name</span>=<span class="string">"topFrame"</span>&gt;</span></div><div class="line">		<span class="tag">&lt;<span class="name">frameset</span> <span class="attr">cols</span>=<span class="string">"50%,50%"</span>&gt;</span></div><div class="line">			<span class="tag">&lt;<span class="name">frame</span> <span class="attr">src</span>=<span class="string">"anotherframe.htm"</span> <span class="attr">name</span>=<span class="string">"leftFrame"</span>&gt;</span></div><div class="line">			<span class="tag">&lt;<span class="name">frame</span> <span class="attr">src</span>=<span class="string">"yetanotherframe.htm"</span> <span class="attr">name</span>=<span class="string">"rightFrame"</span>&gt;</span></div><div class="line">		<span class="tag">&lt;/<span class="name">frameset</span>&gt;</span></div><div class="line">	<span class="tag">&lt;/<span class="name">frameset</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>下图显示了，在最高层窗口中，访问上述例子中每个框架的不同方式：<br><img src="/images/frameset-dom.png" alt="frameset-dom"><br><img src="/images/frameset-page.png" alt="frameset-page"></p>
<h4 id="top对象、parent对象和self对象"><a href="#top对象、parent对象和self对象" class="headerlink" title="top对象、parent对象和self对象"></a>top对象、parent对象和self对象</h4><p>top对象始终指向最高（最外）层的框架，也就是浏览器窗口，使用它可以保证在一个框架中正确地访问另一个框架。因为对于在一个框架中编写的任何代码，其中的window对象指向的都是那个框架的特定实例，而非最高层的框架。<br>与top相对的另一个window对象时parent，parent始终只想当前框架的直接上层框架。在某些情况下，parent可能等于top，但是没有框架的情况下，parent一定等于top（此时它们都等于window）。<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></div><div class="line">	<span class="tag">&lt;<span class="name">head</span>&gt;</span></div><div class="line">		<span class="tag">&lt;<span class="name">title</span>&gt;</span>Frameset Examples<span class="tag">&lt;/<span class="name">title</span>&gt;</span></div><div class="line">	<span class="tag">&lt;/<span class="name">head</span>&gt;</span></div><div class="line">		<span class="tag">&lt;<span class="name">frameset</span> <span class="attr">cols</span>=<span class="string">"50%,50%"</span> <span class="attr">name</span>=<span class="string">"anotherframeset"</span>&gt;</span></div><div class="line">			<span class="tag">&lt;<span class="name">frame</span> <span class="attr">src</span>=<span class="string">"blue.html"</span> <span class="attr">name</span>=<span class="string">"blueFrame"</span>&gt;</span></div><div class="line">			<span class="tag">&lt;<span class="name">frame</span> <span class="attr">src</span>=<span class="string">"red.html"</span> <span class="attr">name</span>=<span class="string">"redFrame"</span>&gt;</span></div><div class="line">		<span class="tag">&lt;/<span class="name">frameset</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></div></pre></td></tr></table></figure></p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></div><div class="line">	<span class="tag">&lt;<span class="name">head</span>&gt;</span></div><div class="line">		<span class="tag">&lt;<span class="name">title</span>&gt;</span>anotherframeset<span class="tag">&lt;/<span class="name">title</span>&gt;</span></div><div class="line">	<span class="tag">&lt;/<span class="name">head</span>&gt;</span></div><div class="line">		<span class="tag">&lt;<span class="name">frameset</span> <span class="attr">cols</span>=<span class="string">"50%,50%"</span> <span class="attr">name</span>=<span class="string">"anotherframeset"</span>&gt;</span></div><div class="line">			<span class="tag">&lt;<span class="name">frame</span> <span class="attr">src</span>=<span class="string">"blue.html"</span> <span class="attr">name</span>=<span class="string">"blueFrame"</span>&gt;</span></div><div class="line">			<span class="tag">&lt;<span class="name">frame</span> <span class="attr">src</span>=<span class="string">"red.html"</span> <span class="attr">name</span>=<span class="string">"redFrame"</span>&gt;</span></div><div class="line">		<span class="tag">&lt;/<span class="name">frameset</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></div></pre></td></tr></table></figure>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></div><div class="line">	<span class="tag">&lt;<span class="name">head</span>&gt;</span></div><div class="line">		<span class="tag">&lt;<span class="name">title</span>&gt;</span>blue<span class="tag">&lt;/<span class="name">title</span>&gt;</span></div><div class="line">	<span class="tag">&lt;/<span class="name">head</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span><span class="javascript"></span></div><div class="line">	<span class="built_in">document</span>.writeln(<span class="string">"window.name="</span>+<span class="built_in">window</span>.name+<span class="string">"&lt;br&gt;"</span>);</div><div class="line">	<span class="built_in">document</span>.writeln(<span class="string">"top.name="</span>+top.name+<span class="string">"&lt;br&gt;"</span>);</div><div class="line">	<span class="built_in">document</span>.writeln(<span class="string">"parent.name="</span>+parent.name+<span class="string">"&lt;br&gt;"</span>);</div><div class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div></pre></td></tr></table></figure>
<p><img src="/images/anotherframeset.png" alt="anotherframeset"></p>
<p><strong>除非最高层窗口是通过window.open()打开的，否则其window对象的name属性不会包含任何值，所以上面的top.name都为空</strong></p>
<p>self对象始终指向window；实际上，self和window对象可以互换使用。引入self对象的目的只是为了与top和parent对象对象起来，因此不包含任何其他值。<br>上述所有对象都是window对象的属性，可以通过window.top、window.parent等形式来访问。所以，可以将不同层次的window对象连缀起来，例如window.parent.parent.frames[0]；</p>
<blockquote>
<p>在使用框架的情况下，浏览器中会存在多个Global对象，在每个框架中定义的全局变量会自动成为框架中window对象的属性。由于每个window对象都包含原声类型的构造函数，因此每个框架都有一套自己的构造函数，这些构造函数一一对应，但不相等。例如： top.Object并不等于top.frames[0].Object。这个问题会影响到对跨框架传递的对象使用instanceof操作符。</p>
</blockquote>
<h3 id="窗口位置"><a href="#窗口位置" class="headerlink" title="窗口位置"></a>窗口位置</h3><p>不同浏览区对于窗口位置的属性和方法的定义会有差别。IE/Safari/Opera/Chrome都提供screenLeft和screenTop属性，分别用于表示浏览器窗口相对于显示器屏幕左边和上边的信息。Firefox则提供screenX和screenY来获取相同的屏幕信息。Opera虽然提供screenX和screenY属性，但是和screenLeft和screenRight属性并不对应，所以不该在Opera中使用screenX和screenY。跨浏览器获取窗口左边和上边位置信息的代码如下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> leftPos = (<span class="keyword">typeof</span> <span class="built_in">window</span>.screenLeft == <span class="string">'number'</span>) ? <span class="built_in">window</span>.screenLeft:<span class="built_in">window</span>.screenX;</div><div class="line"></div><div class="line"><span class="keyword">var</span> topPos = (<span class="keyword">typeof</span> <span class="built_in">window</span>.screenTop == <span class="string">'number'</span>) ? <span class="built_in">window</span>.screenTop:<span class="built_in">window</span>.screenY;</div></pre></td></tr></table></figure></p>
<p>使用moveTo()和moveBy()方法有可能将窗口精确地移动到一个新的位置。<br>moveTo(新位置的X坐标值，新位置的Y坐标值);<br>moveBy(水平方向移动的像素数，垂直方向上移动的像素数)；<br>以上两个方法，可能会被浏览器禁用，同时也只能对最外层的window对象使用，不适用于框架。<br><strong>实验发现上述两个方法对浏览器没有作用，window.open打开的窗口才有作用。</strong></p>
<h3 id="窗口大小"><a href="#窗口大小" class="headerlink" title="窗口大小"></a>窗口大小</h3><p>由于浏览器之间标准的不一致，无法确定浏览器窗口本身的大小，但是可以取得页面视口的大小,移动设备上window.innerHeight/window.innerWidth保存着可见视口，随着页面的缩放，值会改变。<br>navigator.userAgent可以检测用户使用的浏览器设备。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> pageWidth = <span class="built_in">window</span>.innerWidth;</div><div class="line"><span class="keyword">var</span> pageHeight = <span class="built_in">window</span>.innerHeight;</div><div class="line"><span class="keyword">if</span>(<span class="keyword">typeof</span> pageWidth !== <span class="string">'number'</span>)&#123;</div><div class="line">	<span class="keyword">if</span>(<span class="built_in">window</span>.compatMode == <span class="string">'CSS1Compat'</span>)&#123;<span class="comment">//标准模式下</span></div><div class="line">	pageWidth = <span class="built_in">document</span>.documentElement.clientWidth;</div><div class="line">	pageHeight = <span class="built_in">document</span>.documentElement.clientHeight;</div><div class="line">&#125;<span class="keyword">else</span>&#123;</div><div class="line">	pageWidth = <span class="built_in">document</span>.body.clientWidth;</div><div class="line">	pageHeight = <span class="built_in">document</span>.body.clientHeight;</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>resizeTo(浏览器窗口的新宽度，新高度)和resizeBy(新窗口与原窗口的宽度差，高度差)方法同上述的moveTo()和moveBy()</p>
<h3 id="导航和打开窗口"><a href="#导航和打开窗口" class="headerlink" title="导航和打开窗口"></a>导航和打开窗口</h3><p>window.open(要加载的URL，窗口目标，一个特性字符串，一个表示新页面是否取代浏览器路世纪路中当前加载页面的布尔值);通常只须传递第一个参数，最后一个参数只在不打开新窗口的情况下使用。<br>如果为window.open()函数传递第二个参数，而且该参数是已有窗口或框架的名称，那么就会在具有该名称的窗口或框架中加载第一个参数指定的URL。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">	<span class="built_in">window</span>.open(<span class="string">"http://www.baidu.com/"</span>,<span class="string">"topFrame"</span>);</div><div class="line"><span class="comment">//等同于 &lt;a href="http://www.baidu.com/" target="topFrame"&gt;&lt;/a&gt;</span></div></pre></td></tr></table></figure></p>
<p>如果有名为“topFrame”的窗口或者框架，就会在该窗口或框架加载这个URL；否则就会创建一个新窗口，并命名为”topFrame”。此外，第二个参数也可以是: _self,_parent,_top,_blank;</p>
<h4 id="弹出窗口"><a href="#弹出窗口" class="headerlink" title="弹出窗口"></a>弹出窗口</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> wroxWin = <span class="built_in">window</span>.open(<span class="string">"http://www.wrox.com/"</span>,<span class="string">"wroxWindow"</span>,<span class="string">"height=400,width=400,top=10,left=10,resizable=yes"</span>);</div><div class="line">                     </div><div class="line">wroxWin.resizeTo(<span class="number">500</span>,<span class="number">500</span>);</div><div class="line">wroxWin.moveTo(<span class="number">10</span>,<span class="number">10</span>);</div><div class="line">wroxWin.close();</div></pre></td></tr></table></figure>
<p>弹出窗口关闭后，窗口的引用仍然还在，但除了使用wroxin.closed属性检测是否关闭外，没有其他用处。<br>新创建的窗口有一个opner属性，保存打开它的原始窗口，但原始窗口中并没有这样的指针指向弹出窗口。窗口并不跟踪记录它们打开的弹出窗口，所以必要的时候只能手动实现跟踪。<br>有些浏览器会在独立的进程中运行每个交钱也，当一个标签页打开另一个标签页时，如果两个window对象之间需要彼此通信，那么新的标签页就不能运行在独立的进程中。在Chrome中，将新创建的标签页的opener属性置为null，则表示在单独的进程中运行标签页，即不需要与打开它的标签页进行通信。标签页之间一旦断开联系，就没有办法进行恢复。</p>
<h4 id="安全限制"><a href="#安全限制" class="headerlink" title="安全限制"></a>安全限制</h4><p>弹出窗口是否被屏蔽，包括浏览器本身屏蔽或者安装相应的程序进行屏蔽。浏览器本身屏蔽会将window.open()的返回值置为null，程序屏蔽会报错。检测弹出窗口是否被屏蔽并不会影响浏览器显示与被屏蔽的弹出窗口有关的信息。<br>检测代码如下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> blocked = <span class="literal">false</span>;</div><div class="line"></div><div class="line"><span class="keyword">try</span>&#123;</div><div class="line">	<span class="keyword">var</span> wroxWin = <span class="built_in">window</span>.open(<span class="string">"http://www.wrox.com/"</span>,<span class="string">"_blank"</span>);</div><div class="line">	<span class="keyword">if</span>(wroxWin == <span class="literal">null</span>)&#123;</div><div class="line">		blocked = <span class="literal">true</span>;</div><div class="line">	&#125;</div><div class="line">&#125;<span class="keyword">catch</span>(ex)&#123;</div><div class="line">	blocked = <span class="literal">true</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">if</span>(blocked)&#123;</div><div class="line">	alert(<span class="string">"This popup was blocked!"</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="间歇调用和超时调用"><a href="#间歇调用和超时调用" class="headerlink" title="间歇调用和超时调用"></a>间歇调用和超时调用</h4><p>间歇调用，每个一段时间就会执行指定代码；超时调用，设置一个时间，指定时间后执行相关代码。<br>setInterval(function,time);//间歇调用<br>setTimeout(function,time);//超时调用，也可以传递字符串，但性能差，不建议使用</p>
<p>JS是一个单线程序的解释器，一定时间内只能执行一段代码，为了控制要执行的代码，就有一个JS任务队列。任务会按照依次添加到队列中顺序执行，setTimeout的第二个参数就是告诉JS要过多长时间，把当前任务添加到任务队列中。如果队列是空的，那么添加的代码会立即执行；如果队列不为空，那么就要等前面的代码执行完了之后再执行。</p>
<p>setTimeout()会返回一个数值ID，这个超市调用IS是计划执行代码的唯一标识，可以通过它在时间未到之前取消尚未执行的超市调用计划：clearTimeout(tiemoutId)。</p>
<p>超时调用的代码都是在全局作用域中执行，因此函数中的this在非严格模式下指向window对象，在严格模式下是undefined。</p>
<p>使用超时调用来模拟间歇调用时一种最佳模式。因为在使用超时调用时没必要跟踪超时调用ID，每次执行完后，不设置另一次调用，就会自动停止。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> num = <span class="number">0</span>;</div><div class="line"><span class="keyword">var</span> max = <span class="number">10</span>;</div><div class="line"><span class="keyword">var</span> intervalId = <span class="literal">null</span>;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">incrementNumber</span>(<span class="params"></span>)</span>&#123;</div><div class="line">	num++;</div><div class="line">	<span class="keyword">if</span>(num == max)&#123;</div><div class="line">		clearInterval(intervalId);</div><div class="line">		alert(<span class="string">"done!"</span>);</div><div class="line">	&#125; </div><div class="line">	</div><div class="line">&#125;</div><div class="line"></div><div class="line">setInterval(incrementNumber,<span class="number">1000</span>);</div></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> num = <span class="number">0</span>;</div><div class="line"><span class="keyword">var</span> max = <span class="number">10</span>;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">incrementNumber</span>(<span class="params"></span>)</span>&#123;</div><div class="line">	num++;</div><div class="line">	<span class="keyword">if</span>(num &lt; max)&#123;</div><div class="line">		setTimeout(incrementNumber,<span class="number">1000</span>);</div><div class="line">	&#125; </div><div class="line">	<span class="keyword">else</span>&#123;</div><div class="line">	alert(<span class="string">"done!"</span>)</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">setTimeOut(incrementNumber,<span class="number">1000</span>);</div></pre></td></tr></table></figure>
<h4 id="系统对话框"><a href="#系统对话框" class="headerlink" title="系统对话框"></a>系统对话框</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">alert(string);</div><div class="line"><span class="keyword">var</span> confirmResult = confirm(string);<span class="comment">//true or false</span></div><div class="line"><span class="keyword">var</span> promptResult = prompt(<span class="string">"要显示的文本"</span>，“文本输入域的默认值”);<span class="comment">//cancel后返回null，其余返回输入的文本内容</span></div><div class="line"></div><div class="line"><span class="built_in">window</span>.print();<span class="comment">//弹出打印窗口</span></div><div class="line"><span class="built_in">window</span>.find();<span class="comment">//弹出当前页面查找窗口</span></div></pre></td></tr></table></figure>
<h2 id="location对象"><a href="#location对象" class="headerlink" title="location对象"></a>location对象</h2><p>提供与当前窗口中加载的文档有关的信息，还提供了一些导航功能。location既是window对象的属性，也是document对象的属性。即，window.location和document.location引用的是同一个对象。<br>location对象不仅保存当前文档信息，还可以将URL解析为独立的片段，让开发人员通过不同的属性访问这些片段。</p>
<table>
<thead>
<tr>
<th>属性名</th>
<th>例子</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>hash</td>
<td>“#contents”</td>
<td>返回URL中的hash(#号后跟0或多个字符串)，如果URL中不包含散列，返回空字符串</td>
</tr>
<tr>
<td>host</td>
<td>“www.wrox.com:80”</td>
<td>返回服务器名称和端口号（如果有）</td>
</tr>
<tr>
<td>hostname</td>
<td>“www.worx.com”</td>
<td>返回不带端口号的服务器名称</td>
</tr>
<tr>
<td>href</td>
<td>“<a href="http://www.wrox.com/" target="_blank" rel="external">http://www.wrox.com/</a>“</td>
<td>返回当前加载页面的完成URL。而location对象的toString()方法也返回这个值</td>
</tr>
<tr>
<td>pathname</td>
<td>“/WileyCDA”</td>
<td>返回URL中的目录和（或）文件名</td>
</tr>
<tr>
<td>port</td>
<td>“8080”</td>
<td>返回URL中执行的端口号，如果URL中不包括端口号，则这个属性返回空字符串</td>
</tr>
<tr>
<td>protocol</td>
<td>“http:”</td>
<td>返回页面使用的协议。“http:”或者”https:”</td>
</tr>
<tr>
<td>search</td>
<td>“?q=javascript”</td>
<td>返回URL的查询字符串，这个字符串以问号开头</td>
</tr>
</tbody>
</table>
<h3 id="查询字符串参数"><a href="#查询字符串参数" class="headerlink" title="查询字符串参数"></a>查询字符串参数</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">getQueryStringArgs</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  <span class="keyword">var</span> qs = (location.search.length &gt; <span class="number">0</span>) ? location.search.substring(<span class="number">1</span>) : <span class="string">""</span>;</div><div class="line">  <span class="keyword">var</span> args = &#123;&#125;;</div><div class="line">  </div><div class="line">  <span class="keyword">var</span> items = qs.length &gt; <span class="number">0</span> ? qs.split(<span class="string">'&amp;'</span>):[];</div><div class="line">  <span class="keyword">var</span> item = <span class="literal">null</span>;</div><div class="line">  <span class="keyword">var</span> name = <span class="literal">null</span>;</div><div class="line">  <span class="keyword">var</span> value = <span class="literal">null</span>;</div><div class="line">  <span class="keyword">var</span> len = items.length;</div><div class="line">  </div><div class="line">  <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; len; i++)&#123;</div><div class="line">  		item = items[i].split(<span class="string">'='</span>);</div><div class="line">  		name = <span class="built_in">decodeURIComponent</span>(item[<span class="number">0</span>]);</div><div class="line">  		value = <span class="built_in">decodeURIComponent</span>(item[<span class="number">1</span>]);</div><div class="line">  		</div><div class="line">  		<span class="keyword">if</span>(name.length)&#123;</div><div class="line">  			args[name] = value;</div><div class="line">  		&#125;	</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> args;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> args = getQueryStringArgs();</div><div class="line"><span class="comment">// ?q=javascript&amp;num=10</span></div><div class="line">alert(args[<span class="string">"q"</span>]);<span class="comment">//"javascript"</span></div><div class="line">alert(args[<span class="string">"num"</span>]);<span class="comment">//"10"</span></div></pre></td></tr></table></figure>
<h3 id="位置操作"><a href="#位置操作" class="headerlink" title="位置操作"></a>位置操作</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">location.assign(URL);<span class="comment">//立即打开新的URL，逼格在浏览器的历史记录中生成一条记录</span></div><div class="line"></div><div class="line"><span class="comment">//下面的方法，实际上调用的都是location.assign(URL)</span></div><div class="line"><span class="built_in">window</span>.location = URL;</div><div class="line">location.href = URL;</div></pre></td></tr></table></figure>
<p>通过修改location对象的属性，可以改变当前加载的页面，每次修改location的属性（hash除外），页面都会以新的URL重新加载。hash只是在原有的URL后加hash内容。</p>
<p>location.replace(URL);不会在历史记录中生成新记录，所以无法通过导航的后退回到之前的页面。</p>
<p>location.reload();不传入参数的情况下，以最有效的方式重新加载。如果页面自上次请求以来并没有改变过，页面就会从浏览器缓存中重新加载；强制从服务器重新加载，则需要传递参数true:location.reload(true);</p>
<h2 id="navigator对象"><a href="#navigator对象" class="headerlink" title="navigator对象"></a>navigator对象</h2><p>通过navigator对象的属性，可以检测浏览器系统所在相关信息，以及浏览器品牌版本等信息。</p>
<h3 id="检测插件"><a href="#检测插件" class="headerlink" title="检测插件"></a>检测插件</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//检测插件（IE中无效）</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">hasPlugin</span>(<span class="params">name</span>)</span>&#123;</div><div class="line">	<span class="keyword">var</span> name = name.toLowerCase();</div><div class="line">	<span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; navigator.plugins.length; i++ )&#123;</div><div class="line">		<span class="keyword">if</span>(navigator.plugins[i].name.toLowerCase().indexOf(name) &gt; <span class="number">-1</span>)&#123;</div><div class="line">			<span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	<span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line">alert(hasPlugin(<span class="string">"Flash"</span>));</div><div class="line">alert(hasPlugin(<span class="string">"QuickTime"</span>));</div><div class="line"></div><div class="line"><span class="comment">//检测插件，IE</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">hasIEPlugin</span>(<span class="params">name</span>)</span>&#123;</div><div class="line">	<span class="keyword">try</span>&#123;</div><div class="line">	<span class="comment">//在IE中检测插件的唯一方法是使用专有的ActiveObject类型，并尝试创建一个特定插件的实例</span></div><div class="line">		<span class="keyword">new</span> ActiveObject(name);</div><div class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">	&#125;<span class="keyword">catch</span>(ex)&#123;</div><div class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">//IE是以COM对象使用唯一标识符来标识插件的</span></div><div class="line">alert(hasPlugin(<span class="string">"ShockwaveFlash.ShockwaveFlash"</span>));</div><div class="line"></div><div class="line">alert(hasPlugin(<span class="string">"QuickTime,QuickTime"</span>));</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">//通用的方法，为每个插件单独写函数测试</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">hasFlash</span>(<span class="params"></span>)</span>&#123;</div><div class="line">	<span class="keyword">var</span> result = hasPlugin(<span class="string">"Flash"</span>);</div><div class="line">	<span class="keyword">if</span>(!result)&#123;</div><div class="line">		result = hasIEPlugin(<span class="string">"ShockwaveFlash.ShockwaveFlash"</span>);</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> result;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>plugins集合有一个名为refresh()的方法，用于刷新plugins以反映最新安装的插件。这个方法接收一个参数，表示是否应该重新加载页面的一个布尔值。如果值为true,则会重新加载包含插件的所有页面；否则，只更新plugins集合，不重新加载页面。</p>
<p>###注册处理程序<br>navigator的registerContentHandler()和registerProtocolHandler()方法、这两个方法可以让一个站点指明可以处理特定类型的信息。RSS源、ftp或mailto等的处理程序等。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">navigator.registerContentHandler(<span class="string">"application/rss+xml"</span>,<span class="string">"http://www.somereader.com?feed=%s"</span>,<span class="string">"Some Reader"</span>);</div><div class="line"><span class="comment">//第一个参数是RSS源的MIME类型、第二个参数是应该接收RSS源URL的URL，其中%s表示RSS源URL,由浏览器自动插入。当下一次请求RSS源时，浏览器会打开指定的URL，而相应的Web应用程序将以适当方式来处理该请求。</span></div></pre></td></tr></table></figure></p>
<h2 id="screen对象"><a href="#screen对象" class="headerlink" title="screen对象"></a>screen对象</h2><p>screen对象对编程作用不大。基本上只表明客户端的能力，包括浏览器窗口外部的显示器的信息，如像素宽度和高度等。</p>
<h2 id="history对象"><a href="#history对象" class="headerlink" title="history对象"></a>history对象</h2><p>history对象是window对象的属性。因此每个浏览器窗口、每个标签乃至每个框架，都有自己的history对象与特定的window对象关联。使用go()方法，可以再用户的历史记录中任意跳转。正数表示向前跳转，负数表示向后跳转。如果传递的是字符串，则会跳转到历史记录中包含该字符串的第一个位置，可能后退也可能前进，要看哪个位置最近。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">history.go();</div><div class="line">history,back();</div><div class="line">history.forward();</div><div class="line">history.length;</div></pre></td></tr></table></figure></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>浏览器对象模型（BOM）以window对象为依托，表示浏览器窗口以及页面可见区域。同时window对象还是Global对象，因为所有全局变量和函数都是它的属性，且所有原生的构造函数及其他函数也都存在不它的命名空间下。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;BOM（Brower Object Model）为浏览器对象模型,提供了很多对象，用户访问浏览器的功能，功能与网页内容无关，因为浏览器厂商会按照各自的想法随意对其进行扩展，所以，浏览器之间公有的对象就成为了事实上的标准。这些对象在浏览器中得以存在，是由于它们提供了与浏览器的
    
    </summary>
    
      <category term="JavaScript" scheme="http://lijingjing.top/categories/JavaScript/"/>
    
    
      <category term="BOM" scheme="http://lijingjing.top/tags/BOM/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode(一)</title>
    <link href="http://lijingjing.top/blog/2017/01/19/LeetCode-%E4%B8%80/"/>
    <id>http://lijingjing.top/blog/2017/01/19/LeetCode-一/</id>
    <published>2017-01-19T12:36:11.000Z</published>
    <updated>2017-01-20T15:07:58.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Hamming-Distance"><a href="#Hamming-Distance" class="headerlink" title="Hamming Distance"></a>Hamming Distance</h3><h4 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h4><p>The Hamming distance between two integers is the number of positions at which the corresponding bits are different. Given two integers x and y, calculate the Hamming distance.<br>Note: 0 ≤ x, y &lt; 2^31.</p>
<pre><code>Input: x = 1, y = 4

Output: 2

Explanation:
1   (0 0 0 1)
4   (0 1 0 0)
       ↑   ↑

The above arrows point to positions where the corresponding bits are different.
</code></pre><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><h5 id="提交代码"><a href="#提交代码" class="headerlink" title="提交代码"></a>提交代码</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * @param &#123;number&#125; x</div><div class="line"> * @param &#123;number&#125; y</div><div class="line"> * @return &#123;number&#125;</div><div class="line"> */</div><div class="line"></div><div class="line"><span class="keyword">var</span> hammingDistance = <span class="function"><span class="keyword">function</span> (<span class="params">x, y</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> quotientX = x;</div><div class="line">    <span class="keyword">var</span> remainderX = <span class="number">0</span>;</div><div class="line">    <span class="keyword">var</span> quotientY = y;</div><div class="line">    <span class="keyword">var</span> remainderY = <span class="number">0</span>;</div><div class="line">    <span class="keyword">var</span> distance = <span class="number">0</span>;</div><div class="line"></div><div class="line">    <span class="keyword">while</span> (!(quotientX == <span class="number">0</span> &amp;&amp; remainderX == <span class="number">0</span>) || !(quotientY == <span class="number">0</span> &amp;&amp; remainderY == <span class="number">0</span>)) &#123;</div><div class="line"></div><div class="line"></div><div class="line">        remainderX = quotientX % <span class="number">2</span>;</div><div class="line">        quotientX = <span class="built_in">parseInt</span>(quotientX / <span class="number">2</span>);</div><div class="line"></div><div class="line">        remainderY = quotientY % <span class="number">2</span>;</div><div class="line">        quotientY = <span class="built_in">parseInt</span>(quotientY / <span class="number">2</span>);</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (remainderX != remainderY) &#123;</div><div class="line">            distance += <span class="number">1</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> distance;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h5 id="Top-solution"><a href="#Top-solution" class="headerlink" title="Top solution"></a>Top solution</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * @param &#123;number&#125; x</div><div class="line"> * @param &#123;number&#125; y</div><div class="line"> * @return &#123;number&#125;</div><div class="line"> */</div><div class="line"></div><div class="line"><span class="keyword">var</span> hammingDistance = <span class="function"><span class="keyword">function</span> (<span class="params">x, y</span>) </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">var</span> xor = x^y;</div><div class="line">    <span class="keyword">var</span> distance = <span class="number">0</span>;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">32</span>; i++)</div><div class="line">    <span class="comment">//判断条件可以改为xor&gt;0,不必每次循环31次</span></div><div class="line">    &#123;</div><div class="line">        distance+=xor&gt;&gt;i &amp; <span class="number">1</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> distance;</div><div class="line"></div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * @param &#123;number&#125; x</div><div class="line"> * @param &#123;number&#125; y</div><div class="line"> * @return &#123;number&#125;</div><div class="line"> */</div><div class="line"></div><div class="line"><span class="keyword">var</span> hammingDistance = <span class="function"><span class="keyword">function</span> (<span class="params">x, y</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Number</span>(x ^ y).toString(<span class="number">2</span>).replace(<span class="regexp">/0/g</span>, <span class="string">''</span>).length;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h3 id="Number-Complement"><a href="#Number-Complement" class="headerlink" title="Number Complement"></a>Number Complement</h3><h4 id="描述-1"><a href="#描述-1" class="headerlink" title="描述"></a>描述</h4><p>Given a positive integer, output its complement number. The complement strategy is to flip the bits of its binary representation. Note:</p>
<pre><code>1.    The given integer is guaranteed to fit within the range of a 32-bit signed integer.
2.    You could assume no leading zero bit in the integer’s binary representation.
</code></pre><p><strong>Example 1</strong></p>
<pre><code>Input: 5
Output: 2
Explanation: The binary representation of 5 is 101 (no leading zero bits), and its complement is 010. So you need to output 2.
</code></pre><p><strong>Example 2</strong></p>
<pre><code>Input: 1
Output: 0
Explanation: The binary representation of 1 is 1 (no leading zero bits), and its complement is 0. So you need to output 0.
</code></pre><h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><h5 id="提交代码-1"><a href="#提交代码-1" class="headerlink" title="提交代码"></a>提交代码</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * @param &#123;number&#125; num</div><div class="line"> * @return &#123;number&#125;</div><div class="line"> */</div><div class="line"><span class="keyword">var</span> findComplement = <span class="function"><span class="keyword">function</span> (<span class="params">num</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> topBitIndex, max;</div><div class="line">    <span class="keyword">if</span> (num &gt; <span class="number">0</span>) &#123;</div><div class="line">        topBitIndex = <span class="built_in">parseInt</span>(<span class="built_in">Math</span>.log(num) / <span class="built_in">Math</span>.LN2) + <span class="number">1</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span> &#123;</div><div class="line">        topBitIndex = <span class="number">1</span>;</div><div class="line"></div><div class="line">    &#125;</div><div class="line">    max = <span class="built_in">Math</span>.pow(<span class="number">2</span>, (topBitIndex)) - <span class="number">1</span>;</div><div class="line"></div><div class="line">    <span class="keyword">var</span> result = max ^ num;</div><div class="line">    <span class="keyword">return</span> result;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h5 id="Top-Solution"><a href="#Top-Solution" class="headerlink" title="Top Solution"></a>Top Solution</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * @param &#123;number&#125; num</div><div class="line"> * @return &#123;number&#125;</div><div class="line"> */</div><div class="line"><span class="keyword">var</span> findComplement = <span class="function"><span class="keyword">function</span> (<span class="params">num</span>) </span>&#123;</div><div class="line">   <span class="keyword">var</span> mask = ~<span class="number">0</span>;</div><div class="line">   <span class="keyword">while</span> (num &amp; mask)&#123;</div><div class="line">       mask &lt;&lt;= <span class="number">1</span>;</div><div class="line">       &#125;<span class="comment">//位运算求解最高位为1的位置</span></div><div class="line">   <span class="keyword">return</span> ~mask &amp; ~num;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h3 id="Max-Consecutive-Ones"><a href="#Max-Consecutive-Ones" class="headerlink" title="Max Consecutive Ones"></a>Max Consecutive Ones</h3><h4 id="描述-2"><a href="#描述-2" class="headerlink" title="描述"></a>描述</h4><p>Given a binary array, find the maximum number of consecutive 1s in this array.</p>
<p><strong>Example 1:</strong></p>
<pre><code>Input: [1,1,0,1,1,1]
Output: 3
Explanation:
The first two digits or the last three digits are consecutive 1s.

The maximum number of consecutive 1s is 3.
</code></pre><h4 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h4><h5 id="提交代码-2"><a href="#提交代码-2" class="headerlink" title="提交代码"></a>提交代码</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> findMaxConsecutiveOnes = <span class="function"><span class="keyword">function</span>(<span class="params">nums</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> temp = <span class="number">0</span>;</div><div class="line">    <span class="keyword">var</span> max = <span class="number">0</span>;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; nums.length; i++)&#123;</div><div class="line">        <span class="keyword">if</span>(nums[i] == <span class="number">1</span>)</div><div class="line">        &#123;</div><div class="line">            temp+=<span class="number">1</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span>&#123;</div><div class="line">            <span class="keyword">if</span>(temp &gt; max)</div><div class="line">            &#123;</div><div class="line">                max = temp;</div><div class="line">            &#125;</div><div class="line">            temp = <span class="number">0</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span>(temp &gt; max)</div><div class="line">    &#123;</div><div class="line">        max = temp;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> max;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h5 id="Top-Solution-1"><a href="#Top-Solution-1" class="headerlink" title="Top Solution"></a>Top Solution</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> findMaxConsecutiveOnes = <span class="function"><span class="keyword">function</span>(<span class="params">nums</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> sum = <span class="number">0</span>;</div><div class="line">    <span class="keyword">var</span> max = <span class="number">0</span>;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; nums.length; i++)&#123;</div><div class="line"></div><div class="line">        sum = (sum+nums[i])*nums[i];</div><div class="line">        <span class="keyword">if</span>(sum &gt; max)</div><div class="line">        &#123;</div><div class="line">        max = sum;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> max;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ol>
<li>JS中所有的数都是浮点数，所以整除’/‘得到的是小数。</li>
<li>关于二进制的相关运算要考虑运用位运算来解决。</li>
<li>换底公式求解以2为底的对数运算，Math.log(num) / Math.LN2</li>
<li>~否运算，求解时会连最高位符号位一起求解。</li>
<li>负数由补码表示，即正数取反（连同符号位）后加1，得到对应的补码。否运算操作结束后得到补码，减1再取反得到相应的十进制值，然后符号位不变。</li>
</ol>
<pre><code>3: 00000000000000000000000000000011
~3: 11111111111111111111111111111100(第一位为1，表示负数，此为补码形式)
转化为十进制，减1：            
11111111111111111111111111111011
取反：
00000000000000000000000000000100
即为： -4
简单记忆为： 一个数与自身取反值相加，值为-1.
</code></pre>]]></content>
    
    <summary type="html">
    
      Hamming Distance &amp;   Number Complement &amp;  Max Consecutive One
    
    </summary>
    
      <category term="LeetCode" scheme="http://lijingjing.top/categories/LeetCode/"/>
    
    
      <category term="Easy" scheme="http://lijingjing.top/tags/Easy/"/>
    
  </entry>
  
  <entry>
    <title>JS闭包</title>
    <link href="http://lijingjing.top/blog/2017/01/02/JS%E9%97%AD%E5%8C%85/"/>
    <id>http://lijingjing.top/blog/2017/01/02/JS闭包/</id>
    <published>2017-01-02T13:59:04.000Z</published>
    <updated>2017-01-04T08:00:25.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>闭包是指有权访问另一个函数作用域中的变量的函数。一般创建方式是在一个函数内部创建另一个函数。</p>
<p>JS代码块支持函数作用域，即定义在函数中的参数和变量在函数外部是不可见的，而在一个函数内部任何位置定义的变量，在该函数内部任何地方都可见（函数内部变量声明提升）。</p>
<h2 id="作用域链"><a href="#作用域链" class="headerlink" title="作用域链"></a>作用域链</h2><h3 id="一般函数"><a href="#一般函数" class="headerlink" title="一般函数"></a>一般函数</h3><p>当某个函数被调用时，会创建一个执行环境（execution context）及相应的作用域链。然后使用arguments和其他命名参数的值来初始化函数的活动对象(activation object)。但在作用域链中，外部函数的活动对象始终处于第二位，外部函数的外部函数的活动对象处于第三位…依次类推，直至到作为作用域链终点的全局执行环境。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">compare</span>(<span class="params">v1,v2</span>)</span></div><div class="line">&#123;</div><div class="line">	<span class="keyword">if</span>(v1&lt;v2)&#123;</div><div class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</div><div class="line">	&#125;<span class="keyword">else</span> <span class="keyword">if</span>(v1&gt;v2)&#123;</div><div class="line">		<span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">	&#125;<span class="keyword">else</span>&#123;</div><div class="line">		<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> result = compare(<span class="number">5</span>,<span class="number">10</span>);</div></pre></td></tr></table></figure>
<p>以上代码先定义compare()函数，然后又在全局作用域中调用它。当第一次调用compare()时，会创建一个包含this、arguments、v1和v2的活动对象。全局执行环境的变量对象(包含this、result和compare)在compare()执行环境的作用域链中则处于第二位。具体如下图所示：</p>
<p><img src="/images/function1.png" alt="execution context"></p>
<p>后台的每个执行环境都有一个表示变量的对象，即变量对象。全局环境的变量对象始终存在，而像compare()函数这样的局部环境的变量函数，则只在函数执行的过程中存在。</p>
<p>在创建compare()函数时，会创建一个预先包含全局变量对象的作用域链，这个作用域链被保存在内部[[scope]]属性中。当调用compar()函数时，会为函数创建一个执行环境，然后通过赋值函数的[[scope]]属性中的对象构建起执行环境的作用域链。此后，又有一个活动对象（在此作为变量对象）被创建并被推入执行环境作用域链的顶端。对于上例，compare()函数的执行环境，包括本地活动对象和全局变量对象。<strong>作用域链本质上是一个指向变量对象的指针列表，它只引用但不实际包含变量对象。</strong></p>
<p>无论什么时候在函数中访问一个变量时，就会从作用域链中搜索具有相应名字的变量。一般，当函数执行完毕后，局部活动对象就会被销毁，内存中只保存全局作用域（全局执行环境的变量对象）。</p>
<h3 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h3><p>在函数内部定义的函数会包含它所在的函数（即外部函数）的活动对象，将其添加到它的作用域链中。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">createComparisonFunction</span>(<span class="params">propertyName</span>)</span>&#123;</div><div class="line">	<span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">obj1,obj2</span>)</span>&#123;</div><div class="line">		<span class="keyword">var</span> v1 = obj1[propertyName];</div><div class="line">		<span class="keyword">var</span> v2 = obj2[propertyName];</div><div class="line">		</div><div class="line">		<span class="keyword">if</span>(v1 &gt; v2)&#123;</div><div class="line">			<span class="keyword">return</span> <span class="number">-1</span>;</div><div class="line">		&#125;<span class="keyword">else</span> <span class="keyword">if</span>(v1 &lt; v2)&#123;</div><div class="line">			<span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">		&#125;<span class="keyword">else</span>&#123;</div><div class="line">			<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//创建函数</span></div><div class="line"><span class="keyword">var</span> compare = createComparisonFunction(<span class="string">"name"</span>);</div><div class="line"></div><div class="line"><span class="comment">//调用函数</span></div><div class="line"><span class="keyword">var</span> result = compare(&#123;<span class="attr">name</span> : <span class="string">"Jingjing"</span>&#125;,&#123;<span class="attr">name</span> : <span class="string">"JJ"</span>&#125;);</div><div class="line"></div><div class="line"><span class="comment">//解除对匿名函数的引用（以便释放内存）</span></div><div class="line">compare = <span class="literal">null</span>;</div></pre></td></tr></table></figure></p>
<p>下面以图来具体说明以上代码作用域链：</p>
<ol>
<li><p>createComparisonFunction(“name”)执行中<br><img src="/images/closure1.png" alt="execution context"></p>
</li>
<li><p>createComparisonFunction(“name”)执行结束后<br><img src="/images/closure2.png" alt="execution context"></p>
</li>
<li><p>compare({name : “Jingjing”},{name : “JJ”})执行中<br><img src="/images/closure3.png" alt="execution context"></p>
</li>
<li><p>compare({name : “Jingjing”},{name : “JJ”})执行结束后<br><img src="/images/closure4.png" alt="execution context"></p>
</li>
<li><p>compare置为null后<br><img src="/images/closure5.png" alt="execution context"></p>
</li>
</ol>
<h2 id="闭包与变量"><a href="#闭包与变量" class="headerlink" title="闭包与变量"></a>闭包与变量</h2><p>作用域链的配置，使闭包只能取得包含函数中任何变量的<strong>最后</strong>一个值。闭包保存的是整个变量对象，而不是某个特殊的变量。   </p>
<p>下面举个最常见的例子来说明：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">createFunctions</span>(<span class="params"></span>)</span>&#123;</div><div class="line">	<span class="keyword">var</span> result = <span class="keyword">new</span> <span class="built_in">Array</span>();</div><div class="line">	</div><div class="line">	<span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++)&#123;</div><div class="line">		result[i] = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">			<span class="keyword">return</span> i;</div><div class="line">		&#125;;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	<span class="keyword">return</span> result;</div><div class="line">&#125;</div><div class="line"></div><div class="line">createFunctions();</div><div class="line"><span class="comment">//result[0] = 10;</span></div><div class="line"><span class="comment">//result[1] = 10;</span></div><div class="line"><span class="comment">//result[2] = 10;</span></div><div class="line"><span class="comment">//...</span></div><div class="line"><span class="comment">//result[9] = 10;</span></div></pre></td></tr></table></figure>
<p>期望是每个函数返回自己的索引值，即result[0]=0,result[1]=1….但实际上，因为每个函数的作用域链中都保存着createFunctions的活动对象（active object）,每个函数其实引用的都是同一个变量i。当createFunction()返回后，i的值变为10，所以每个函数内部的i的值都是10。</p>
<p>解决方法：通过创建另一个匿名函数，强制让闭包的行为符合预期。具体实现如下所示：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">createFunctions</span>(<span class="params"></span>)</span>&#123;</div><div class="line">	<span class="keyword">var</span> result = <span class="keyword">new</span> <span class="built_in">Array</span>();</div><div class="line">	</div><div class="line">	<span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++)&#123;</div><div class="line">		result[i] = <span class="function"><span class="keyword">function</span>(<span class="params">num</span>)</span>&#123;</div><div class="line">			<span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">				<span class="keyword">return</span> num;</div><div class="line">			&#125;</div><div class="line">		&#125;(i);</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">createFunctions();</div><div class="line"><span class="comment">//result[0] = 0;</span></div><div class="line"><span class="comment">//result[1] = 1;</span></div><div class="line"><span class="comment">//result[2] = 2;</span></div><div class="line"><span class="comment">//...</span></div><div class="line"><span class="comment">//result[9] = 9;</span></div></pre></td></tr></table></figure>
<p>上述例子中，没有把闭包直接赋值给数组，而是定义了一个匿名函数，把匿名函数的执行结果赋值给数组。匿名函数有一个参数num，即匿名函数的返回值。在调用每个匿名函数的时候，传入变量i，由于函数参数按值传递，所以将变量i的当前值复制给参数num。而在这个匿名函数内部，又创建了一个访问num的闭包。</p>
<p><em>在给result数组赋值的时候调用了匿名函数，调用过程中会有对应的执行环境以及活动对象，匿名函数执行完，匿名函数的闭包，即result数组中的每个函数的作用域链中都有自己调用时匿名函数的活动对象。</em></p>
<p>这样，result数组中的每个函数都有自己num变量的一个副本，因此就可以返回各自不同的值了。</p>
<h2 id="关于this对象"><a href="#关于this对象" class="headerlink" title="关于this对象"></a>关于this对象</h2><h3 id="匿名函数"><a href="#匿名函数" class="headerlink" title="匿名函数"></a>匿名函数</h3><p>闭包中使用this会出现一些问题。this对象实在运行时基于函数的执行环境绑定的：在全局函数中，this等于window，而当函数被作为某个对象的方法调用时，this等于那个对象。 <strong>不过匿名函数的执行环境具有全局性。</strong> 因此，匿名函数的this对象通常指向window。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> name = <span class="string">"The window"</span>;</div><div class="line"></div><div class="line"><span class="keyword">var</span> object = &#123;</div><div class="line">	<span class="attr">name</span>: <span class="string">"My object"</span>,</div><div class="line">	</div><div class="line">	<span class="attr">getNameFunction</span> : <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">		<span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">			<span class="keyword">return</span> <span class="keyword">this</span>.name;<span class="comment">// "TypeError: this is undefined" (在严格模式下)</span></div><div class="line">		&#125;</div><div class="line">	&#125;;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">alert(object.getNameFunction()());</div><div class="line"><span class="comment">// "The window"(在非严格模式下，匿名函数的this指向window)</span></div></pre></td></tr></table></figure>
<h3 id="访问外部函数的特殊变量"><a href="#访问外部函数的特殊变量" class="headerlink" title="访问外部函数的特殊变量"></a>访问外部函数的特殊变量</h3><p>每个函数在被调用时都会自动取得两个特殊变量： this和arguments。内部函数在搜索这两个变量时，只会搜索到自己的活动对象位置，因此永远不可能直接访问外部函数中的这两个变量。不过把外部作用域中的this对象保存在一个闭包中能够访问的对象里，就可以让闭包访问外部函数的this对象了。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> name = <span class="string">"The window"</span>;</div><div class="line"></div><div class="line"><span class="keyword">var</span> object = &#123;</div><div class="line">	<span class="attr">name</span>: <span class="string">"My object"</span>,</div><div class="line">	</div><div class="line">	<span class="attr">getNameFunction</span> : <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">	</div><div class="line">	<span class="keyword">var</span> that = <span class="keyword">this</span>;</div><div class="line">	</div><div class="line">   <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">   		<span class="keyword">return</span> that.name;   </div><div class="line">   		&#125;;		</div><div class="line">	&#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">alert(object.getNameFunction()());</div><div class="line"><span class="comment">// "My Object"</span></div></pre></td></tr></table></figure>
<p>在定义匿名函数之前，把this对象赋值给了that变量。定义了闭包之后，闭包也可以访问这个变量，因为它是我们在包含函数中特意声明的变量，及时在函数返回后，that也仍然引用着object。</p>
<p>同样，如果想要访问作用域中的arguments对象，必须将该对象的引用保存在另一个闭包能够访问的变量中。</p>
<h3 id="特殊情况"><a href="#特殊情况" class="headerlink" title="特殊情况"></a>特殊情况</h3><p>细微的语法变化，可能会意外修改this的值。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> name = <span class="string">"The window"</span>;</div><div class="line"></div><div class="line"><span class="keyword">var</span> object = &#123;</div><div class="line">	<span class="attr">name</span>: <span class="string">"My object"</span>,</div><div class="line">	</div><div class="line">	<span class="attr">getName</span> : <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">   		<span class="keyword">return</span> <span class="keyword">this</span>.name;   	</div><div class="line">	&#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">object.getName();<span class="comment">// "My object"</span></div><div class="line">(object.getName)();<span class="comment">//"My object"</span></div><div class="line">(object.getName = object.getName)();<span class="comment">//"The window",在非严格模式下;严格模式下，‘TypeError: this is undefined’</span></div></pre></td></tr></table></figure>
<p>第一行调用，this.name就是object.name。<br>第二行调用，加上括号后，引用函数，this的值得到了维持，因为object.getName和（object.getName）的定义是相同的。<br>因为第三行调用，先执行了一条赋值语句，然后再调用赋值后的结果。因为这个赋值表达式的值是函数本身，所以this的值不能得到维持，在非严格模式下，this指向window。</p>
]]></content>
    
    <summary type="html">
    
      JS闭包总结
    
    </summary>
    
      <category term="javascript" scheme="http://lijingjing.top/categories/javascript/"/>
    
    
      <category term="闭包" scheme="http://lijingjing.top/tags/%E9%97%AD%E5%8C%85/"/>
    
  </entry>
  
  <entry>
    <title>再见，2016。你好，2017</title>
    <link href="http://lijingjing.top/blog/2017/01/02/%E5%86%8D%E8%A7%81%EF%BC%8C2016/"/>
    <id>http://lijingjing.top/blog/2017/01/02/再见，2016/</id>
    <published>2017-01-02T05:36:26.000Z</published>
    <updated>2017-01-02T13:56:43.000Z</updated>
    
    <content type="html"><![CDATA[<p>新年快乐。</p>
<p>矫情还是在深夜发作比较好。这样发完之后就可以安稳的去睡觉。这是我2017年1月1日凌晨给好友发祝福信息时说的话。</p>
<p>放一张图片，假装我2016年很快乐。<br><img src="/images/my2016.jpeg" alt="2016"></p>
<p>本来想着2016年就这么默默地过去就好了吧，毕竟我太期待2017了，迫不及待想要拥抱新的生活，去展开新的诗篇。我的2016真的不怎么美好，一点儿都不留恋、怀念以及舍不得，更不用说什么感恩了。但是中午实在没有感觉想要学习，在元旦假期的最后一天中午，利用这段时间来写点儿东西好了。</p>
<p>如果非要感谢什么的话，那我只能感谢2016年让我成长很多。</p>
<p>2016年的一月份和二月份好像还在做最美食的项目。记得过年那几天还一直在深夜开过语音会议，但是做最美食真的真的让我成长不少。我记得半夜解决拍照上传的问题，效率出奇的高。然后觉着很多问题真的是你认真去解决就可以解决好的。期间和策女神和鑫爷做项目也让我很开心。虽然那段日子繁忙但是现在回想起来好像还可以说是美好的时光了吧。和学弟还有亦谦住各种五星级酒店，拍拍照片，然后开会的时候大家一起嘻嘻哈哈怼甲方不合理的需求，真的很喜欢这种team，大家都很努力，很认真，一起成长。然后还记得和妈妈在包饺子的时候收到了任老师发来的新年红包，超级开心。寒假的时候还想着在2016年要努力学技术，成为一个厉害的前端。然而…</p>
<p>然后好像就开学了吧。开学后发现同组的小明大神已经搭建好了博客，虽然我一直说要搭建，但是懒癌患者一直在拖延，在小明的刺激下，一晚上搭好了现在这个博客，当然期间换过一次主题，现在用的主题自己其实改了不少东西。</p>
<p>接着就是蔡老师劝我回可视化组做自己组的项目。其实我当时也是打算做完软工项目就回归的。但是蔡老师好像以为我不想回来，苦口婆心和我说了很多。发生了很多事情的三月份就开始了。三月初，发小霖霖来上海玩，一起浪了几天，很感谢陈思远带我们去朱家角。虽然事实证明的确没什么好玩的，但毕竟也去打过卡了。</p>
<p>霖霖走后的第二天参加年级聚会，看完电影就很想认识一个男孩子，然而在一群老司机的带领下我最后还是翻了船，然后，我的三、四、五、六、七、八、九、十月份就在各种纠结与不甘心以及莫名其妙的各种复杂情绪下度过。期间的所有不安与失落。估计也就只有我自己知道了，现在回想起来，自己真的没做好什么，但也不能说自己做错什么吧，毕竟我不觉着真心喜欢一个人，并努力去争取的过程有什么不对以及需要忏悔的，如果有的话，也是由于第一次这么主动，不能处理好所有的慌乱与紧张以及不正常的自己吧。</p>
<p>三月份侯欣然回国，又剪了一次短发，以至于我现在非常坚定的确定我还是比较喜欢长发的自己。</p>
<p>三月份开始做爱淘课的项目，第一次和小明合作项目，然后现在我发现我们两个还是比较适合一起努力学习写自己喜欢的代码。</p>
<p>一直到十月份真的就是各种慌乱、不安以及乱七八糟。四五六月份的自己在发疯，真的没什么好记录的吧。</p>
<p>七月份的时候每晚都在跑步，然后也会背一些单词，还一度很坚定的要出国。不过之后还是觉着好好毕业，找份好工作比较适合我吧。从高中开始跑步，大学断断续续也一直在坚持，然后研究生也在断断续续的跑步，和小明一起跑过步，和望姐一起跑过，也和胡洁琼一起跑过。最后发现自己还不错。就像刚开始上大学的时候，一个人从图书馆出来去操场跑步再回宿舍一样。今年就是各种怀念原来潇洒而且很酷的自己。</p>
<p>暑假左右在做实验室的外高桥项目。真的是一个很讨厌的项目，用别人的前端框架，就是各种复制拷贝什么的，唯一有挑战的问题还是IE8兼容，宝宝真的想少做点这种项目。</p>
<p>九月份的时候见回国的吕秋一，丢了只用了三个月的6S，然后九月底玩滑板还很惨的把胳膊摔骨折了，以至于我的十一假期有三个星期，但我觉着也因为我在家那三个星期，让自己平静了不少吧，可以想很多乱七八糟的事情，整理自己的心情。</p>
<p>十月份回学校，之前的水务项目也不用自己去跟了。然后就是接着做九月份接的二次外包项目。因为自己之前已经做的差不多了，之后还有大饼帮我一起做，由于胳膊的原因，也没有让我做很多事情。但是做这个二次外包却意外的逼我自己去写了angular的directive，让我觉着也还不错。</p>
<p>十一月份开始自己好像比原来开心点了。开始学钢琴，每晚会去光彪楼弹一两个小时的钢琴。期间还去牙防所拔了四颗一直折磨我的智齿，还补了一颗蛀牙。</p>
<p>哦，对了，今年还当了实验室的大总管，下半年又做了教务办的助管。这些，对我来说，都是一种锻炼吧。虽然说实话，如果有选择我肯定不会主动去做这些。</p>
<p>十二月份就是准备实验室的双旦晚会，准备了好久，还好我的学弟学妹们都比较捧场。很感谢期间一直帮我的胡洁琼以及最后一天帮我布置会场的小明、佳薇、顺婷以及水哥。还有开题的事情，谢谢一起奋斗的小明以及毕业的学长余博。</p>
<p>2016年好像心理的成长更多，但是我也觉着这样挺好的，不至于让自己一直处于小孩子的心态。</p>
<p>我的幼稚我的可笑我的焦躁我的无理取闹以及我所有慌乱与不安，都随着2016一起消失或者停留在过去吧。</p>
<p>我的未来，希望做一个温柔明媚骄傲的自己，成长为一个很厉害的前端程序媛。</p>
<p>2017目标以及计划：</p>
<ol>
<li>好好梳理前端知识，学习react，总结angular经验，动手写node。</li>
<li>好好写毕设，顺利毕业，希望不用在18年的元旦赶论文。</li>
<li>能找到一份自己喜欢的实习以及工作。</li>
<li>早睡早起，好好对自己。</li>
<li>有时间可以去旅行。</li>
<li>如果能成长为一个厉害的前端就更好了。</li>
<li>坚持学钢琴。</li>
<li>好好跑步。</li>
<li>多读书。</li>
<li>希望18年回首的时候，上面的计划与目标都不是空话。</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;新年快乐。&lt;/p&gt;
&lt;p&gt;矫情还是在深夜发作比较好。这样发完之后就可以安稳的去睡觉。这是我2017年1月1日凌晨给好友发祝福信息时说的话。&lt;/p&gt;
&lt;p&gt;放一张图片，假装我2016年很快乐。&lt;br&gt;&lt;img src=&quot;/images/my2016.jpeg&quot; alt=&quot;20
    
    </summary>
    
      <category term="随笔" scheme="http://lijingjing.top/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="年终总结" scheme="http://lijingjing.top/tags/%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>ES6 let&amp;const</title>
    <link href="http://lijingjing.top/blog/2017/01/01/ES6-let-const/"/>
    <id>http://lijingjing.top/blog/2017/01/01/ES6-let-const/</id>
    <published>2017-01-01T15:01:48.000Z</published>
    <updated>2017-01-02T12:54:52.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="let"><a href="#let" class="headerlink" title="let"></a>let</h1><h2 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h2><p>JS的变量作用域是函数域而不是块级作用域，这意味着在块语句中定义的变量，实际上是在包含函数中而非语句中创建的。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">outputNumbers</span>(<span class="params">count</span>)</span>&#123;</div><div class="line">	<span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>; i&lt;count; i++)&#123;</div><div class="line">		alert(i);</div><div class="line">	&#125;</div><div class="line">	alert(i);</div><div class="line">&#125;</div><div class="line"><span class="comment">//outputNumbers(3);</span></div><div class="line"><span class="comment">//alert(0);</span></div><div class="line"><span class="comment">//alert(1);</span></div><div class="line"><span class="comment">//alert(2);</span></div><div class="line"><span class="comment">//alert(3);</span></div></pre></td></tr></table></figure></p>
<p>函数中定义了for循环，在Java、C++等语言中，变量i只会在for循环的语句块中有定义，循环一旦结束，变量i就会被销毁。但在JS中，变量i是定义在函数outputNumbers中的活动对象，因此从它定义开始，就可以在函数内部随处访问它。即使像下面错误的重新声明一个变量，也不会修改它的值。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">outputNumbers</span>(<span class="params">count</span>)</span>&#123;</div><div class="line">	<span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>; i&lt;count; i++)&#123;</div><div class="line">		alert(i);</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">var</span> i;</div><div class="line">	alert(i);</div><div class="line">&#125;</div><div class="line"><span class="comment">//outputNumbers(3);</span></div><div class="line"><span class="comment">//alert(0);</span></div><div class="line"><span class="comment">//alert(1);</span></div><div class="line"><span class="comment">//alert(2);</span></div><div class="line"><span class="comment">//alert(3);</span></div></pre></td></tr></table></figure></p>
<p>JS中函数声明会被提升。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">outputNumbers(<span class="number">3</span>);</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">outputNumbers</span>(<span class="params">count</span>)</span>&#123;</div><div class="line">	alert(i);</div><div class="line">	<span class="comment">//变量i被提升，alert出undefined。</span></div><div class="line">	<span class="comment">//如果变量	没有提升，则会抛出i is not defined的异常。</span></div><div class="line">	</div><div class="line">	<span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>; i&lt;count; i++)&#123;</div><div class="line">		alert(i);</div><div class="line">	&#125;		</div><div class="line">&#125;</div><div class="line"><span class="comment">//alert: undefined;</span></div><div class="line"><span class="comment">//alert: 0;</span></div><div class="line"><span class="comment">//alert: 1;</span></div><div class="line"><span class="comment">//alert: 2;</span></div></pre></td></tr></table></figure></p>
<h2 id="JS模仿块级作用域"><a href="#JS模仿块级作用域" class="headerlink" title="JS模仿块级作用域"></a>JS模仿块级作用域</h2><p>JS从来不会告诉你是否多次声明了一个变量，遇到多次声明的情况，只会对后续的声明视而不见（不过，它会执行后续生命中的变量初始化）。<br>匿名函数可以模仿块级作用域。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//将函数声明，加上圆括号变成函数表达式</span></div><div class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  <span class="comment">//这里是块级作用域</span></div><div class="line">&#125;)();</div></pre></td></tr></table></figure></p>
<p>以上代码定义并立即调用了一个匿名函数。将函数声明包含在一对圆括号中，表示它实际上是一个函数表达式。</p>
<p>无论在什么地方，只要临时需要一些变量，就可以使用私有作用域：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">outputNumbers</span>(<span class="params">count</span>)</span>&#123;</div><div class="line">	(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">		<span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>; i&lt;count; i++)&#123;</div><div class="line">			alert(i);</div><div class="line">		&#125;	</div><div class="line">	&#125;)();</div><div class="line">	</div><div class="line">	alert(i);<span class="comment">//i is not defined</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在for循环外部插入了一个私有作用域，在匿名函数中定义的任何变量，都会在执行结束时被销毁，因此，变量i只能在循环中使用，使用后立即被销毁，而在私有作用域中能够访问变量count，是因为这个匿名函数是一个闭包，它能够访问包含作用域中的所有变量。</p>
<h2 id="为什么要有块级作用域"><a href="#为什么要有块级作用域" class="headerlink" title="为什么要有块级作用域"></a>为什么要有块级作用域</h2><p>一般来说，我们都应该尽量向去全局作用域添加变量和函数。在一个由很多开发人员共同参与的大型应用程序中，过多的全局变量和函数很容易导致命名冲突。而通过创建私有作用域，每个开发人员既可以使用自己的变量，又不必担心搞乱全局作用域。</p>
<h2 id="let特性"><a href="#let特性" class="headerlink" title="let特性"></a>let特性</h2><ol>
<li>let声明的变量拥有块级作用域。</li>
<li>let声明的全局变量不是全局对象的属性。即不能通过window.变量名的方式访问这些变量。它们只存在于一个不可见的块的作用域中，这个块理论上是web页面中运行的所有JS代码的外层块。</li>
<li>形如for(let x …)的循环在每次迭代时都会为x创建新的绑定,即每个循环是不同的变量绑定，占用不同的内存，不会发生循坏最后引用的是同一个内存的变量。这种情况适用于for-of/for-in/以及传统分号分割的循环。</li>
<li>let声明的变量不会被提升。在声明之前使用变量会报错。</li>
<li>var声明的变量可以重复声明，但是let重复声明会报错。</li>
</ol>
<h1 id="const"><a href="#const" class="headerlink" title="const"></a>const</h1><h2 id="ES5-防篡改对象"><a href="#ES5-防篡改对象" class="headerlink" title="ES5 防篡改对象"></a>ES5 防篡改对象</h2><h3 id="不可扩展对象"><a href="#不可扩展对象" class="headerlink" title="不可扩展对象"></a>不可扩展对象</h3><p>默认情况下，所有对象都是可以扩展的。即，任何时候都可以向对象中添加属性和方法。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> person = &#123;<span class="attr">name</span>: <span class="string">'Jingjing'</span>&#125;;</div><div class="line">person.age = <span class="number">23</span>;<span class="comment">//为person对象添加age属性</span></div></pre></td></tr></table></figure></p>
<p>使用Object.preventExtensions()方法可以防止之后给对象添加属性和方法。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> person = &#123;<span class="attr">name</span>: <span class="string">'Jingjing'</span>&#125;;</div><div class="line"><span class="built_in">Object</span>.preventExtensions(person);</div><div class="line"></div><div class="line">person.age = <span class="number">23</span>;</div><div class="line">alert(person.age);<span class="comment">//非严格模式下undefined；严格模式下抛出错误</span></div></pre></td></tr></table></figure></p>
<p>虽然不可以添加新成员，但是可以修改和删除已有的成员。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> person = &#123;<span class="attr">name</span>: <span class="string">'Jingjing'</span>&#125;;</div><div class="line">alert(<span class="built_in">Object</span>.isExtensible(person));<span class="comment">//true</span></div><div class="line"></div><div class="line"><span class="built_in">Object</span>.preventExtensions(person);</div><div class="line">person.name = <span class="string">"JJ"</span>;</div><div class="line"></div><div class="line">alert(<span class="built_in">Object</span>.isExtensible(person));<span class="comment">//false</span></div><div class="line">alert(person.name);<span class="comment">// JJ</span></div></pre></td></tr></table></figure></p>
<h3 id="密封的对象"><a href="#密封的对象" class="headerlink" title="密封的对象"></a>密封的对象</h3><p>密封对象不可扩展，而且已有的成员的[[Configurable]]特性将设置为false。意味着不能删除属性和方法，因为不能使用Object.defineProperty()把数据属性修改为访问器属性,或者相反。属性值是可以修改的。</p>
<p>密封对象，可以使用Object.seal()方法。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> person = &#123;<span class="attr">name</span>: <span class="string">'Jingjing'</span>&#125;;</div><div class="line"><span class="built_in">Object</span>.seal(person);</div><div class="line"></div><div class="line">person.age = <span class="number">23</span>;</div><div class="line">alert(person.age);<span class="comment">// undefined</span></div><div class="line"></div><div class="line"><span class="keyword">delete</span> person.name;</div><div class="line">alert(person.name);<span class="comment">// 'Jingjing'</span></div><div class="line"><span class="comment">//严格模式下，上面两个alert均会抛出错误。</span></div></pre></td></tr></table></figure></p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">	var person = &#123;name: 'Jingjing'&#125;;</div><div class="line">	alert(Object.isExtensible(person));//true</div><div class="line">	alert(Object.isSealed(person));/false</div><div class="line">	</div><div class="line">	Object.seal(person);</div><div class="line">	</div><div class="line">	alert(Object.isExtensible(person));//false</div><div class="line">alert(Object.isSealed(person));/true</div></pre></td></tr></table></figure>
<h3 id="冻结的对象"><a href="#冻结的对象" class="headerlink" title="冻结的对象"></a>冻结的对象</h3><p>最严格的防篡改级别是冻结对象。冻结的对象既不可扩展，又是密封的。而且对象数据属性[[Writable]]特性会被设置为false。如果定义[[Set]]函数，访问器属性仍然是科协的。</p>
<p>对于JS库的作者来说，冻结对象很有用。因为JS库最怕有人意外（或有意）修改库中的核心对象。冻结（或密封）主要的库函数能够防止这些问题。</p>
<p>ES5定义的Object.freeze()方法可以用来冻结对象。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//严格模式下会抛出错误</span></div><div class="line">	<span class="keyword">var</span> person = &#123;<span class="attr">name</span>: <span class="string">'Jingjing'</span>&#125;;</div><div class="line">	<span class="built_in">Object</span>.freeze(person);</div><div class="line">	</div><div class="line">	person.age = <span class="number">23</span>;</div><div class="line">	alert(person.age); <span class="comment">// undefined</span></div><div class="line">	</div><div class="line">	<span class="keyword">delete</span> person.name;</div><div class="line">	alert(person.name);<span class="comment">// 'Jingjing'</span></div><div class="line">	</div><div class="line">	person.name = <span class="string">'JJ'</span>;</div><div class="line">	alert(person.name);<span class="comment">// 'Jingjing</span></div></pre></td></tr></table></figure></p>
<p>可以用Object.isFrozen()方法来检测冻结对象。也可以用Object.isExtensible()和Object.isSealed()检测冻结对象将分别返回false和true来检测。<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">var person = &#123;name: 'Jingjing'&#125;;</div><div class="line">alert(Object.isExtensible(person));//true</div><div class="line">alert(Object.isSealed(person));/false</div><div class="line">alert(Object.isFrozen(person));//false</div><div class="line"></div><div class="line">Object.freeze(person);</div><div class="line"></div><div class="line">alert(Object.isExtensible(person));//false</div><div class="line">alert(Object.isSealed(person));/true</div><div class="line">alert(Object.isFrozen(person));//true</div></pre></td></tr></table></figure></p>
<h2 id="const特性"><a href="#const特性" class="headerlink" title="const特性"></a>const特性</h2><p>const和其他语言中常量定义一样，即声明的变量要在声明时赋值，不可以随意修改。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> a ;<span class="comment">//会报SyntaxError,必须赋值</span></div></pre></td></tr></table></figure></p>
<p>对于原始类型来说，由于内存中存的就是具体的值，被赋值之后是不可以修改的；但是对于变量，由于存的是地址，地址不可变，但是地址所指的空间里的内容可以改变的。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> a = <span class="string">"test"</span>;</div><div class="line">a = <span class="string">"update"</span>;<span class="comment">//会报SyntaxError</span></div></pre></td></tr></table></figure></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> name = &#123;<span class="attr">lastname</span>: <span class="string">'li'</span>&#125;;</div><div class="line">name.lastname = <span class="string">"Lee"</span>;</div><div class="line"><span class="built_in">console</span>.log(name.lastname);<span class="comment">//输出为 Lee</span></div></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> name = &#123;<span class="attr">lastname</span>: <span class="string">'li'</span>&#125;;</div><div class="line">name = &#123;<span class="string">'firstname'</span>: <span class="string">'JJ'</span>&#125;;<span class="comment">//SyntaxError: redeclaration of const name</span></div></pre></td></tr></table></figure>
<p>const的作用域同样是块级作用域。</p>
]]></content>
    
    <summary type="html">
    
      ES6关键字let和const
    
    </summary>
    
      <category term="javascript" scheme="http://lijingjing.top/categories/javascript/"/>
    
    
      <category term="let const" scheme="http://lijingjing.top/tags/let-const/"/>
    
  </entry>
  
  <entry>
    <title>React(二)</title>
    <link href="http://lijingjing.top/blog/2016/12/27/React-%E4%BA%8C/"/>
    <id>http://lijingjing.top/blog/2016/12/27/React-二/</id>
    <published>2016-12-27T05:52:50.000Z</published>
    <updated>2017-01-02T08:27:53.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="组件的生命周期"><a href="#组件的生命周期" class="headerlink" title="组件的生命周期"></a>组件的生命周期</h1><p>一个组件就是一个状态机：对于特定的输入，它总会返回一致的输出。</p>
<p>React为每个组件提供了生命周期钩子函数去响应不同的时刻——创建时、存在期及销毁时。这些时刻出现的顺序——从实例化开始，到活动期，直到最后被销毁。</p>
<h2 id="生命周期方法"><a href="#生命周期方法" class="headerlink" title="生命周期方法"></a>生命周期方法</h2><p>React的组件拥有简洁的生命周期API，它仅仅提供你所需要的方法，而不会去追求全面。</p>
<h3 id="实例化"><a href="#实例化" class="headerlink" title="实例化"></a>实例化</h3><p>一个实例初次被创建时所调用的生命周期方法与其他各个后续实例被创建时所调用的方法略有不同。当你首次使用一个组件类时，你会看到西面这些方法依次被调用：</p>
<ul>
<li>getDefaultProps</li>
</ul>
<p>对于组件类来说，这个方法只会被调用一次。对于那些没有被父辈组件指定props属性的新建实例来说，这个方法返回的对象可用于为实例设置默认的props值。<br><em>任何复杂的值，比如对象和数组，都会在所有的实例中共享，而不是拷贝或者克隆。</em></p>
<ul>
<li>getInitialState</li>
</ul>
<p>对于组件的每个实例来说，这个方法的调用次数有且只有一次。在这里你将有机会初始化每个实例的state。与getDefaultProps方法不同的是，每次实例创建时该方法都会被调用一次。在这个方法里，可以访问到this.props.</p>
<ul>
<li>componentWillMount</li>
</ul>
<p>该方法会在完成首次渲染之前被调用。这也是在render方法调用前可以修改组件state的最后一次机会。</p>
<ul>
<li>render</li>
</ul>
<p>在这里会创建一个虚拟DOM，用来表示组件的输出。对于一个组件来说，render是唯一一个必需的方法，并且有特定的规则。render方法需要满足以下几点：<br>（1）只能通过this.props和this.state访问数据<br>（2）可以返回null/false或者任何React组件<br>（3）只能出现一个顶级组件（不能返回一组元素）<br>（4）必须纯净，意味着不能改变组件的状态或者修改DOM的输出</p>
<p><em>render方法返回的结果不是真正的DOM，而是一个虚拟的表现，React随后会把它和真实的DOM（内存中的DOM表现，而非浏览器中的）作对比，来判断是否有必要做出修改。</em></p>
<ul>
<li>componentDidMount</li>
</ul>
<p>在render方法成功调用并且真实的DOM已经被渲染之后，可以在componentDidMount内部通过this.getDOMNode()方法访问到它。</p>
<p>比如：当你需要测量渲染出DOM元素的高度，或者使用计时器来操作它，亦或运行一个自定义的jQuery插件时，可以将这些操作挂载到这个方法上。<br>eg:假设需要在一个通过React渲染出的表单元素上使用jQuery UI的Autocomplete插件，则可以这样使用它：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//需要自动补全的字符串列表</span></div><div class="line"><span class="keyword">var</span> datasource = [...];</div><div class="line"></div><div class="line"><span class="keyword">var</span> MyComponent = React.createClass(&#123;</div><div class="line">	<span class="attr">render</span> : <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">		<span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">input</span> <span class="attr">...</span> /&gt;</span>;</span></div><div class="line">	&#125;,</div><div class="line">	componentDidMount: function()&#123;</div><div class="line">		$(this.getDOMDNode()).autocomplete(&#123;</div><div class="line">			source : datasource</div><div class="line">	&#125;);</div><div class="line">	&#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>==当React运行在服务端时，componentDidMount方法不会被调用。==</p>
<p><em>对于该组件类的所有后续应用，将会看到下面的方法依次被调用。getDefaultProps方法不在列表中</em></p>
<ul>
<li>getInitialState</li>
<li>componentWillMount</li>
<li>render</li>
<li>componentDidMount</li>
</ul>
<h3 id="存在期"><a href="#存在期" class="headerlink" title="存在期"></a>存在期</h3><p>此时，组件已经渲染好并且用户可以与它进行交互。通常是通过一次鼠标店家，手指点按或者是键盘事件来出发一个事件处理器。随着用户改变了组件或者整个应用的state，便会有新的state流入组件树，并且我们将会获得操控它的机会。</p>
<p>随着应用状态的改变，以及组件逐渐受到影响，你将会看到下面的方法依次被调用：</p>
<ul>
<li>componentWillReceiveProps</li>
</ul>
<p>在任意时刻，组件的props都可以通过父辈组件来更改。出现这种情况时，componentWillReceiveProps方法会被调用，也将获得更改props对象及更新state的机会。</p>
<ul>
<li>shouldComponentUpdate</li>
</ul>
<p>通过调用shouldComponentUpdate方法在组件渲染时进行精确优化可以使react更快。<br><em>在首次渲染期间或者调用了forceUpdate之后，这个方法不会被调用</em></p>
<ul>
<li>componentWillUpdate</li>
</ul>
<p>和componentWillMount方法类似，组件会在接收到新的props或者state进行渲染之前，调用该方法。</p>
<p><em>不可以在该方法中更新state或者props，而应该借助componentWillReceiveProps方法在运行时更新state</em></p>
<ul>
<li>render</li>
<li>componentDidUpdate</li>
</ul>
<p>和componentDidMount方法相似，该方法给了我们更新已经渲染好的DOM的机会。</p>
<h3 id="销毁-amp-清理期"><a href="#销毁-amp-清理期" class="headerlink" title="销毁&amp;清理期"></a>销毁&amp;清理期</h3><p>最后，当该组件被使用完成后，componentWillUnmount方法将会被调用，目的是给这个实例提供清理自身的机会。</p>
<p>每当React使用完一个组件，这个组件就必须从DOM中卸载随后被销毁。此时，仅有的一个钩子函数会做出响应，完成所有的清理和销毁工作，这很必要。</p>
<p>componentWillUnmount,该方法会在组件被移除之前被调用，让你有机会做些清理工作。在componentDidMount方法中添加的所有任务都需要在该方法中撤销，比如创建的定时器或者添加的事件监听器。</p>
<h1 id="数据流"><a href="#数据流" class="headerlink" title="数据流"></a>数据流</h1><p>在React中，数据的流向是单向的——从父节点传递到子节点，因而组件是简单且易于把握的，它们只需要从父节点获取props渲染即可。如果顶层组件的某个prop改变了，React会递归的向下遍历整棵组件树，重新渲染所有使用这个属性的组件。</p>
<p>组件内部还具有自己的状态，这些状态只能在组件内修改。React组件本身很简单，可以把它们看成一个函数，它接受props和state作为参数，返回一个虚拟的DOM表现。</p>
<h2 id="Props"><a href="#Props" class="headerlink" title="Props"></a>Props</h2><p>props就是properties的缩写，可以使用它把任意类型的数据传递给组件。</p>
<p>可以在挂载组件时设置它的props:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> survey = [&#123;<span class="attr">title</span>:<span class="string">'SuperHeroes'</span>&#125;];</div><div class="line"><span class="xml"><span class="tag">&lt;<span class="name">ListSurveys</span> <span class="attr">survey</span>=<span class="string">&#123;surveys&#125;/</span>&gt;</span></span></div></pre></td></tr></table></figure></p>
<p>或者调用组件实例的setProps方法（很少需要这么做）来设置其props:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> survey = [&#123;<span class="attr">title</span>:<span class="string">'SuperHeroes'</span>&#125;];</div><div class="line"><span class="keyword">var</span> listSurveys = React.render(</div><div class="line">	<span class="xml"><span class="tag">&lt;<span class="name">ListSurveys</span>/&gt;</span></span></div><div class="line">	<span class="built_in">document</span>.querySelector(<span class="string">'body'</span>);</div><div class="line">);</div><div class="line">listSurveys.setProps(&#123; <span class="attr">surveys</span>: surveys&#125;);</div></pre></td></tr></table></figure></p>
<p><em>只能在子组件或者在组件树外(上例)调用setProps。千万别调用this.setProps或者直接修改this.props，如果需要，使用state。</em></p>
<p>可以通过this.props访问props,但绝不能通过这种范式修改它。一个组件绝对不可以自己修改自己的props。</p>
<p>在JSX中<br>(1)可以把props设置为字符串：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;a href=<span class="string">'/surveys/add'</span>&gt;Add survey&lt;<span class="regexp">/a&gt;</span></div></pre></td></tr></table></figure></p>
<p>(2)可以使用{}语法设置注入JS传递任意类型的变量<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;a href=&#123;<span class="string">'/surveys/‘+ survey.id&#125;&gt;&#123;survey.title&#125;&lt;/a&gt;</span></div></pre></td></tr></table></figure></p>
<p>(3)可以把props设置成一个对象：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> ListSurveys = React.createClass(&#123;</div><div class="line">	<span class="attr">render</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">		<span class="keyword">var</span> props = &#123;</div><div class="line">			<span class="attr">one</span> : <span class="string">'foo'</span>,</div><div class="line">			<span class="attr">two</span> : <span class="string">'bar'</span></div><div class="line">		&#125;;</div><div class="line">		<span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">SurveyTable</span> &#123;<span class="attr">...props</span>&#125;/&gt;</span>;</span></div><div class="line">	&#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>(4) 可以用来添加事件处理器<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> SaveButton = React.createClass(&#123;</div><div class="line">	<span class="attr">render</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">		<span class="keyword">return</span> (</div><div class="line">		<span class="xml"><span class="tag">&lt;<span class="name">a</span> <span class="attr">className</span>=<span class="string">'button save'</span> <span class="attr">onClick</span>=<span class="string">&#123;this.handleClick&#125;</span>&gt;</span>Save<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span></div><div class="line">		);</div><div class="line">	&#125;,</div><div class="line">	<span class="attr">handleClick</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">	<span class="comment">// ...</span></div><div class="line">	&#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<h2 id="PropTypes"><a href="#PropTypes" class="headerlink" title="PropTypes"></a>PropTypes</h2><p>通过在组件中定义一个配置对象，提供一种验证props的方式。组件初始化时，如果传递的属性和propTypes不匹配，则会打印一个consoel.warn日志。<br>如果是可选的配置，则可以去掉.isRequired。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> SurveyTableRow = React.createClass(&#123;</div><div class="line">	<span class="attr">propTypes</span>:&#123;</div><div class="line">		<span class="attr">survey</span>: React.propTypes.shape(&#123;</div><div class="line">			<span class="attr">id</span>: React.PropTypes.number.isRequired</div><div class="line">		&#125;).isRequired,</div><div class="line">		<span class="attr">onClick</span>: React.propTypes.ufnc</div><div class="line">	&#125;,</div><div class="line">	<span class="comment">// ...</span></div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<h2 id="getDefaultProps"><a href="#getDefaultProps" class="headerlink" title="getDefaultProps"></a>getDefaultProps</h2><p>可以为组件添加getDefaultProps函数来设置属性的默认值。不过，这应该只针对那些非必须属性。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> SurveyTable = React.createClass(&#123;</div><div class="line">	<span class="attr">getDefaultProps</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">		<span class="keyword">return</span> &#123;</div><div class="line">			<span class="attr">surveys</span>:[]</div><div class="line">		&#125;;</div><div class="line">	&#125;,</div><div class="line">	<span class="comment">// ...</span></div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p><em>getDeafultProps并不是在组件实例化时被调用的。而是在React.createClass调用时就被调用了，返回值会被缓存起来。也就是说，不能在getDefaultProps中使用任何特定的<em>实例数据</em>。</em></p>
<h2 id="State"><a href="#State" class="headerlink" title="State"></a>State</h2><p>每一个React组件都可以拥有自己的state，state与props的区别在于前者只存在于组件的内部。</p>
<p>state可以用来确定一个元素的视图状态。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> CountryDropdown = React.createClass(&#123;</div><div class="line">	<span class="attr">getInitialState</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">		<span class="keyword">return</span> &#123;</div><div class="line">			<span class="attr">showOptions</span>: <span class="literal">false</span></div><div class="line">		&#125;; 	</div><div class="line">	&#125;,</div><div class="line">	</div><div class="line">	<span class="attr">render</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">		<span class="keyword">var</span> options;</div><div class="line">		</div><div class="line">		<span class="keyword">if</span>(<span class="keyword">this</span>.state.showOptions)&#123;</div><div class="line">			options = (</div><div class="line">				<span class="xml"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">className</span>=<span class="string">'options'</span>&gt;</span></span></div><div class="line">					<span class="tag">&lt;<span class="name">li</span>&gt;</span>China<span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line">				<span class="tag">&lt;/<span class="name">ul</span>&gt;</span></div><div class="line">			);</div><div class="line">		&#125;</div><div class="line">		</div><div class="line">		<span class="keyword">return</span> (</div><div class="line">			<span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span> = <span class="string">"dropDown"</span> <span class="attr">onClick</span>=<span class="string">&#123;this.handleClick&#125;</span>&gt;</span></span></div><div class="line">				<span class="tag">&lt;<span class="name">label</span>&gt;</span> Choose a country <span class="tag">&lt;/<span class="name">label</span>&gt;</span>.&#123;options&#125;</div><div class="line">			<span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">		);</div><div class="line">	&#125;,</div><div class="line">	<span class="attr">handleClick</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">		<span class="keyword">this</span>.setState(&#123;</div><div class="line">			<span class="attr">showOptions</span>: <span class="literal">true</span></div><div class="line">		&#125;);</div><div class="line">	&#125;</div><div class="line">	<span class="comment">// ...</span></div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>上例中，state被用来记录是否在下拉框中显示可选项。</p>
<p>state可以通过setState来修改，也可以使用上面出现的getInitialState方法提供一组默认值。只要setState被调用，render就会被调用。<em>如果render函数的返回值有变化，虚拟DOM就会更新，真实的DOM也会被更新，最终用户就会在浏览器中看到变化。</em>  </p>
<p>不能直接修改this.state，永远要使用this.setState方法修改。</p>
<h2 id="state和props"><a href="#state和props" class="headerlink" title="state和props"></a>state和props</h2><p>不要在state中保存计算出的值，而应该只保存最简单的数据，即那些组件正常工作时的必要数据。比如：下拉选框是否显示的布尔值。</p>
<p>不要尝试把props复制到state中，要尽可能把props当作数据源。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li>使用props在整个组件树中传递数据和配置</li>
<li>避免在组件内部修改this.props或调用this.setProps，请把props当作制度的</li>
<li>使用props来做时间处理器，与子组件通信</li>
<li>使用state存储简单的视图状态，比如下拉框是否可见这样的状态</li>
<li>使用this.setState来设置状态，而不要使用this.state直接修改状态</li>
</ul>
]]></content>
    
    <summary type="html">
    
      《React引领未来的用户界面开发框架》
    
    </summary>
    
      <category term="读书笔记" scheme="http://lijingjing.top/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="React" scheme="http://lijingjing.top/tags/React/"/>
    
  </entry>
  
  <entry>
    <title>React (一)</title>
    <link href="http://lijingjing.top/blog/2016/12/26/React-%E4%B8%80/"/>
    <id>http://lijingjing.top/blog/2016/12/26/React-一/</id>
    <published>2016-12-26T12:04:05.000Z</published>
    <updated>2017-01-02T08:27:50.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>React发源自Facebook的PHP框架XHP的一个分支。XHP作为一个PHP框架，旨在有请求进来时渲染整个页面。React的产生就是为了把这种重新渲染整个页面的PHP式工作流带到客户端应用中来。<br>React本质上是一个”状态机“，可以帮助开发者管理复杂的随着时间而变化的状态，以一个精简的模型实现了这一点。React只关心两件事：</p>
<ol>
<li>更新DOM</li>
<li>响应事件</li>
</ol>
<p>React不处理Ajax、路由和数据存储，也不规定数据组织的方式。它不是一个Model-View-Controller框架。如果非要问它是什么，它就是MVC中的”V“.</p>
<p>在每次状态改变时，使用JS重新渲染整个页面会异常慢，这应该归咎于读取和更新DOM的性能问题。React运用一个<em>虚拟的DOM</em>实现了一个非常强大的渲染系统，在React中<em>对DOM只更新不读取</em>。</p>
<p>React以渲染函数为基础。这些函数读入当前的状态，将其转换为目标页面上的一个虚拟表现，只要React被告知状态有变化，它就会重新运行这些函数，计算出页面的一个新的虚拟表现，接着自动地把结果转换成必要的DOM更新来反映新的表现。</p>
<p>虽然看上去比通常的按需更新每一个元素的JS方案要慢，但是React使用了非常高效的算法，计算出虚拟页面当前版本和新版本间的差异，基于这些差异对DOM进行必要的最少更新。</p>
<p><em>React赢在最小化重绘，并避免了不必要的DOM操作。</em></p>
<p>React的<em>虚拟表示差异算法</em>，不但能够把这些问题的影响降到最低（通过在单个周期内进行最小的更新），还能简化应用的维护成本。当用户输入或者有其他更新导致状态改变时，我们只要简单地通知React状态改变了，它就能自动化地处理剩下的事情。</p>
<p>React在整个应用中只使用单个事件处理器，并且会把所有的事件委托到这个处理器上。这一点也提升了React的性能，因为如果有很多事件处理器也会导致性能问题。</p>
<h1 id="JSX"><a href="#JSX" class="headerlink" title="JSX"></a>JSX</h1><p>JSX（JavaScript XML），一种在React组件内部构建标签的类XML语法。使用JSX可以提高组件的可读性。JSX最后只是被简单地转化成对应的JS函数，但是JSX更令其他开发人员熟悉、语义化和直观。</p>
<p>JSX特征：</p>
<ol>
<li>JSX是一种句法变换——每一个JSX节点都对应着一个JS函数。</li>
<li>JSX既不提供也不需要运行时库。</li>
<li>JSX并没有改变或添加JS的语义——它只是简单的函数调用而已。</li>
</ol>
<p><em>JSX和HTML的不同</em><br>(1) <em>属性</em>，在HTML中用内联的方式给每个节点设置属性，eg:<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"some-id"</span> <span class="attr">class</span>=<span class="string">"some-class-name"</span>&gt;</span>...<span class="tag">&lt;/<span class="name">div</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>JSX以同样的方式实现了属性的设置，同时还提供了将属性设置为动态JS变量的便利。要设置动态的属性，你需要把原本用引号括起来的文本替换成花括号包裹的JS变量。<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">var surveyQuestionId = this.props.id;</div><div class="line">var classes = 'some-class-name';</div><div class="line">...</div><div class="line">&lt;div id = &#123;surveyQuestionId&#125;  className=&#123;classes&#125;&gt;...&lt;/div&gt;</div><div class="line"></div><div class="line">&lt;div id=&#123;this.getSurveyId()&#125;&gt;...&lt;/div&gt;</div></pre></td></tr></table></figure></p>
<p>React每渲染一个组件时，我们制定的变量和函数会被求值，而最终生成的DOM结构会反映出这个新的状态。</p>
<p>(2) <em>条件判断</em>，在React中，可以利用JS实现循环和条件判断。<br>在组件中添加条件判断很困难，因为if/else逻辑很难用HTML标签来表达。直接往JSX中加入if语句会渲染出无效的JS。<br>解决方法：<br><em>使用三目运算符；</em><br>虽然对于文本来说三目运算符可以正常运行，但是如果想在其他情况下很好地应用React Component，三目运算符就可能显得笨重又麻烦。对于这些情况最好是使用以下方法。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">...</div><div class="line">render:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">	<span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&#123;</span></span></span></div><div class="line">		<span class="attr">this.state.isComplete</span> ? '<span class="attr">is-complete</span>' <span class="attr">:</span> ''</div><div class="line">	&#125;&gt;...<span class="tag">&lt;/<span class="name">div</span>&gt;</span>;</div><div class="line">&#125;</div><div class="line">...</div></pre></td></tr></table></figure>
<p><em>设置一个变量并在属性中引用它；</em></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">...</div><div class="line">getIsComplete:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">	<span class="keyword">return</span> <span class="keyword">this</span>.state.isComplete ? <span class="string">'is-complete'</span> : <span class="string">''</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line">render:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">	<span class="keyword">var</span> isComplete = <span class="keyword">this</span>.getIsComplete();</div><div class="line">	<span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&#123;isComplete&#125;</span>&gt;</span>...<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></div><div class="line">&#125;</div><div class="line">...</div></pre></td></tr></table></figure>
<p><em>将逻辑转化到函数中；</em></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">...</div><div class="line">getIsComplete:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">	<span class="keyword">return</span> <span class="keyword">this</span>.state.isComplete ? <span class="string">'is-complete'</span> : <span class="string">''</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line">render:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">	<span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&#123;</span> <span class="attr">this.getIsComplete</span>()&#125;&gt;</span>...<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></div><div class="line">&#125;</div><div class="line">...</div></pre></td></tr></table></figure>
<p><em>使用&amp;&amp;运算符；</em><br>由于对于null或者false值React不会输出任何内容，因此可以使用一个后面跟随了期望字符串的布尔值来实现条件判断。如果这个布尔值为true，那么后续的字符串就会被使用。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">...</div><div class="line">render:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">	<span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&#123;this.state.isComplete</span> &amp;&amp; '<span class="attr">isComplete</span>'&#125;&gt;</span>...<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></div><div class="line">&#125;</div><div class="line">...</div></pre></td></tr></table></figure>
<p>(3) 非DOM属性<br>下面的属性只在JSX中存在</p>
<ul>
<li>key<br>key是一个可选的唯一标识符，在程序运行的过程中，一个组件可能会在组件树中调整位置，比如当用户在进行搜索操作时，或者当一个列表中的物品被增加、删除时。当这些情况发生时，组件可能并不需要被销毁并重新创建。<br>通过给组件设置一个独一无二的键，并确保它在一个渲染周期中保持一致，使得React能够更智能地决定应该重新重用一个组件，还是销毁并重新创建一个组件，进而提升渲染性能。当两个已经存在于DOM中的组件交换位置时，React能够匹配对应的键并进行相应的移动，且不需要完全重新渲染DOM。</li>
<li>ref<br>ref允许父组件在render方法之外保持对子组件的一个引用。在JSX中，可以通过在属性中设置期望的引用名来定义一个引用。<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">render:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">	<span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">ref</span>=<span class="string">"myInput"</span> <span class="attr">...</span>/&gt;</span>...<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></div><div class="line">&#125;</div><div class="line">...</div></pre></td></tr></table></figure>
</li>
</ul>
<p>然后就可以再组件中的任何地方使用<code>this.refs.myInput</code>获取这个引用，通过引用获取到的对象被称为支持实例。它并不是真的DOM，而是React在需要时用来创建DOM的一个描述对象。可以使用<code>this.refs.myInput.getDOMNode()</code>访问真实的DOM节点。</p>
<ul>
<li>dangerouslySetInnerHTML<br>有时候需要将HTML内容设置为字符串，尤其是使用了通过字符串操作DOM的第三方库时。为了提升React的互操作性，这个属性允许你使用HTML字符串。然而如果你能避免使用它的话，就还是不要使用。要让这个属性发挥作用，你需要把字符串设置到一个主键为_html的对象里，像这样：<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">...</div><div class="line">render:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line"><span class="keyword">var</span> htmlString = &#123;</div><div class="line">	<span class="attr">_html</span>: <span class="string">"&lt;span&gt;html&lt;/span&gt;"</span></div><div class="line">&#125;;</div><div class="line">	<span class="keyword">return</span> &lt;div dangerouslySetInnerHTML=&#123;htmlString&#125;&gt;&lt;div&gt;</div><div class="line">&#125;</div><div class="line">...</div></pre></td></tr></table></figure>
</li>
</ul>
<p>(4) 事件<br>在JSX中，捕获一个事件就像给组件的方法设置一个属性一样简单。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">...</div><div class="line">handleClick: <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;...&#125;,</div><div class="line"><span class="attr">render</span>:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">	<span class="keyword">return</span> &lt;div onClick=&#123;this.handleClick&#125;&gt;...&lt;div&gt;</div><div class="line">&#125;</div><div class="line">...</div></pre></td></tr></table></figure></p>
<p>React自动绑定了组件所有方法的作用域，因此不需要手动绑定。</p>
<p>(5) 注释<br>JSX本质上就是JS，可以再标签内添加原生的JS注释。注释用以下两种形式添加：</p>
<ul>
<li><p>当做一个元素的子节点</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></div><div class="line">	&#123;/* a comment about this input with multiple lines*/&#125;</div><div class="line">	<span class="tag">&lt;<span class="name">input</span> <span class="attr">name</span>=<span class="string">"email"</span> <span class="attr">placeholder</span>=<span class="string">"Email Address"</span> /&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div></pre></td></tr></table></figure>
</li>
<li><p>内联在元素的属性中</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></div><div class="line">	<span class="tag">&lt;<span class="name">input</span></span></div><div class="line">	/* <span class="attr">a</span> <span class="attr">comment</span> <span class="attr">about</span> <span class="attr">this</span> <span class="attr">input</span> <span class="attr">with</span> <span class="attr">multiple</span> <span class="attr">lines</span>*/</div><div class="line">	<span class="attr">name</span>=<span class="string">"email"</span> <span class="attr">placeholder</span>=<span class="string">"Email Address"</span> /&gt;</div><div class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div></pre></td></tr></table></figure>
</li>
</ul>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></div><div class="line">	<span class="tag">&lt;<span class="name">input</span></span></div><div class="line">	<span class="attr">name</span>=<span class="string">"email"</span> // <span class="attr">a</span> <span class="attr">single-line</span> <span class="attr">comment</span></div><div class="line">	<span class="attr">placeholder</span>=<span class="string">"Email Address"</span> /&gt;</div><div class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div></pre></td></tr></table></figure>
<p>(6) 特殊属性<br>由于JSX会转换为原生的JS函数，因此有一些关键词我们是不能使用的——如for和class。<br>要给表单里的标签添加for属性需要使用htmlFor.<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">label</span> <span class="attr">htmlFor</span>=<span class="string">'for-text'</span> <span class="attr">...</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&#123;classes&#125;</span> <span class="attr">...</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>(7) 样式<br>React把所有的内联样式都规范化为了驼峰形式，与JS中DOM的style属性一致。添加一个自定义的样式属性，只需简单把驼峰形式的属性名以及期望的CSS值拼装为对象即可。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> style = &#123;</div><div class="line">	<span class="attr">borderColor</span>: <span class="string">"#999"</span>,</div><div class="line">	<span class="attr">borderThickness</span>: <span class="string">"1px"</span></div><div class="line">&#125;;</div><div class="line"></div><div class="line">React.renderComponent(<span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&#123;style&#125;</span>&gt;</span>...<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>,node);</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      《React引领未来的用户界面开发框架》
    
    </summary>
    
      <category term="读书笔记" scheme="http://lijingjing.top/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="React" scheme="http://lijingjing.top/tags/React/"/>
    
  </entry>
  
  <entry>
    <title>利用Angular Directive实现table tree</title>
    <link href="http://lijingjing.top/blog/2016/11/29/%E5%88%A9%E7%94%A8Angular-Directive%E5%AE%9E%E7%8E%B0table-tree/"/>
    <id>http://lijingjing.top/blog/2016/11/29/利用Angular-Directive实现table-tree/</id>
    <published>2016-11-29T08:40:46.000Z</published>
    <updated>2017-01-02T08:27:47.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p> 依然是Cadillac的项目中碰到的，媒设老师只要给设计稿，感觉所有的代码都要自己敲，没有省事的方法了。设计图如下： <img src="/images/Cadillac_statistic.png" alt="Cadillac_statistic"><br> 想了一想，项目前端主要使用的是AngularJS，所以自己应该写指令来实现这种表现形式。</p>
<h1 id="实现思路"><a href="#实现思路" class="headerlink" title="实现思路"></a>实现思路</h1><p> 实现思路是，考虑全部展开的形式，通过点击事件来判断，哪些<tr>可以显示，哪些</tr><tr>是要隐藏的。并且利用Angular里的ng-repeat-start和ng-repeat-end来控制repeat的dom节点。由此，可以得到item下面的areas,areas中的每个area又有sales。第一栏table的分配宽度为30%，通过</tr><tr>里第一个<td>的文字位置，来模拟树形结构的展开形式，大区的第一栏字体靠左，MAC字体居中，经销商字体居右。</td></tr></p>
<h2 id="html文件"><a href="#html文件" class="headerlink" title="html文件"></a>html文件</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">sale-table</span> <span class="attr">class</span>=<span class="string">"sale-table"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">items</span> <span class="attr">ng-repeat-start</span>=<span class="string">"item in items"</span> <span class="attr">item</span>=<span class="string">"item"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">items</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">areas</span> <span class="attr">ng-repeat-start</span>=<span class="string">"area in areas"</span> <span class="attr">item-id</span>=<span class="string">"item.area"</span> <span class="attr">area</span>=<span class="string">"area"</span> <span class="attr">ng-show</span>=<span class="string">"item.area == showArea"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">areas</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">sales</span> <span class="attr">ng-repeat</span>=<span class="string">"sale in sales"</span> <span class="attr">area-id</span>=<span class="string">"area.area"</span> <span class="attr">sale</span>=<span class="string">"sale"</span></span></div><div class="line">           <span class="attr">ng-show</span>=<span class="string">"(area.area == showSale)&amp;&amp;(item.area == showArea)"</span>&gt;</div><div class="line">    <span class="tag">&lt;/<span class="name">sales</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">ng-repeat-end</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">ng-repeat-end</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">sale-table</span>&gt;</span></div></pre></td></tr></table></figure>
<h2 id="JS文件"><a href="#JS文件" class="headerlink" title="JS文件"></a>JS文件</h2><h3 id="sale-table"><a href="#sale-table" class="headerlink" title="sale-table"></a>sale-table</h3><p> sale-table是table tree的最外层，规定了表格的表头,展开和收起的控制逻辑也在这个指令里。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/** @ngInject */</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">saleTableFunc</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> &#123;</div><div class="line">        <span class="attr">restrict</span>: <span class="string">'EA'</span>,</div><div class="line">        <span class="attr">replace</span>: <span class="literal">true</span>,</div><div class="line">        <span class="attr">transclude</span>: <span class="literal">true</span>,</div><div class="line">        <span class="attr">template</span>: <span class="string">'&lt;table class="data table table-bordered statistic-table" style="text-align: center;"&gt;'</span> +</div><div class="line">        <span class="string">'&lt;tr class="table-header"&gt;'</span> +</div><div class="line">        <span class="string">'&lt;th class="data-th" width="30%"&gt;大区&lt;/th&gt;'</span> +</div><div class="line">        <span class="string">'&lt;th class="data-th" width="10%"&gt;全部车系&lt;/th&gt;'</span> +</div><div class="line">        <span class="string">'&lt;th class="data-th" width="10%"&gt;SRX&lt;/th&gt;'</span> +</div><div class="line">        <span class="string">'&lt;th class="data-th" width="10%"&gt;XTS&lt;/th&gt;'</span> +</div><div class="line">        <span class="string">'&lt;th class="data-th" width="10%"&gt;ATS-L&lt;/th&gt;'</span> +</div><div class="line">        <span class="string">'&lt;th class="data-th" width="10%"&gt;CT6&lt;/th&gt;'</span> +</div><div class="line">        <span class="string">'&lt;th class="data-th" width="10%"&gt;XT5&lt;/th&gt;'</span> +</div><div class="line">        <span class="string">'&lt;th class="data-th" width="10%"&gt;CTS&lt;/th&gt; &lt;/tr&gt;'</span> +</div><div class="line">        <span class="string">'&lt;tbody ng-transclude&gt;&lt;/tbody&gt;&lt;/table&gt;'</span>,</div><div class="line">        <span class="attr">controller</span>: <span class="function"><span class="keyword">function</span> (<span class="params">$scope</span>) </span>&#123;</div><div class="line">          <span class="comment">//第二层，MAC展开收起控制逻辑</span></div><div class="line">            $scope.$on(<span class="string">'getArea'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">d, data</span>) </span>&#123;</div><div class="line">              <span class="comment">//拿到当前区域下的MAC信息</span></div><div class="line">                $scope.areas = data.areas;</div><div class="line">              <span class="comment">//如果当前点击id为之前存储的id，则由展开变为收起形式</span></div><div class="line">                <span class="keyword">if</span> ($scope.showArea == data.itemId) &#123;</div><div class="line">                    $scope.showArea = <span class="number">-1</span>;</div><div class="line">                    $scope.showSale = <span class="number">-1</span>;</div><div class="line">                &#125;</div><div class="line">                <span class="comment">//否则，将当前点击的id存储，但是之前所有的经销商项都收起</span></div><div class="line">                <span class="keyword">else</span></div><div class="line">                &#123;</div><div class="line">                    $scope.showArea = data.itemId;</div><div class="line">                    $scope.showSale = <span class="number">-1</span>;</div><div class="line">                &#125;</div><div class="line">            &#125;);</div><div class="line"></div><div class="line">          <span class="comment">//第三层，经销商展开和收起控制逻辑</span></div><div class="line">            $scope.$on(<span class="string">'getSale'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">d, data</span>) </span>&#123;</div><div class="line">                $scope.sales = data.sales;</div><div class="line">                <span class="built_in">console</span>.log(data.areaId);</div><div class="line">                <span class="keyword">if</span> ($scope.showSale == data.areaId)</div><div class="line">                    $scope.showSale = <span class="number">-1</span>;</div><div class="line">                <span class="keyword">else</span></div><div class="line">                    $scope.showSale = data.areaId;</div><div class="line">            &#125;);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="items"><a href="#items" class="headerlink" title="items"></a>items</h3><p> saleItemFunc是items的指令函数。其中showMiddleArea函数来获取当前大区的id，并通过这个id难道所有的MAC区信息，通过变量showArea和当前点击的item的id做比较，来判断MAC信息节点的展开和收起，在areas指令里，通过ng-show条件判断来控制当前的MAC信息是否显示。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">areas</span>  <span class="attr">ng-show</span>=<span class="string">"item.area == showArea"</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">areas</span>&gt;</span></div></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/** @ngInject */</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">saleItemFunc</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> &#123;</div><div class="line">        <span class="attr">restrict</span>: <span class="string">'EA'</span>,</div><div class="line">        <span class="attr">replace</span>: <span class="literal">true</span>,</div><div class="line">        <span class="attr">transclude</span>: <span class="literal">true</span>,</div><div class="line">        <span class="attr">require</span>: <span class="string">'^?saleTable'</span>,</div><div class="line">        <span class="attr">scope</span>: &#123;</div><div class="line">            <span class="attr">item</span>: <span class="string">'=item'</span></div><div class="line">        &#125;,</div><div class="line">        <span class="attr">template</span>: <span class="string">'&lt;tr&gt;'</span> +</div><div class="line">        <span class="string">'&lt;td class="data-td left-text"&gt;'</span> +</div><div class="line">        <span class="string">'&lt;div class="all-area" ng-click="showMiddleArea()"&gt;'</span> +</div><div class="line">        <span class="string">'&#123;&#123;item.area&#125;&#125;'</span> +</div><div class="line">        <span class="string">'&lt;span class="ion-chevron-down"&gt;&lt;/span&gt;'</span> +</div><div class="line">        <span class="string">'&lt;/div&gt; &lt;/td&gt;'</span> +</div><div class="line">        <span class="string">'&lt;td class="data-td red-color"&gt;'</span> +</div><div class="line">        <span class="string">'&#123;&#123;item.lines&#125;&#125;&lt;/td&gt;'</span> +</div><div class="line">        <span class="string">'&lt;td class="data-td"&gt;'</span> +</div><div class="line">        <span class="string">'&#123;&#123;item.srx&#125;&#125;&lt;/td&gt;'</span> +</div><div class="line">        <span class="string">'&lt;td class="data-td"&gt;'</span> +</div><div class="line">        <span class="string">'&#123;&#123;item.xts&#125;&#125;&lt;/td&gt;'</span> +</div><div class="line">        <span class="string">'&lt;td class="data-td"&gt;'</span> +</div><div class="line">        <span class="string">'&#123;&#123;item.ats&#125;&#125;&lt;/td&gt;'</span> +</div><div class="line">        <span class="string">'&lt;td class="data-td"&gt;'</span> +</div><div class="line">        <span class="string">'&#123;&#123;item.ct6&#125;&#125;&lt;/td&gt;'</span> +</div><div class="line">        <span class="string">'&lt;td class="data-td"&gt;'</span> +</div><div class="line">        <span class="string">'&#123;&#123;item.xt5&#125;&#125;&lt;/td&gt;'</span> +</div><div class="line">        <span class="string">'&lt;td class="data-td"&gt;'</span> +</div><div class="line">        <span class="string">'&#123;&#123;item.cts&#125;&#125; &lt;/td&gt; &lt;/tr&gt;'</span>,</div><div class="line">        <span class="attr">link</span>: <span class="function"><span class="keyword">function</span> (<span class="params">scope, element, attrs, saleTableController</span>) </span>&#123;</div><div class="line">          <span class="comment">//实际情况应该和后台交互，拿到当前大区下的所有MAC信息</span></div><div class="line">            scope.showMiddleArea = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">                scope.areas = [&#123;</div><div class="line">                    <span class="attr">area</span>: <span class="string">'MAC1'</span>,</div><div class="line">                    <span class="attr">lines</span>: <span class="number">2744</span>,</div><div class="line">                    <span class="attr">srx</span>: <span class="number">800</span>,</div><div class="line">                    <span class="attr">xts</span>: <span class="number">345</span>,</div><div class="line">                    <span class="attr">ats</span>: <span class="number">975</span>,</div><div class="line">                    <span class="attr">ct6</span>: <span class="number">800</span>,</div><div class="line">                    <span class="attr">xt5</span>: <span class="number">345</span>,</div><div class="line">                    <span class="attr">cts</span>: <span class="number">975</span></div><div class="line">                &#125;, &#123;</div><div class="line">                    <span class="attr">area</span>: <span class="string">'MAC2'</span>,</div><div class="line">                    <span class="attr">lines</span>: <span class="number">5856</span>,</div><div class="line">                    <span class="attr">srx</span>: <span class="number">265</span>,</div><div class="line">                    <span class="attr">xts</span>: <span class="number">235</span>,</div><div class="line">                    <span class="attr">ats</span>: <span class="number">324</span>,</div><div class="line">                    <span class="attr">ct6</span>: <span class="number">265</span>,</div><div class="line">                    <span class="attr">xt5</span>: <span class="number">235</span>,</div><div class="line">                    <span class="attr">cts</span>: <span class="number">324</span></div><div class="line">                &#125;, &#123;</div><div class="line">                    <span class="attr">area</span>: <span class="string">'MAC3'</span>,</div><div class="line">                    <span class="attr">lines</span>: <span class="number">2344</span>,</div><div class="line">                    <span class="attr">srx</span>: <span class="number">334</span>,</div><div class="line">                    <span class="attr">xts</span>: <span class="number">235</span>,</div><div class="line">                    <span class="attr">ats</span>: <span class="number">53</span>,</div><div class="line">                    <span class="attr">ct6</span>: <span class="number">234</span>,</div><div class="line">                    <span class="attr">xt5</span>: <span class="number">32</span>,</div><div class="line">                    <span class="attr">cts</span>: <span class="number">123</span></div><div class="line">                &#125;, &#123;</div><div class="line">                    <span class="attr">area</span>: <span class="string">'MAC4'</span>,</div><div class="line">                    <span class="attr">lines</span>: <span class="number">7356</span>,</div><div class="line">                    <span class="attr">srx</span>: <span class="number">324</span>,</div><div class="line">                    <span class="attr">xts</span>: <span class="number">221</span>,</div><div class="line">                    <span class="attr">ats</span>: <span class="number">553</span>,</div><div class="line">                    <span class="attr">ct6</span>: <span class="number">321</span>,</div><div class="line">                    <span class="attr">xt5</span>: <span class="number">451</span>,</div><div class="line">                    <span class="attr">cts</span>: <span class="number">763</span></div><div class="line">                &#125;, &#123;</div><div class="line">                    <span class="attr">area</span>: <span class="string">'MAC5'</span>,</div><div class="line">                    <span class="attr">lines</span>: <span class="number">5356</span>,</div><div class="line">                    <span class="attr">srx</span>: <span class="number">224</span>,</div><div class="line">                    <span class="attr">xts</span>: <span class="number">323</span>,</div><div class="line">                    <span class="attr">ats</span>: <span class="number">518</span>,</div><div class="line">                    <span class="attr">ct6</span>: <span class="number">341</span>,</div><div class="line">                    <span class="attr">xt5</span>: <span class="number">171</span>,</div><div class="line">                    <span class="attr">cts</span>: <span class="number">623</span></div><div class="line">                &#125;];</div><div class="line">                scope.data = &#123;<span class="attr">itemId</span>: scope.item.area, <span class="attr">areas</span>: scope.areas&#125;;</div><div class="line">                scope.$emit(<span class="string">'getArea'</span>, scope.data);</div><div class="line"></div><div class="line">            &#125;;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="areas"><a href="#areas" class="headerlink" title="areas"></a>areas</h3><p> areas为MAC信息的指令。其主要思想和上层大区指令的思想一样。并且通过当前MAC的id和点击存储的id进行比较，以及当前展开的item的id是否为点击存储的item的id,两个条件同时来控制最后一层经销商信息是否展开。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">sales</span>  <span class="attr">ng-show</span>=<span class="string">"(area.area == showSale)&amp;&amp;(item.area == showArea)"</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">sales</span>&gt;</span></div></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/** @ngInject */</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">areasFunc</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> &#123;</div><div class="line">        <span class="attr">restrict</span>: <span class="string">'EA'</span>,</div><div class="line">        <span class="attr">replace</span>: <span class="literal">true</span>,</div><div class="line">        <span class="attr">transclude</span>: <span class="literal">true</span>,</div><div class="line">        <span class="attr">require</span>: <span class="string">'^?saleTable'</span>,</div><div class="line">        <span class="attr">scope</span>: &#123;</div><div class="line">            <span class="attr">itemId</span>: <span class="string">'=itemId'</span>,</div><div class="line">            <span class="attr">area</span>: <span class="string">'=area'</span></div><div class="line">        &#125;,</div><div class="line">        <span class="attr">template</span>: <span class="string">'&lt;tr&gt;&lt;td class="data-td middle-text"&gt;'</span> +</div><div class="line">        <span class="string">'&lt;div class="all-area" ng-click="showLastArea()"&gt;'</span> +</div><div class="line">        <span class="string">'&#123;&#123;area.area&#125;&#125;'</span> +</div><div class="line">        <span class="string">'&lt;span class="ion-chevron-down"&gt;&lt;/span&gt;'</span> +</div><div class="line">        <span class="string">'&lt;/div&gt; &lt;/td&gt;'</span> +</div><div class="line">        <span class="string">'&lt;td class="data-td red-color"&gt;'</span> +</div><div class="line">        <span class="string">'&#123;&#123;area.lines&#125;&#125;&lt;/td&gt;'</span> +</div><div class="line">        <span class="string">'&lt;td class="data-td"&gt;'</span> +</div><div class="line">        <span class="string">'&#123;&#123;area.srx&#125;&#125;&lt;/td&gt;'</span> +</div><div class="line">        <span class="string">'&lt;td class="data-td"&gt;'</span> +</div><div class="line">        <span class="string">'&#123;&#123;area.xts&#125;&#125;&lt;/td&gt;'</span> +</div><div class="line">        <span class="string">'&lt;td class="data-td"&gt;'</span> +</div><div class="line">        <span class="string">'&#123;&#123;area.ats&#125;&#125;&lt;/td&gt;'</span> +</div><div class="line">        <span class="string">'&lt;td class="data-td"&gt;'</span> +</div><div class="line">        <span class="string">'&#123;&#123;area.ct6&#125;&#125;&lt;/td&gt;'</span> +</div><div class="line">        <span class="string">'&lt;td class="data-td"&gt;'</span> +</div><div class="line">        <span class="string">'&#123;&#123;area.xt5&#125;&#125;&lt;/td&gt;'</span> +</div><div class="line">        <span class="string">'&lt;td class="data-td"&gt;'</span> +</div><div class="line">        <span class="string">'&#123;&#123;area.cts&#125;&#125; &lt;/td&gt;&lt;/tr&gt;'</span>,</div><div class="line">        <span class="attr">link</span>: <span class="function"><span class="keyword">function</span> (<span class="params">scope, element, attrs, saleTableController</span>) </span>&#123;</div><div class="line">          <span class="comment">//实际项目中应与后台交互拿到相关的经销商信息</span></div><div class="line">            scope.showLastArea = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">                scope.sales = [&#123;</div><div class="line">                    <span class="attr">area</span>: <span class="string">'经销商一'</span>,</div><div class="line">                    <span class="attr">lines</span>: <span class="number">2744</span>,</div><div class="line">                    <span class="attr">srx</span>: <span class="number">800</span>,</div><div class="line">                    <span class="attr">xts</span>: <span class="number">345</span>,</div><div class="line">                    <span class="attr">ats</span>: <span class="number">975</span>,</div><div class="line">                    <span class="attr">ct6</span>: <span class="number">800</span>,</div><div class="line">                    <span class="attr">xt5</span>: <span class="number">345</span>,</div><div class="line">                    <span class="attr">cts</span>: <span class="number">975</span></div><div class="line">                &#125;, &#123;</div><div class="line">                    <span class="attr">area</span>: <span class="string">'经销商二'</span>,</div><div class="line">                    <span class="attr">lines</span>: <span class="number">5856</span>,</div><div class="line">                    <span class="attr">srx</span>: <span class="number">265</span>,</div><div class="line">                    <span class="attr">xts</span>: <span class="number">235</span>,</div><div class="line">                    <span class="attr">ats</span>: <span class="number">324</span>,</div><div class="line">                    <span class="attr">ct6</span>: <span class="number">265</span>,</div><div class="line">                    <span class="attr">xt5</span>: <span class="number">235</span>,</div><div class="line">                    <span class="attr">cts</span>: <span class="number">324</span></div><div class="line">                &#125;, &#123;</div><div class="line">                    <span class="attr">area</span>: <span class="string">'经销商三'</span>,</div><div class="line">                    <span class="attr">lines</span>: <span class="number">2344</span>,</div><div class="line">                    <span class="attr">srx</span>: <span class="number">334</span>,</div><div class="line">                    <span class="attr">xts</span>: <span class="number">235</span>,</div><div class="line">                    <span class="attr">ats</span>: <span class="number">53</span>,</div><div class="line">                    <span class="attr">ct6</span>: <span class="number">234</span>,</div><div class="line">                    <span class="attr">xt5</span>: <span class="number">32</span>,</div><div class="line">                    <span class="attr">cts</span>: <span class="number">123</span></div><div class="line">                &#125;, &#123;</div><div class="line">                    <span class="attr">area</span>: <span class="string">'经销商四'</span>,</div><div class="line">                    <span class="attr">lines</span>: <span class="number">7356</span>,</div><div class="line">                    <span class="attr">srx</span>: <span class="number">324</span>,</div><div class="line">                    <span class="attr">xts</span>: <span class="number">221</span>,</div><div class="line">                    <span class="attr">ats</span>: <span class="number">553</span>,</div><div class="line">                    <span class="attr">ct6</span>: <span class="number">321</span>,</div><div class="line">                    <span class="attr">xt5</span>: <span class="number">451</span>,</div><div class="line">                    <span class="attr">cts</span>: <span class="number">763</span></div><div class="line">                &#125;, &#123;</div><div class="line">                    <span class="attr">area</span>: <span class="string">'经销商五'</span>,</div><div class="line">                    <span class="attr">lines</span>: <span class="number">5356</span>,</div><div class="line">                    <span class="attr">srx</span>: <span class="number">224</span>,</div><div class="line">                    <span class="attr">xts</span>: <span class="number">323</span>,</div><div class="line">                    <span class="attr">ats</span>: <span class="number">518</span>,</div><div class="line">                    <span class="attr">ct6</span>: <span class="number">341</span>,</div><div class="line">                    <span class="attr">xt5</span>: <span class="number">171</span>,</div><div class="line">                    <span class="attr">cts</span>: <span class="number">623</span></div><div class="line">                &#125;];</div><div class="line">                scope.data = &#123;<span class="attr">areaId</span>: scope.area.area, <span class="attr">sales</span>: scope.sales&#125;;</div><div class="line">                scope.$emit(<span class="string">'getSale'</span>, scope.data);</div><div class="line"></div><div class="line">            &#125;;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="sales"><a href="#sales" class="headerlink" title="sales"></a>sales</h3><p> 关于经销商的指令，思想同上。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/** @ngInject */</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">salesFunc</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> &#123;</div><div class="line">        <span class="attr">restrict</span>: <span class="string">'EA'</span>,</div><div class="line">        <span class="attr">replace</span>: <span class="literal">true</span>,</div><div class="line">        <span class="attr">transclude</span>: <span class="literal">true</span>,</div><div class="line">        <span class="attr">require</span>: <span class="string">'^?saleTable'</span>,</div><div class="line">        <span class="attr">scope</span>: &#123;</div><div class="line">            <span class="attr">areaId</span>: <span class="string">'=areaId'</span>,</div><div class="line">            <span class="attr">sale</span>: <span class="string">'=sale'</span></div><div class="line">        &#125;,</div><div class="line">        <span class="attr">template</span>: <span class="string">'&lt;tr class="gray-bg"&gt;&lt;td class="data-td right-text"&gt;'</span> +</div><div class="line">        <span class="string">'&lt;div class="all-area"&gt;'</span> +</div><div class="line">        <span class="string">'&#123;&#123;sale.area&#125;&#125;'</span> +</div><div class="line">        <span class="string">'&lt;/div&gt; &lt;/td&gt;'</span> +</div><div class="line">        <span class="string">'&lt;td class="data-td red-color"&gt;'</span> +</div><div class="line">        <span class="string">'&#123;&#123;sale.lines&#125;&#125;&lt;/td&gt;'</span> +</div><div class="line">        <span class="string">'&lt;td class="data-td"&gt;'</span> +</div><div class="line">        <span class="string">'&#123;&#123;sale.srx&#125;&#125;&lt;/td&gt;'</span> +</div><div class="line">        <span class="string">'&lt;td class="data-td"&gt;'</span> +</div><div class="line">        <span class="string">'&#123;&#123;sale.xts&#125;&#125;&lt;/td&gt;'</span> +</div><div class="line">        <span class="string">'&lt;td class="data-td"&gt;'</span> +</div><div class="line">        <span class="string">'&#123;&#123;sale.ats&#125;&#125;&lt;/td&gt;'</span> +</div><div class="line">        <span class="string">'&lt;td class="data-td"&gt;'</span> +</div><div class="line">        <span class="string">'&#123;&#123;sale.ct6&#125;&#125;&lt;/td&gt;'</span> +</div><div class="line">        <span class="string">'&lt;td class="data-td"&gt;'</span> +</div><div class="line">        <span class="string">'&#123;&#123;sale.xt5&#125;&#125;&lt;/td&gt;'</span> +</div><div class="line">        <span class="string">'&lt;td class="data-td"&gt;'</span> +</div><div class="line">        <span class="string">'&#123;&#123;sale.cts&#125;&#125; &lt;/td&gt;&lt;/tr&gt;'</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="实现效果"><a href="#实现效果" class="headerlink" title="实现效果"></a>实现效果</h1><p><img src="/images/Cadillac_statistic1.jpeg" alt="Cadillac_statistic"><br><img src="/images/Cadillac_statistic2.jpeg" alt="Cadillac_statistic"><br><img src="/images/Cadillac_statistic3.jpeg" alt="Cadillac_statistic"></p>
]]></content>
    
    <summary type="html">
    
      利用AngularJS的指令实现表格中的树形结构
    
    </summary>
    
      <category term="AngularJS" scheme="http://lijingjing.top/categories/AngularJS/"/>
    
    
      <category term="Directive" scheme="http://lijingjing.top/tags/Directive/"/>
    
  </entry>
  
  <entry>
    <title>HTML5触摸界面设计与开发</title>
    <link href="http://lijingjing.top/blog/2016/11/16/HTML5%E8%A7%A6%E6%91%B8%E7%95%8C%E9%9D%A2%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%BC%80%E5%8F%91/"/>
    <id>http://lijingjing.top/blog/2016/11/16/HTML5触摸界面设计与开发/</id>
    <published>2016-11-16T06:11:39.000Z</published>
    <updated>2016-11-17T09:06:49.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第二章-创建一个简单的内容型网站"><a href="#第二章-创建一个简单的内容型网站" class="headerlink" title="第二章 创建一个简单的内容型网站"></a>第二章 创建一个简单的内容型网站</h1><h2 id="CSS选择器"><a href="#CSS选择器" class="headerlink" title="CSS选择器"></a>CSS选择器</h2><p> CSS选择器要避免使用后代选择器，因为浏览器解析CSS是从右向左的，即如果它看到一个如”nav ul li a”的规则时，它首先必须获得所有匹配a的元素列表，然后检查看它是不是li的后代，再按相同规则继续检查。后代建渣器虽然看起来很方便，但是它的开销是最大的。</p>
<h2 id="em和px"><a href="#em和px" class="headerlink" title="em和px"></a>em和px</h2><p> 一个单位的em总是代表当前的字体大小，em主要用于排版，而不是布局，px才是用来对网页进行布局的最简单的单位。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width"</span>&gt;</span></div></pre></td></tr></table></figure>
<p>  viewport就是一个虚拟的窗口，viewport的边缘代替浏览器的边缘，成为了窗口的边缘。<br></p>
<table>
<thead>
<tr>
<th style="text-align:left">属性</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">width</td>
<td style="text-align:left">设置viewport的宽度，默认值为980，允许的取值范围是200~10000</td>
</tr>
<tr>
<td style="text-align:left">height</td>
<td style="text-align:left">设置viewport的高度。默认值是通过宽度和设备宽高比计算出来的，允许的取值范围是223~10000</td>
</tr>
<tr>
<td style="text-align:left">initial-scale</td>
<td style="text-align:left">设置viewport的出事比例。默认值是通过计算使得整个页面在可见区域内。范围由minimum-scale和maximum-scale属性决定</td>
</tr>
<tr>
<td style="text-align:left">maximum-scale</td>
<td style="text-align:left">设置viewport的最大比例。默认值是5.0。允许的取值范围为0~10.0</td>
</tr>
<tr>
<td style="text-align:left">user-scaleable</td>
<td style="text-align:left">决定用户是否可以缩放视图。还可以防止文本开始输入时的滚动</td>
</tr>
</tbody>
</table>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>使用媒体查询来创建样式的分界点。移动浏览器不可以调整大小，并且没有标准的宽度。任何在移动设备上运行的网页的布局必须是灵活的。我觉着作者的意思应该是，不要写死在移动浏览器中的宽度吧。</p>
<h1 id="第三章-提高第一次加载的速度"><a href="#第三章-提高第一次加载的速度" class="headerlink" title="第三章 提高第一次加载的速度"></a>第三章 提高第一次加载的速度</h1><h2 id="第一次加载速度"><a href="#第一次加载速度" class="headerlink" title="第一次加载速度"></a>第一次加载速度</h2><p>第一次加载速度是用”首字节的时间”测量的，即从用户请求该页面到第一个字节从服务器下载下来的这段时间，此处”首字节的时间”实际上是用来测量”延迟”的。</p>
<h2 id="浏览器如何加载页面"><a href="#浏览器如何加载页面" class="headerlink" title="浏览器如何加载页面"></a>浏览器如何加载页面</h2><h3 id="解析域名"><a href="#解析域名" class="headerlink" title="解析域名"></a>解析域名</h3><ol>
<li>浏览器将一个包含域名的请求发送给DNS服务器</li>
<li>DNS服务器返回对应的IP地址</li>
<li>为了提高性能，减少DNS服务器上的负载，DNS查找机制会被浏览器、设备及设备和服务器之间的路由器和代理服务器缓存。这就是为什么更改DNS记录可能需要几天才能生效的原因。</li>
</ol>
<h3 id="发起请求"><a href="#发起请求" class="headerlink" title="发起请求"></a>发起请求</h3><ol>
<li>浏览器向由DNS查找得到的IP地址的主机发起TCP连接。</li>
<li>然后发送请求，请求中包含网址、浏览器信息、浏览器能接受的数据类型（编码和语言），以及所有相关的cookie，包含域和路径的cookie。</li>
</ol>
<h3 id="下载响应"><a href="#下载响应" class="headerlink" title="下载响应"></a>下载响应</h3><p> 浏览器开始下载响应，随着响应流的到达，浏览器解析HTML并识别出更多的资源。然后浏览器开始获取这些资源。</p>
<h3 id="渲染页面"><a href="#渲染页面" class="headerlink" title="渲染页面"></a>渲染页面</h3><p>浏览器会尽快开始渲染页面。如果页面中外链了CSS或脚本文件时，浏览器会等到这些文件加载和解析（如果是JS，则还需要执行）完再渲染页面。</p>
<h2 id="页面加载缓慢原因"><a href="#页面加载缓慢原因" class="headerlink" title="页面加载缓慢原因"></a>页面加载缓慢原因</h2><h3 id="HTTP连接数"><a href="#HTTP连接数" class="headerlink" title="HTTP连接数"></a>HTTP连接数</h3><p>一个HTTP请求不是只下载数据那么简单，每次请求都包含一定量的额外开销。所以，连续不断的请求许多小文件会比一次请求一个大文件慢很多。<br>为当前域创建两个别名，能允许更多的下载并行，会使大文件下载的性能明显改善。不过由于每个域都需要进行DNS查找，添加太多的域反而会更慢，使用至少两个，至多不超过五个域名是YSlow的经验法则。  另一个要考虑的是cookie，如果cookie有几千个字节，那么此后发送到这个域的每次请求都将把这些字节包含在请求头里，然后发送。服务器还必须在读取请求体之前读取这些cookie。cookie可以把一个很小的请求变得很大。</p>
<h3 id="总字节数"><a href="#总字节数" class="headerlink" title="总字节数"></a>总字节数</h3><p>被下载资源的大小也是影响页面加载速度的原因，所以任何能降低下载资源大小的行为都是值得做的。</p>
<h3 id="等待时的渲染阻塞"><a href="#等待时的渲染阻塞" class="headerlink" title="等待时的渲染阻塞"></a>等待时的渲染阻塞</h3><p>将script标签放到页面尾部。script标签将会阻塞后续的HTML的渲染，直到它所包含的脚本已经下载到本地，并解析执行完毕。当你把外部的JS放在页面头部时，只有在所有脚本加载完后，用户才能看到网页。</p>
<h3 id="网络延迟"><a href="#网络延迟" class="headerlink" title="网络延迟"></a>网络延迟</h3><p>网络连接可以通过带宽（比特）和延迟（毫秒）来测量，网络延迟耽误的时间会被加到链接的请求时间内。</p>
<h3 id="缓存能力差"><a href="#缓存能力差" class="headerlink" title="缓存能力差"></a>缓存能力差</h3><p>要确保浏览器最终不会重复获取已有的资源。</p>
<h2 id="用YSlow和PageSpeed提升速度"><a href="#用YSlow和PageSpeed提升速度" class="headerlink" title="用YSlow和PageSpeed提升速度"></a>用YSlow和PageSpeed提升速度</h2><h3 id="YSlow"><a href="#YSlow" class="headerlink" title="YSlow"></a>YSlow</h3><p>内容分发网络（CDN）是一种服务，让你能够从”周边的服务器”上获取某些（通常静态的）内容：服务器分布在很多地方，最好的情况是可以就近地服务最终用户。这种服务通常用于图像、JS和CSS文件，因为它们不太可能会动态变化。</p>
<h3 id="PageSpeed"><a href="#PageSpeed" class="headerlink" title="PageSpeed"></a>PageSpeed</h3><p>没有看懂为什么设置了报头的过期时间就可以解决不把同一个代理上网的桌面用户定义到移动网站。。</p>
<h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><p>把样式内联，把JS置于底部，并优化图像（媒体查询，不同设备下载不同图像）。</p>
<h1 id="加快下一次访问的速度"><a href="#加快下一次访问的速度" class="headerlink" title="加快下一次访问的速度"></a>加快下一次访问的速度</h1><p>缓存是你第一次访问之后存储数据，它可以让你在下一次访问时跟更迅速。在移动端，与其他终端一样，要尽最大的可能利用缓存。在触摸设备上使用缓存的主要工具是常规的浏览器缓存、本地存储（localStorage）和应用缓存（application cache）。</p>
<h2 id="在HTTP中缓存"><a href="#在HTTP中缓存" class="headerlink" title="在HTTP中缓存"></a>在HTTP中缓存</h2><p>控制HTTP缓存的方式有三种：</p>
<ol>
<li>新鲜度</li>
<li>验证</li>
<li>失效</li>
</ol>
<h3 id="新鲜度"><a href="#新鲜度" class="headerlink" title="新鲜度"></a>新鲜度</h3><p>也成为TTL（生存时间）。是最简单的方式，使用报头，缓存代理会被告知在保持状态和重新获取新内容之前，需要缓存保留该资源多长时间。最简单的处理方法是使用Expires报头。这样做的目的是那些所谓的静态资源（eg:CSS JS），如果可以的话，不用再次获取。</p>
<h3 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h3><p>浏览器可以发出一个包含If-Modified-Since报头的请求，如果服务器上的文件没有发生改变，服务器就会发送一个304 Not Modified的响应，这样浏览器就会使用缓存中已有的文件，而不是从服务器重新获取。  另一个验证功能是ETag.ETag是一种唯一标识符，一般通过哈希算出。它只需要比较一段间断的字符，就能在没有日期信息的情况下验证缓存是否与服务器上的文件相同。请求代理会创建一个有附加条件的请求，并加入If-None-Match报头，它包含了ETag。如果服务器上当前内容能匹配用户的ETag,则服务器会再次返回一个304响应。  验证缓存需要在客户端和服务器之间进行一次往返，虽然比重新下载一个文件好，但是设置较长的过期时间，可以避免浏览器尝试去验证它。</p>
<h3 id="失效"><a href="#失效" class="headerlink" title="失效"></a>失效</h3><p>创建指向相同URL的非GET请求会使缓存失效。</p>
<h3 id="正常的缓存行为"><a href="#正常的缓存行为" class="headerlink" title="正常的缓存行为"></a>正常的缓存行为</h3><p>如果没有改写报头，也没有做其他事，浏览器有正常的缓存行为。大多数浏览器有一个最大缓存大小，当缓存到达这个大小时，就会从缓存中删除最近最少使用的项目。因此，长时间没有被使用的缓存项将被清除，清除哪些缓存完全是基于用户行为的。</p>
<h2 id="网络存储"><a href="#网络存储" class="headerlink" title="网络存储"></a>网络存储</h2><p>网络存储通过localStorage和sessionStorage这两个全局变量来访问。sessionStorage是一种非持久性的存储，会在浏览会话之间被清除掉。它也不能在多个标签页之间共享，因此更适合于存储临时的应用程序数据，而不是被当作缓存使用。除了这一点，localStorage和sessionStorage的其他方面都是相同的。  与cookie一样，网络存储访问有同源策略（某个网页只能访问来自同一域，即”域”、”端口”和”协议”都相同的网络存储设定的值）的限制。如果用户重置浏览器，那么所有的数据都会丢失。  localStorage应该被视为不安全的。和任何（不安全）数据一样，用户可以读取和修改localStorage中的一切内容。</p>
<h3 id="将网络存储作为缓存层来使用"><a href="#将网络存储作为缓存层来使用" class="headerlink" title="将网络存储作为缓存层来使用"></a>将网络存储作为缓存层来使用</h3><p>将网络存储作为缓存层来使用时，可以通过下面公式计算当前剩余空间：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//localStorage的默认存储大小为5M</span></div><div class="line">  <span class="number">1024</span>*<span class="number">1024</span>*<span class="number">5</span> - <span class="built_in">unescape</span>(<span class="built_in">encodeURIComponent</span>(<span class="built_in">JSON</span>.stringify(localStorage))).length</div></pre></td></tr></table></figure>
<h2 id="应用存储"><a href="#应用存储" class="headerlink" title="应用存储"></a>应用存储</h2><p>应用缓存存储是为了web程序没有联网时也能继续使用。使用应用缓存，即使缓存已经到期，文件也不会被立即更新，而是要到用户下一次访问时文件才会被更新。可以用JS API来检查旧缓存。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> appCache = <span class="built_in">window</span>.applicationCache;</div><div class="line">appCache.update();</div></pre></td></tr></table></figure>
<h2 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h2><p>应用缓存可能会带来很多问题，并不建议使用。</p>
]]></content>
    
    <summary type="html">
    
      《HTML5触摸界面设计与开发》读书笔记
    
    </summary>
    
      <category term="读书笔记" scheme="http://lijingjing.top/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="学习" scheme="http://lijingjing.top/tags/%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>利用Angular Directive实现树形结构</title>
    <link href="http://lijingjing.top/blog/2016/09/21/Angular-Directive/"/>
    <id>http://lijingjing.top/blog/2016/09/21/Angular-Directive/</id>
    <published>2016-09-21T05:16:47.000Z</published>
    <updated>2016-11-29T08:45:23.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p> 在做Cadillac的项目时，由于网页端开发要参照媒设老师给的设计图，具体如下： <img src="/images/Cadillac_config.png" alt="Cadillac_config">  我也不清楚是否有现成的插件可以用，感觉应该要自己实现，而且由于自己一直很排斥angular中的指令，觉着好难，为了拯救我自己，所以就逼着自己去学习directive并运用到现有的开发项目中。</p>
<p> 其实我的实现代码本身还是很混乱的，因为点击编辑经常出现没有反应的现象，这个bug好像有时候可以复现，有时候不能复现，而且我一直想总结directive方面的东西，但因为拖延症没有总结。总之，由于bug的飘忽性，我终于决定写一篇关于directive的博客，希望梳理思路的过程中可以找到代码的漏洞，同时整理一下我自己都不想多看的代码。</p>
<h1 id="实现思路"><a href="#实现思路" class="headerlink" title="实现思路"></a>实现思路</h1><h2 id="html文件"><a href="#html文件" class="headerlink" title="html文件"></a>html文件</h2><p> 我本来想车系、配置和颜色各占一栏，这样均分三份就好了。但是由于配置由车系决定，颜色又由配置决定，这种从属关系太复杂，我发现如果我让他们各自独立成三块，不能方便的进行通信，因为每个directive有自己独立的scope，如果兄弟节点之间想要通信，必须借助于父亲，先把消息$emit给父亲，再通过父亲$broadcast给所有的孩子，特定的孩子再进行消息处理。这样我觉着逻辑太复杂，所以就设计了下面的指令形式。</p>
<p> 所有代码如下所示：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"row"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">container</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">configinfo</span> <span class="attr">ng-repeat</span>=<span class="string">"carline in lines"</span>&gt;</span>      </div><div class="line">            <span class="tag">&lt;<span class="name">carline</span> <span class="attr">class</span>=<span class="string">"carline"</span> <span class="attr">line-name</span>=<span class="string">"carline.name"</span> <span class="attr">line-id</span>=<span class="string">"carline.id"</span> <span class="attr">edit</span>=<span class="string">"edit"</span></span></div><div class="line">                     <span class="attr">line-checked</span>=<span class="string">"carline.flag"</span>&gt;</div><div class="line">            <span class="tag">&lt;/<span class="name">carline</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"col-md-6 col-xs-12"</span>&gt;</span></div><div class="line">                <span class="tag">&lt;<span class="name">div</span> <span class="attr">ng-show</span>=<span class="string">"showConfigs"</span>&gt;</span></div><div class="line">                    <span class="tag">&lt;<span class="name">configs</span> <span class="attr">ng-repeat</span>=<span class="string">"config in configs"</span>&gt;</span></div><div class="line">                        <span class="tag">&lt;<span class="name">config</span> <span class="attr">class</span>=<span class="string">"config width-p50"</span> <span class="attr">config-name</span>=<span class="string">"config.name"</span></span></div><div class="line">                                <span class="attr">config-id</span>=<span class="string">"config.id"</span> <span class="attr">carline-id</span>=<span class="string">"carline.id"</span></div><div class="line">                                <span class="attr">config-checked</span>=<span class="string">"config.flag"</span>&gt;</div><div class="line">                        <span class="tag">&lt;/<span class="name">config</span>&gt;</span></div><div class="line">                        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"width-p50"</span> <span class="attr">ng-show</span>=<span class="string">"showColors"</span>&gt;</span></div><div class="line">                            <span class="tag">&lt;<span class="name">div</span> <span class="attr">ng-repeat</span>=<span class="string">"color in colors"</span>&gt;</span></div><div class="line">                                <span class="tag">&lt;<span class="name">color</span> <span class="attr">class</span>=<span class="string">"color"</span> <span class="attr">config-id</span>=<span class="string">"config.id"</span> <span class="attr">color-name</span>=<span class="string">"color.name"</span></span></div><div class="line">                                       <span class="attr">color-id</span>=<span class="string">"color.id"</span> <span class="attr">color-checked</span>=<span class="string">"color.flag"</span>&gt;</div><div class="line">                                <span class="tag">&lt;/<span class="name">color</span>&gt;</span></div><div class="line">                            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">                        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">                    <span class="tag">&lt;/<span class="name">configs</span>&gt;</span></div><div class="line">                <span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"col-xs-6 col-md-3"</span>&gt;</span></div><div class="line">                <span class="comment">&lt;!-- 为了对齐操作那一栏 --&gt;</span></div><div class="line">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">        <span class="tag">&lt;/<span class="name">configinfo</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">container</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div></pre></td></tr></table></figure>
<h2 id="JS文件"><a href="#JS文件" class="headerlink" title="JS文件"></a>JS文件</h2><h3 id="container"><a href="#container" class="headerlink" title="container"></a>container</h3><p> 其中，container是整个控件的容器，是下面所有指令的父亲，一些页面的控制可以写在container的控制器里；</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//directives</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">containerFunc</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> &#123;</div><div class="line">        <span class="attr">restrict</span>: <span class="string">'EA'</span>,</div><div class="line">        <span class="attr">replace</span>: <span class="literal">true</span>,</div><div class="line">        <span class="attr">transclude</span>: <span class="literal">true</span>,</div><div class="line">        <span class="attr">template</span>: <span class="string">'&lt;div ng-transclude&gt;&lt;/div&gt;'</span>,</div><div class="line">        <span class="attr">controller</span>: <span class="function"><span class="keyword">function</span> (<span class="params">$scope</span>) </span>&#123;</div><div class="line">            <span class="keyword">var</span> carlines = [];<span class="comment">//这里获取所有车系的scope，以方便之后判断哪个车系要展开</span></div><div class="line">            <span class="keyword">var</span> colors = [];</div><div class="line">            <span class="keyword">var</span> configs = [];</div><div class="line"></div><div class="line">            <span class="keyword">this</span>.gotConfigOpened = <span class="function"><span class="keyword">function</span> (<span class="params">selectedCarline</span>) </span>&#123;</div><div class="line">              <span class="comment">//刚开始没有选中的车系时，哪个配置都不展开</span></div><div class="line">                <span class="keyword">if</span> (selectedCarline == <span class="literal">undefined</span>) &#123;</div><div class="line">                    angular.forEach(carlines, <span class="function"><span class="keyword">function</span> (<span class="params">carline</span>) </span>&#123;</div><div class="line">                      <span class="comment">//让所有的配置项的icon都为加号</span></div><div class="line">                        carline.$broadcast(<span class="string">'showConfig'</span>, <span class="literal">false</span>);</div><div class="line">                        <span class="comment">//将所有配置项都收起</span></div><div class="line">                        carline.showConfigs = <span class="literal">false</span>;</div><div class="line"></div><div class="line">                    &#125;);</div><div class="line">                &#125;</div><div class="line">                <span class="comment">//根据点击获取车系的id,令当前车系下的配置展开</span></div><div class="line">                <span class="keyword">else</span> &#123;</div><div class="line">                    angular.forEach(carlines, <span class="function"><span class="keyword">function</span> (<span class="params">carline</span>) </span>&#123;</div><div class="line">                        <span class="keyword">if</span> (selectedCarline.lineid != carline.carline.id) &#123;</div><div class="line">                          <span class="comment">//让所有的配置项的icon都为加号</span></div><div class="line">                            carline.$broadcast(<span class="string">'showConfig'</span>, <span class="literal">false</span>);</div><div class="line">                            <span class="comment">//将所有配置项都收起</span></div><div class="line">                            carline.showConfigs = <span class="literal">false</span>;</div><div class="line">                        &#125;</div><div class="line">                        <span class="keyword">else</span> &#123;</div><div class="line">                          <span class="comment">//根据当前点击icon的状态来判断配置是否为收起状态</span></div><div class="line">                            carline.showConfigs = selectedCarline.showConfig;</div><div class="line">                            carline.$emit(<span class="string">'configs'</span>, selectedCarline.lineid);</div><div class="line"></div><div class="line">                        &#125;</div><div class="line">                    &#125;);</div><div class="line">                &#125;</div><div class="line"></div><div class="line"></div><div class="line">            <span class="keyword">this</span>.gotColorOpened = <span class="function"><span class="keyword">function</span> (<span class="params">selectedConfig</span>) </span>&#123;</div><div class="line">               angular.forEach(configs, <span class="function"><span class="keyword">function</span> (<span class="params">config</span>) </span>&#123;</div><div class="line">                   <span class="keyword">if</span> (selectedConfig.configid != config.config.id) &#123;</div><div class="line">                       config.$broadcast(<span class="string">'showColor'</span>, <span class="literal">false</span>);</div><div class="line">                       config.showColors = <span class="literal">false</span>;</div><div class="line">                       config.$emit(<span class="string">'showColors'</span>, <span class="literal">false</span>);</div><div class="line">                   &#125;</div><div class="line">                   <span class="keyword">else</span> &#123;</div><div class="line">                       config.showColors = selectedConfig.showColor;</div><div class="line">                       config.$emit(<span class="string">'showColors'</span>, selectedConfig.showColor);</div><div class="line">                       config.$emit(<span class="string">'colors'</span>, selectedConfig.configid);</div><div class="line"></div><div class="line">                   &#125;</div><div class="line">               &#125;);</div><div class="line">           &#125;;</div><div class="line"></div><div class="line">                <span class="comment">//车系下的配置展开，所有的颜色信息收起</span></div><div class="line">                $scope.colors = [];</div><div class="line">                $scope.$broadcast(<span class="string">'showColor'</span>, <span class="literal">false</span>);</div><div class="line">                $scope.showColors = <span class="literal">false</span>;</div><div class="line">                $scope.$emit(<span class="string">'showColors'</span>, <span class="literal">false</span>);</div><div class="line"></div><div class="line">            &#125;;</div><div class="line"></div><div class="line">            <span class="keyword">this</span>.addCarLine = <span class="function"><span class="keyword">function</span> (<span class="params">carline</span>) </span>&#123;</div><div class="line">                carlines.push(carline);</div><div class="line">            &#125;;</div><div class="line"></div><div class="line">            <span class="keyword">this</span>.addConfig = <span class="function"><span class="keyword">function</span> (<span class="params">config</span>) </span>&#123;</div><div class="line">               configs.push(config);</div><div class="line">           &#125;;</div><div class="line"></div><div class="line">            <span class="keyword">this</span>.addColor = <span class="function"><span class="keyword">function</span> (<span class="params">color</span>) </span>&#123;</div><div class="line">                colors.push(color);</div><div class="line">            &#125;;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="configinfo"><a href="#configinfo" class="headerlink" title="configinfo"></a>configinfo</h3><p> configinfo用来拿到车系信息，作为下层指令的父亲，所有的孩子都可以获取车系的相关信息；</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">configinfoFunc</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> &#123;</div><div class="line">        <span class="attr">restrict</span>: <span class="string">'EA'</span>,</div><div class="line">        <span class="attr">replace</span>: <span class="literal">true</span>,</div><div class="line">        <span class="attr">transclude</span>: <span class="literal">true</span>,</div><div class="line">        <span class="attr">require</span>: <span class="string">'^?container'</span>,</div><div class="line">        <span class="attr">template</span>: <span class="string">'&lt;div class="row configinfo" ng-transclude&gt;&lt;/div&gt;'</span>,</div><div class="line">        <span class="attr">link</span>: <span class="function"><span class="keyword">function</span> (<span class="params">scope, element, attrs, containerController</span>) </span>&#123;</div><div class="line">          <span class="comment">//将当前车系的scope加入到父亲控制器的变量中，为之后配置的展开与收起做准备</span></div><div class="line">            containerController.addCarLine(scope);</div><div class="line">            scope.$on(<span class="string">'showColors'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">d, data</span>) </span>&#123;</div><div class="line">                scope.showColors = data;</div><div class="line">            &#125;);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="carline"><a href="#carline" class="headerlink" title="carline"></a>carline</h3><p> carline为具体的车系指令，显示车系，并在编辑状态下，显示前面的复选框，这样来让操作人员控制哪些车系现在可以放到系统里进行售卖；</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">carlineFunc</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> &#123;</div><div class="line">        <span class="attr">restrict</span>: <span class="string">'EA'</span>,</div><div class="line">        <span class="attr">replace</span>: <span class="literal">true</span>,</div><div class="line">        <span class="attr">transclude</span>: <span class="literal">true</span>,</div><div class="line">        <span class="attr">require</span>: <span class="string">'^?container'</span>,</div><div class="line">        <span class="attr">scope</span>: &#123;<span class="comment">//传递信息给当前作用域</span></div><div class="line">            linename: <span class="string">'=lineName'</span>,</div><div class="line">            <span class="attr">lineid</span>: <span class="string">'=lineId'</span>,</div><div class="line">            <span class="attr">carlineChecked</span>: <span class="string">'=lineChecked'</span>,</div><div class="line">            <span class="attr">edit</span>: <span class="string">'=edit'</span></div><div class="line">        &#125;,</div><div class="line">        <span class="attr">template</span>: <span class="string">'&lt;div class="col-md-3 col-xs-6"&gt;'</span> +</div><div class="line">        <span class="string">'&lt;div class="checkbox" ng-show="edit"&gt;'</span> +</div><div class="line">        <span class="string">'&lt;label class="custom-checkbox"&gt;'</span> +</div><div class="line">        <span class="string">'&lt;input type="checkbox"  ng-model="carlineChecked" ng-change="lineChange(carlineChecked,lineid)"&gt;'</span> +</div><div class="line">        <span class="string">'&lt;span&gt;&#123;&#123;linename&#125;&#125;&lt;/span&gt;&lt;/label&gt; &lt;/div&gt;&lt;span ng-show="!edit"&gt;&#123;&#123;linename&#125;&#125;&lt;/span&gt;'</span> +</div><div class="line">        <span class="string">'&lt;i class="ion-ios-plus-outline addIcon config-icon" ng-show="(!showConfig)&amp;&amp;edit" ng-transclude ng-click="toggle()"&gt;&lt;/i&gt;'</span> +</div><div class="line">        <span class="string">'&lt;i class="ion-chevron-left addIcon config-icon" ng-show="showConfig&amp;&amp;edit" ng-transclude ng-click="toggle()"&gt;&lt;/i&gt;'</span> +</div><div class="line">        <span class="string">'&lt;/div&gt;'</span>,</div><div class="line">        <span class="attr">link</span>: <span class="function"><span class="keyword">function</span> (<span class="params">scope, element, attrs, containerController</span>) </span>&#123;</div><div class="line">          <span class="comment">//标志位，用来判断，当前后面的信息是否展开</span></div><div class="line">          <span class="comment">//如果为true，说明后面的配置项已经展开，图标为小于号</span></div><div class="line">          <span class="comment">//如果为false，说明后面的配置项收起，图标为加号</span></div><div class="line">            scope.showConfig = <span class="literal">false</span>;</div><div class="line"></div><div class="line">            scope.$on(<span class="string">'edit'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">d, data</span>) </span>&#123;</div><div class="line">                scope.edit = data;</div><div class="line">                scope.showConfig = <span class="literal">false</span>;</div><div class="line">                <span class="comment">//点击编辑，强制将所有项都收起，恢复初始状态</span></div><div class="line">                containerController.gotConfigOpened(<span class="literal">undefined</span>);</div><div class="line">            &#125;);</div><div class="line"></div><div class="line">            <span class="comment">//获取当前是否被勾选，然后发送消息给父亲scope，进行之后的信息保存</span></div><div class="line">            scope.lineChange = <span class="function"><span class="keyword">function</span> (<span class="params">carlineChecked, lineId</span>) </span>&#123;</div><div class="line">                <span class="keyword">var</span> data = &#123;<span class="attr">id</span>: lineId, <span class="attr">flag</span>: carlineChecked&#125;;</div><div class="line">                scope.$emit(<span class="string">'lineChange'</span>, data);</div><div class="line">            &#125;;</div><div class="line"></div><div class="line">            <span class="comment">//接收showConfig消息</span></div><div class="line">            scope.$on(<span class="string">'showConfig'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">d, data</span>) </span>&#123;</div><div class="line">                scope.showConfig = data;</div><div class="line">            &#125;);</div><div class="line"></div><div class="line">            scope.toggle = <span class="function"><span class="keyword">function</span> <span class="title">toggle</span>(<span class="params"></span>) </span>&#123;</div><div class="line">                scope.showConfig = !scope.showConfig;</div><div class="line">                containerController.gotConfigOpened(scope);</div><div class="line">            &#125;;</div><div class="line"></div><div class="line"></div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="configs"><a href="#configs" class="headerlink" title="configs"></a>configs</h3><p> configs用来获取所有的配置信息，并将所有配置的scope存放到container中，即最外层指令中。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">configsFunc</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> &#123;</div><div class="line">        <span class="attr">restrict</span>: <span class="string">'EA'</span>,</div><div class="line">        <span class="attr">replace</span>: <span class="literal">true</span>,</div><div class="line">        <span class="attr">transclude</span>: <span class="literal">true</span>,</div><div class="line">        <span class="attr">require</span>: <span class="string">'^?container'</span>,</div><div class="line">        <span class="attr">template</span>: <span class="string">'&lt;div class="row configinfo" ng-transclude&gt;&lt;/div&gt;'</span>,</div><div class="line">        <span class="attr">link</span>: <span class="function"><span class="keyword">function</span> (<span class="params">scope, element, attrs, containerController</span>) </span>&#123;</div><div class="line">            containerController.addConfig(scope);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="config"><a href="#config" class="headerlink" title="config"></a>config</h3><p> config为具体某个配置。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">configFunc</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> &#123;</div><div class="line">        <span class="attr">restrict</span>: <span class="string">'EA'</span>,</div><div class="line">        <span class="attr">replace</span>: <span class="literal">true</span>,</div><div class="line">        <span class="attr">transclude</span>: <span class="literal">true</span>,</div><div class="line">        <span class="attr">require</span>: <span class="string">'^?container'</span>,</div><div class="line">        <span class="attr">scope</span>: &#123;</div><div class="line">            <span class="attr">configname</span>: <span class="string">'=configName'</span>,</div><div class="line">            <span class="attr">configid</span>: <span class="string">'=configId'</span>,</div><div class="line">            <span class="attr">carlineid</span>: <span class="string">'=carlineId'</span>,</div><div class="line">            <span class="attr">configChecked</span>: <span class="string">'=configChecked'</span></div><div class="line">        &#125;,</div><div class="line">        <span class="attr">template</span>: <span class="string">'&lt;div class="config"&gt;'</span> +</div><div class="line">        <span class="string">'&lt;div class="checkbox"&gt;'</span> +</div><div class="line">        <span class="string">'&lt;label class="custom-checkbox"&gt;'</span> +</div><div class="line">        <span class="string">'&lt;input type="checkbox"  ng-model="configChecked" ng-change="configChange(configChecked,configid)"&gt;'</span> +</div><div class="line">        <span class="string">'&lt;span&gt;&#123;&#123;configname&#125;&#125;&lt;/span&gt;&lt;/label&gt; &lt;/div&gt;'</span> +</div><div class="line">        <span class="string">'&lt;i class="ion-ios-plus-outline config-icon" ng-show="!showColor" ng-transclude ng-click="toggle()"&gt;&lt;/i&gt;'</span> +</div><div class="line">        <span class="string">'&lt;i class="ion-chevron-left config-icon" ng-show="showColor" ng-transclude ng-click="toggle()"&gt;&lt;/i&gt;'</span> +</div><div class="line">        <span class="string">'&lt;/div&gt;'</span>,</div><div class="line">        <span class="attr">link</span>: <span class="function"><span class="keyword">function</span> (<span class="params">scope, element, attrs, containerController</span>) </span>&#123;</div><div class="line">            scope.showColor = <span class="literal">false</span>;</div><div class="line">            scope.$on(<span class="string">'showColor'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">d, data</span>) </span>&#123;</div><div class="line">                scope.showColor = data;</div><div class="line">            &#125;);</div><div class="line"></div><div class="line">            scope.toggle = <span class="function"><span class="keyword">function</span> <span class="title">toggle</span>(<span class="params"></span>) </span>&#123;</div><div class="line">                scope.showColor = !scope.showColor;</div><div class="line">                containerController.gotColorOpened(scope);</div><div class="line">            &#125;;</div><div class="line"></div><div class="line">            scope.configChange = <span class="function"><span class="keyword">function</span> (<span class="params">configChecked, configId</span>) </span>&#123;</div><div class="line">                <span class="keyword">var</span> data = &#123;<span class="attr">id</span>: configId, <span class="attr">flag</span>: configChecked&#125;;</div><div class="line">                scope.$emit(<span class="string">'configChange'</span>, data);</div><div class="line">            &#125;;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="color"><a href="#color" class="headerlink" title="color"></a>color</h3><p> color为某个具体车系下的所有颜色。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">colorFunc</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> &#123;</div><div class="line">        <span class="attr">restrict</span>: <span class="string">'EA'</span>,</div><div class="line">        <span class="attr">replace</span>: <span class="literal">true</span>,</div><div class="line">        <span class="attr">transclude</span>: <span class="literal">true</span>,</div><div class="line">        <span class="attr">require</span>: <span class="string">'^?container'</span>,</div><div class="line">        <span class="attr">scope</span>: &#123;</div><div class="line">            <span class="attr">colorname</span>: <span class="string">'=colorName'</span>,</div><div class="line">            <span class="attr">colorid</span>: <span class="string">'=colorId'</span>,</div><div class="line">            <span class="attr">configid</span>: <span class="string">'=configId'</span>,</div><div class="line">            <span class="attr">colorChecked</span>: <span class="string">'=colorChecked'</span></div><div class="line">        &#125;,</div><div class="line">        <span class="attr">template</span>: <span class="string">'&lt;div class="color"&gt;'</span> +</div><div class="line">        <span class="string">'&lt;div class="checkbox"&gt;'</span> +</div><div class="line">        <span class="string">'&lt;label class="custom-checkbox"&gt;'</span> +</div><div class="line">        <span class="string">'&lt;input type="checkbox" id="checkboxWarning" ng-model="colorChecked" ng-change="colorChange(colorid,colorChecked)"&gt;'</span> +</div><div class="line">        <span class="string">'&lt;span&gt;&#123;&#123;colorname&#125;&#125;&lt;/span&gt;'</span> +</div><div class="line">        <span class="string">'&lt;/label&gt; &lt;/div&gt;'</span>,</div><div class="line">        <span class="attr">link</span>: <span class="function"><span class="keyword">function</span> (<span class="params">scope, element, attrs, containerController</span>) </span>&#123;</div><div class="line">            containerController.addColor(scope);</div><div class="line">            scope.colorChange = <span class="function"><span class="keyword">function</span> (<span class="params">id, flag</span>) </span>&#123;</div><div class="line">                <span class="keyword">var</span> data = &#123;<span class="attr">id</span>: id, <span class="attr">flag</span>: flag&#125;;</div><div class="line">                scope.$emit(<span class="string">'colorChange'</span>, data);</div><div class="line">            &#125;;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="数据缓存"><a href="#数据缓存" class="headerlink" title="数据缓存"></a>数据缓存</h3><p> 如果每次展开和收起都要重新去服务器拉取数据，这样是网络延迟比较高的情况下，用户体验是很差的，所以，可以把第一次获取的数据缓存到当前页面中。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//ctrl</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">ConfigInfoCtrl</span>(<span class="params">$scope, $filter, ConfigInfoService, $state, $stateParams</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> submitLines = [];</div><div class="line">    <span class="keyword">var</span> submitConfigs = [];</div><div class="line">    <span class="keyword">var</span> submitColors = [];</div><div class="line"></div><div class="line">    <span class="keyword">var</span> tempConfigs = [];</div><div class="line">    <span class="keyword">var</span> tempColors = [];</div><div class="line"></div><div class="line"></div><div class="line">    $scope.$on(<span class="string">'configs'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">d, lineId</span>) </span>&#123;</div><div class="line">        $scope.configs = [];</div><div class="line">        <span class="keyword">if</span> (tempConfigs[lineId] == <span class="literal">null</span> || tempConfigs[lineId] == <span class="literal">undefined</span>) &#123;</div><div class="line"></div><div class="line">            ConfigInfoService.getConfigs(lineId).success(<span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</div><div class="line">                $scope.configs = data.data;</div><div class="line">                tempConfigs[lineId] = data.data;</div><div class="line">            &#125;);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span></div><div class="line">            $scope.configs = tempConfigs[lineId];</div><div class="line"></div><div class="line">    &#125;);</div><div class="line"></div><div class="line">    $scope.$on(<span class="string">'colors'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">d, configId</span>) </span>&#123;</div><div class="line">        $scope.colors = [];</div><div class="line">        <span class="keyword">if</span> (tempColors[configId] == <span class="literal">null</span> || tempColors[configId] == <span class="literal">undefined</span>) &#123;</div><div class="line">            ConfigInfoService.getColors(configId).success(<span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</div><div class="line">                $scope.colors = data.data;</div><div class="line">                tempColors[configId] = data.data;</div><div class="line">            &#125;);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span> &#123;</div><div class="line">            $scope.colors = tempColors[configId];</div><div class="line">        &#125;</div><div class="line"></div><div class="line">    &#125;);</div><div class="line"></div><div class="line">    ConfigInfoService.getLines().success(<span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</div><div class="line">        $scope.lines = data.data;</div><div class="line">    &#125;);</div><div class="line"></div><div class="line">    $scope.$on(<span class="string">'lineChange'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">d, data</span>) </span>&#123;</div><div class="line">        submitLines.push(data);</div><div class="line">    &#125;);</div><div class="line"></div><div class="line">    $scope.$on(<span class="string">'configChange'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">d, data</span>) </span>&#123;</div><div class="line">        submitConfigs.push(data);</div><div class="line">    &#125;);</div><div class="line"></div><div class="line">    $scope.$on(<span class="string">'colorChange'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">d, data</span>) </span>&#123;</div><div class="line">        submitColors.push(data);</div><div class="line">    &#125;);</div><div class="line">    $scope.edit = <span class="literal">false</span>;</div><div class="line"></div><div class="line">    $scope.startEdit = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line"></div><div class="line">        $scope.edit = <span class="literal">true</span>;</div><div class="line">        $scope.$broadcast(<span class="string">'edit'</span>, <span class="literal">true</span>);</div><div class="line">    &#125;;</div><div class="line"></div><div class="line">    $scope.cancelEdit = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">        submitLines = [];</div><div class="line">        submitConfigs = [];</div><div class="line">        submitColors = [];</div><div class="line"></div><div class="line">        tempConfigs = [];</div><div class="line"></div><div class="line">        tempColors = [];</div><div class="line">        $scope.edit = <span class="literal">false</span>;</div><div class="line">        $scope.$broadcast(<span class="string">'edit'</span>, <span class="literal">false</span>);</div><div class="line">        $scope.$broadcast(<span class="string">'showColor'</span>, <span class="literal">false</span>);</div><div class="line">        $scope.$broadcast(<span class="string">'showConfig'</span>, <span class="literal">false</span>);</div><div class="line">        ConfigInfoService.getLines().success(<span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</div><div class="line">            $scope.lines = data.data;</div><div class="line">        &#125;);</div><div class="line">    &#125;;</div><div class="line"></div><div class="line">    $scope.updateConfig = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line"></div><div class="line">        <span class="keyword">var</span> params = &#123;<span class="attr">line</span>: submitLines, <span class="attr">configuration</span>: submitConfigs, <span class="attr">color</span>: submitColors&#125;;</div><div class="line"></div><div class="line">        ConfigInfoService.updateConfigs(<span class="built_in">JSON</span>.stringify(params)).success(<span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</div><div class="line">            $scope.edit = <span class="literal">false</span>;</div><div class="line">            $scope.$broadcast(<span class="string">'edit'</span>, <span class="literal">false</span>);</div><div class="line">            alert(<span class="string">"提交成功!"</span>);</div><div class="line">        &#125;);</div><div class="line">    &#125;;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="实现结果"><a href="#实现结果" class="headerlink" title="实现结果"></a>实现结果</h1><p><img src="/images/Cadillac1.jpeg" alt="Cadillac_config"><br><img src="/images/Cadillac2.jpeg" alt="Cadillac_config"><br><img src="/images/Cadillac3.jpeg" alt="Cadillac_config">   </p>
]]></content>
    
    <summary type="html">
    
      AngularJS Directive实践
    
    </summary>
    
      <category term="AngularJS" scheme="http://lijingjing.top/categories/AngularJS/"/>
    
    
      <category term="Directive" scheme="http://lijingjing.top/tags/Directive/"/>
    
  </entry>
  
</feed>
