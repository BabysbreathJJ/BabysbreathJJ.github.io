<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="chrome=1">

    

    <title>
      阿菁菁菁菁菁 | 阿菁菁菁菁菁
    </title>

    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
    
      <meta name="author" content="阿菁菁菁菁菁">
    
    

    <meta name="description" content="JavaScrip继承">
<meta property="og:type" content="article">
<meta property="og:title" content="阿菁菁菁菁菁 | 阿菁菁菁菁菁">
<meta property="og:url" content="http://lijingjing.top/blog/2016/05/17/JS继承/index.html">
<meta property="og:site_name" content="阿菁菁菁菁菁">
<meta property="og:description" content="JavaScrip继承">
<meta property="og:image" content="http://lijingjing.top/images/inherit.png">
<meta property="og:image" content="http://lijingjing.top/images/inherit_all.png">
<meta property="og:updated_time" content="2016-05-30T03:55:14.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="阿菁菁菁菁菁 | 阿菁菁菁菁菁">
<meta name="twitter:description" content="JavaScrip继承">
<meta name="twitter:image" content="http://lijingjing.top/images/inherit.png">

    
    
      <link rel="icon" type="image/x-icon" href="/images/avatar.png">
    
    <link rel="stylesheet" href="/css/uno.css">
    <link rel="stylesheet" href="/css/highlight.css">
    <link rel="stylesheet" href="/css/archive.css">
    <link rel="stylesheet" href="/css/china-social-icon.css">


</head>
<body>

    
      <header class="panel-cover panel-cover--collapsed">


  <div class="panel-main">


    <div class="panel-main__inner panel-inverted">
    <div class="panel-main__content">

        
        <a href="/" title="link to homepage for 阿菁菁菁菁菁"><img src="/images/avatar.png" width="100" alt="阿菁菁菁菁菁 logo" class="panel-cover__logo logo" /></a>
        

        <h1 class="panel-cover__title panel-title"><a href="/" title="link to homepage">阿菁菁菁菁菁</a></h1>
        <hr class="panel-cover__divider" />

        
        <h2 class="panel-cover__description panel-description-small">
          Change takes time.
        </h2>
        <hr class="panel-cover__divider panel-cover__divider--secondary" />
        

        <div class="navigation-wrapper">


        <nav class="cover-navigation cover-navigation--primary">
          <ul class="navigation">
            
              
              <li class="navigation__item"><a href="/blog" title="" class="blog-button">文章</a></li>
            
              
              <li class="navigation__item"><a href="/archive" title="" class="">归档</a></li>
            
              
              <li class="navigation__item"><a href="/about" title="" class="">关于我</a></li>
            

          </ul>
        </nav>

      <!-- ----------------------------
To add a new social icon simply duplicate one of the list items from below
and change the class in the <i> tag to match the desired social network
and then add your link to the <a>. Here is a full list of social network
classes that you can use:

    icon-social-500px
    icon-social-behance
    icon-social-delicious
    icon-social-designer-news
    icon-social-deviant-art
    icon-social-digg
    icon-social-dribbble
    icon-social-facebook
    icon-social-flickr
    icon-social-forrst
    icon-social-foursquare
    icon-social-github
    icon-social-google-plus
    icon-social-hi5
    icon-social-instagram
    icon-social-lastfm
    icon-social-linkedin
    icon-social-medium
    icon-social-myspace
    icon-social-path
    icon-social-pinterest
    icon-social-rdio
    icon-social-reddit
    icon-social-skype
    icon-social-spotify
    icon-social-stack-overflow
    icon-social-steam
    icon-social-stumbleupon
    icon-social-treehouse
    icon-social-tumblr
    icon-social-twitter
    icon-social-vimeo
    icon-social-xbox
    icon-social-yelp
    icon-social-youtube
    icon-social-zerply
    icon-mail

-------------------------------->

<!-- add social info here -->



<nav class="cover-navigation navigation--social">
  <ul class="navigation">

    
      <!-- Github -->
      <li class="navigation__item">
        <a href="https://github.com/BabysbreathJJ" title="阿菁 on GitHub">
          <i class='icon icon-social-github'></i>
          <span class="label">GitHub</span>
        </a>
      </li>
      <li class="navigation__item">
        <a href="mailto:lijingjing1008@gmail.com" title="阿菁‘s e-mail">
          <i class='icon icon-mail'></i>
          <span class="label">Mail</span>
        </a>
      </li>
      <li class="navigation__item">
        <a href="http://weibo.com/2797656002/profile" title="阿菁 on Weibo">
          <i class='icon cs-icon-weibo'></i>
          <span class="label">Weibo</span>
        </a>
      </li>
    

    <!-- China social icon -->
    <!--

      <li class="navigation__item">
        <a href="" title="">
          <i class='icon cs-icon-douban'></i>
          <span class="label">Douban</span>
        </a>
      </li>



    -->



  </ul>
</nav>




      <nav class="cover-navigation cover-navigation--primary">
        <h2 class="panel-cover__description panel-description-small">
        友情链接
        </h2>
        <ul class="navigation">
          
            <li class="friend__item"><a target="_blank" href="http://gaocegege.com/Blog" title="" class="">高策</a></li>
          
            <li class="friend__item"><a target="_blank" href="http://lizheming.top/" title="" class="">黎哲明</a></li>
          
            <li class="friend__item"><a target="_blank" href="http://peipeili.cn/" title="" class="">李佩佩</a></li>
          

        </ul>
      </nav>


        </div>

      </div>

    </div>

    <div class="panel-cover--overlay"></div>
  </div>
</header>

      <span class="mobile btn-mobile-menu">
          <i class="icon icon-list btn-mobile-menu__icon"></i>
          <i class="icon icon-x-circle btn-mobile-close__icon hidden"></i>
      </span>
      <div class="content-wrapper">
          <div class="content-wrapper__inner entry">
              

<article class="post-container post-container--single">

  <header class="post-header">

    <h1 class="post-title">JS继承</h1>

    

    <div class="post-meta">
      <time datetime="2016-05-17" class="post-meta__date date">2016-05-17</time>

      <span class="post-meta__tags tags">
          
            <font class="categories">
            &#8226; 分类:
            <a class="categories-link" href="/categories/学习笔记/">学习笔记</a>, <a class="categories-link" href="/categories/学习笔记/javascript/">javascript</a>
            </font>
          

          
             &#8226; 标签:
            <font class="tags">
              <a class="tags-link" href="/tags/面向对象/">面向对象</a>
            </font>
          
        </span>
     </div>
    

  </header>

  <section id="post-content" class="article-content post">
    <p> 许多OO语言都支持两种继承方式：接口继承和实现继承。接口继承只继承方法签名，而实现继承则继承实际的方法。由于函数没有签名，在ECMAScript中无法实现接口继承。ECMAScript只支持实现继承，而且其实现继承主要是依靠原型链来实现的。</p>
<h1 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h1><p> 基本思想是利用原型让一个引用类型继承另一个引用类型的属性和方法。引用类型是一种数据结构，用于将数据和功能组织在一起。它也经常被称为类，但这种称呼并不妥当。引用类型有时候也被称为对象定义，因为它们描述的是一类对象所具有的属性和方法。<br>引用类型：</p>
<ol>
<li>Object类型</li>
<li>Array类型</li>
<li>Date类型</li>
<li>RegExp类型</li>
<li>Function类型</li>
<li>基本包装类型（Boolean类型，Number类型，String类型）</li>
<li>单体内置类型（Global对象，Math对象）   </li>
</ol>
<p></p><p>实现原型链有一种基本模式：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  <span class="keyword">this</span>.property = <span class="literal">true</span>;</div><div class="line">&#125;</div><div class="line">SuperType.prototype.getSuperValue = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.property;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  <span class="keyword">this</span>.subProperty = <span class="literal">false</span>;</div><div class="line">&#125;</div><div class="line"><span class="comment">//继承了superType</span></div><div class="line">SubType.prototype = <span class="keyword">new</span> SuperType();</div><div class="line"></div><div class="line"><span class="comment">//函数定义必须在继承之后</span></div><div class="line">SubType.prototype.getSubValue = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.subProperty;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> instance = <span class="keyword">new</span> SubType();</div><div class="line">alert(instance.getSuperValue());</div></pre></td></tr></table></figure>
<p> 上例是通过创建SuperType的实例来实现继承的，实现的本质是重写原型对象。原来存在于SuperType中的属性和方法，现在也存在于SubType.prototype中了,因为现在SubType.prototype是SuperType的一个实例对象，所以会有实例属性property，以及可以访问SuperType的原型方法getSuperValue。<strong>要注意，现在instance.constructor指向的是superType,这是因为原来SubType.prototype中的constructor被重写了。实际上不是SubType的原型的constructor属性被重写了，而是SubType的原型指向了另一个对象–SuperType的原型，而这个原型对象的constructor属性指向的是SuperType。</strong><br>  <img src="/images/inherit.png" alt="原型链"></p>
<h2 id="别忘记默认的原型"><a href="#别忘记默认的原型" class="headerlink" title="别忘记默认的原型"></a>别忘记默认的原型</h2><p> 所有的引用类型默认都继承了Object，这个继承也是通过原型链实现的。所有函数的默认原型都是Object的实例，因此默认原型都会包含一个内部指针指向Object.prototype。这也是所有自定义类型都会继承toString()、valueOf()等默认方法的根本原因。<br><img src="/images/inherit_all.png" alt="完整原型链"></p>
<h2 id="确定原型和实例的关系"><a href="#确定原型和实例的关系" class="headerlink" title="确定原型和实例的关系"></a>确定原型和实例的关系</h2><p> 两种方法来确定原型和实例之间的关系。</p>
<h3 id="instanceof操作符"><a href="#instanceof操作符" class="headerlink" title="instanceof操作符"></a>instanceof操作符</h3><p>只要用这个操作符来测试实例与原型链中出现过的构造函数，结果就会返回true。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">alert(instance <span class="keyword">instanceof</span> <span class="built_in">Object</span>); <span class="comment">//true</span></div><div class="line">alert(instance <span class="keyword">instanceof</span> SuperType); <span class="comment">//true</span></div><div class="line">alert(instance <span class="keyword">instanceof</span> SubType); <span class="comment">//true</span></div></pre></td></tr></table></figure>
<h3 id="isPrototypeOf-方法"><a href="#isPrototypeOf-方法" class="headerlink" title="isPrototypeOf()方法"></a>isPrototypeOf()方法</h3><p>只要是原型链中出现过的原型，都可以是该原型链所派生的实例原型。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">alert(<span class="built_in">Object</span>.prototype.isPrototypeOf(instance)); <span class="comment">//true</span></div><div class="line">alert(SuperType.prototype.isPrototypeOf(instance)); <span class="comment">//true</span></div><div class="line">alert(SubType.prototype.isPrototypeOf(instance)); <span class="comment">//true</span></div></pre></td></tr></table></figure>
<h2 id="谨慎地定义方法"><a href="#谨慎地定义方法" class="headerlink" title="谨慎地定义方法"></a>谨慎地定义方法</h2><p> 子类型有时候需要重写超类型中的某个方法，或者需要添加超类型中不存在的某个方法。<br><strong>不管怎么样，给原型添加方法的代码一定要方法替换原型的语句之后，即放在继承之后； 通过原型链实现继承时，不能使用对象字面量创建原型方法。因为这样就会重写原型链。</strong>  </p>
<h2 id="原型链的问题"><a href="#原型链的问题" class="headerlink" title="原型链的问题"></a>原型链的问题</h2><p> 包含引用类型值的原型属性会被所有实例共享，所以应该在构造函数中，而不是在原型对象中定义属性。在通过原型来实现继承时，原型实际上会变成另一个类型的实例，所以，原先的实例属性也就成了现在的原型属性了。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  <span class="keyword">this</span>.colors = [<span class="string">'red'</span>,<span class="string">'blue'</span>,<span class="string">'green'</span>];</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params"></span>)</span>&#123;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//继承了SuperValue</span></div><div class="line">SubType.prototype = <span class="keyword">new</span> SuperType();</div><div class="line"></div><div class="line"><span class="keyword">var</span> instance1 = <span class="keyword">new</span> SubType();</div><div class="line">instance1.colors.push(<span class="string">'black'</span>);</div><div class="line">alert(instance1.colors); <span class="comment">// 'red,blue,green,black'</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> instance2 = <span class="keyword">new</span> SubType();</div><div class="line">alert(instance2.colors); <span class="comment">// 'red,blue,green,black'</span></div></pre></td></tr></table></figure>
<p> 另一个问题是，在创建子类型的实例中，不能向超类型的构造函数中传递参数（不懂什么情况下需要给超类型的构造函数传递参数），实际上应该说没办法在不影响所有对象实例的情况下，给超类型的构造函数传递参数。<br>  实际上很少会单独使用原型链。</p>
<h1 id="借用构造函数（constructor-stealing）"><a href="#借用构造函数（constructor-stealing）" class="headerlink" title="借用构造函数（constructor stealing）"></a>借用构造函数（constructor stealing）</h1><p> 借用构造函数的技术，有时候也叫作伪造对象或经典继承。即在子类型构造函数的内部调用超类型构造函数。函数是在特定环境中执行代码的对象，因此可以通过使用apply()和call()方法可以在新创建的对象上执行构造函数。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  <span class="keyword">this</span>.colors = [<span class="string">"red,black,white"</span>];</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  <span class="comment">//继承了SuperType</span></div><div class="line">  SuperType.call(<span class="keyword">this</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> instance1 = <span class="keyword">new</span> SubType();</div><div class="line">instance1.colors.push(<span class="string">"blue"</span>);</div><div class="line">alert(instance1.colors);<span class="comment">//red,black,white,blue</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> instance2 = <span class="keyword">new</span> SubType();</div><div class="line">alert(instance2.colors);<span class="comment">//red,black,white</span></div></pre></td></tr></table></figure>
<h2 id="传递参数"><a href="#传递参数" class="headerlink" title="传递参数"></a>传递参数</h2><p> 借用构造函数，可以在子类型构造函数中向超类型构造函数传递参数。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params">name</span>)</span>&#123;</div><div class="line">  <span class="keyword">this</span>.name = name;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  <span class="comment">//继承了SuperType,同时还传递了参数</span></div><div class="line">  SuperType.call(<span class="keyword">this</span>,<span class="string">"LiJingjing"</span>);</div><div class="line">  <span class="keyword">this</span>.age = <span class="number">22</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> instance = <span class="keyword">new</span> SubType();</div><div class="line">alert(instance.name);<span class="comment">//LiJingjing</span></div><div class="line">alert(instance.age);<span class="comment">//22</span></div></pre></td></tr></table></figure>
<p> 在SubType构造函数内部调用SuperType构造函数时，实际上是为了SubType的实例设置了name属性，为了确保SuperType构造函数不会重写子类型的属性，可以在调用超类型构造函数后，再添加应该在子类型中定义的属性。</p>
<h2 id="借用构造函数的问题"><a href="#借用构造函数的问题" class="headerlink" title="借用构造函数的问题"></a>借用构造函数的问题</h2><p> 如果仅仅使用构造函数，那么方法都在构造函数中定义，就无法实现函数复用。在超类型的原型中定义的方法，对子类型而言也是不可见的，结果所有类型都只能使用构造函数模式。所以很少单独使用构造函数。</p>
<h1 id="组合继承（最常用的继承模式）"><a href="#组合继承（最常用的继承模式）" class="headerlink" title="组合继承（最常用的继承模式）"></a>组合继承（最常用的继承模式）</h1><p> 组合继承（combination inheritance），指将原型链和借用构造函数的技术组合在一起，背后的思想是使用原型链实现对原型属性和方法的继承，通过借用构造函数来实现对实例属性的继承。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params">name</span>)</span>&#123;</div><div class="line">  <span class="keyword">this</span>.name = name;</div><div class="line">  <span class="keyword">this</span>.colors = [<span class="string">"white"</span>,<span class="string">"black"</span>,<span class="string">"red"</span>];</div><div class="line">&#125;</div><div class="line"></div><div class="line">SuperType.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  alert(<span class="keyword">this</span>.name);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params">name,age</span>)</span>&#123;</div><div class="line">  <span class="comment">//继承实例属性</span></div><div class="line">  SuperType.call(<span class="keyword">this</span>,name);</div><div class="line">  <span class="keyword">this</span>.age = age;</div><div class="line">&#125;</div><div class="line">SubType.prototype = <span class="keyword">new</span> SuperType();<span class="comment">//继承原型属性和方法</span></div><div class="line">SubType.prototype.constructor = SubType;</div><div class="line">SubType.prototype.sayAge = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  alert(<span class="keyword">this</span>.age);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> instance1 = <span class="keyword">new</span> SubType(<span class="string">"lijingjing"</span>,<span class="number">22</span>);</div><div class="line">instance1.colors.push(<span class="string">"blue"</span>);</div><div class="line">alert(instance1.colors);<span class="comment">//white,black,red,blue</span></div><div class="line">instance1.sayName();<span class="comment">//lijingjing</span></div><div class="line">instance1.sayAge();<span class="comment">//22</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> instance2 = <span class="keyword">new</span> SubType(<span class="string">"Jessica"</span>,<span class="number">22</span>);</div><div class="line">alert(instance2.colors);<span class="comment">//white,black,red</span></div><div class="line">instance2.sayName();<span class="comment">//Jessica</span></div><div class="line">instance2.sayAge();<span class="comment">//22</span></div></pre></td></tr></table></figure>
<p> 组合继承避免了原型链和借用构造函数的缺陷，融合了它们的优点，是JS中最常用的继承模式。而且，instanceof和isProtptypeOf()也能够用于识别基于组合继承创建的对象。</p>
<h1 id="原型式继承"><a href="#原型式继承" class="headerlink" title="原型式继承"></a>原型式继承</h1><p> 借助原型可以基于已有的对象创建新对象，同时还不必因此创建自定义类型。道格拉斯-克罗克福德给出了如下函数：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//本质上讲object()对传入其中的对象执行了一次浅复制。</span></div><div class="line">  <span class="function"><span class="keyword">function</span> <span class="title">object</span>(<span class="params">o</span>)</span>&#123;</div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params"></span>)</span>&#123;&#125;</div><div class="line">    F.prototype = o;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> F();</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">var</span> person = &#123;</div><div class="line">    name : <span class="string">"lijingjing"</span>,</div><div class="line">    friends : [<span class="string">"HouXinran"</span>,<span class="string">"LvQiuyi"</span>,<span class="string">"JiaLinlin"</span>,<span class="string">"ZhangYan"</span>]</div><div class="line">  &#125;;</div><div class="line"></div><div class="line">  <span class="keyword">var</span> anotherPerson = object(person);</div><div class="line">  anotherPerson.name = <span class="string">"Jessica"</span>;</div><div class="line">  anotherPerson.friends.push(<span class="string">"HuJieqiong"</span>);</div><div class="line"></div><div class="line">  <span class="keyword">var</span> yetAnotherPerson = object(person);</div><div class="line">  yetAnotherPerson.name = <span class="string">"Seyi"</span>;</div><div class="line">  yetAnotherPerson.friends.push(<span class="string">"LiPeipei"</span>);</div><div class="line"></div><div class="line">  alert(person.friends);<span class="comment">//"HouXinran,LvQiuyi,JiaLinlin,ZhangYan,HuJieqiong,LiPeipei"</span></div></pre></td></tr></table></figure>
<p> 原型式继承要求必须有一个对象可以作为另一个对象的基础。上述的例子是实质上创建了person对象的两个副本。ECMAScript5通过新增Object.create()方法规范了原型式继承。这个方法接收两个参数，一个用作新对象原型的对象和（可选）一个为新对象定义额外属性的对象。在传入一个对象的情况下，Object.create()与object()方法的行为相同。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">var</span> person = &#123;</div><div class="line">  name : <span class="string">"lijingjing"</span>,</div><div class="line">  friends : [<span class="string">"HouXinran"</span>,<span class="string">"LvQiuyi"</span>,<span class="string">"JiaLinlin"</span>,<span class="string">"ZhangYan"</span>]</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">var</span> anotherPerson = <span class="built_in">Object</span>.create(person);</div><div class="line">anotherPerson.name = <span class="string">"Jessica"</span>;</div><div class="line">anotherPerson.friends.push(<span class="string">"HuJieqiong"</span>);</div><div class="line">alert(anotherPerson.name);</div><div class="line"></div><div class="line"><span class="keyword">var</span> yetAnotherPerson = <span class="built_in">Object</span>.create(person);</div><div class="line">yetAnotherPerson.name = <span class="string">"Seyi"</span>;</div><div class="line">yetAnotherPerson.friends.push(<span class="string">"LiPeipei"</span>);</div><div class="line">alert(yetAnotherPerson.name);</div><div class="line"></div><div class="line">alert(person.friends);<span class="comment">//"HouXinran,LvQiuyi,JiaLinlin,ZhangYan,HuJieqiong,LiPeipei"</span></div></pre></td></tr></table></figure>
<p> Object.create()方法的第二个参数与Object.defineProperties()方法的第二个参数格式相同：每个属性都是通过自己的描述符定义的，以这种方式制定的任何属性都会覆盖原型对象上的同名属性。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">var</span> person = &#123;</div><div class="line">  name : <span class="string">"lijingjing"</span>,</div><div class="line">  friends : [<span class="string">"HouXinran"</span>,<span class="string">"LvQiuyi"</span>,<span class="string">"JiaLinlin"</span>,<span class="string">"ZhangYan"</span>]<span class="comment">//引用类型</span></div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">var</span> anotherPerson = <span class="built_in">Object</span>.create(person,&#123;</div><div class="line">  name: &#123;</div><div class="line">    value:<span class="string">"Jessica"</span></div><div class="line">  &#125;</div><div class="line">&#125;);</div><div class="line"></div><div class="line"></div><div class="line">alert(anotherPerson.name);<span class="comment">//"Jessica"</span></div></pre></td></tr></table></figure>
<p><strong>使用原型式继承时要注意，包含引用类型值的属性始终都会共享相应的值，就像使用原型模式一样。</strong></p>

  </section>

  
  

<section class="post-comments">

    <div class="ds-thread" data-thread-key="blog/2016/05/17/JS继承/"></div>

    <script type="text/javascript">
      var duoshuoQuery = {short_name:"lijingjing"};
      (function() {
        var ds = document.createElement('script');
        ds.type = 'text/javascript';ds.async = true;
        ds.src = '//static.duoshuo.com/embed.js';
        ds.charset = 'UTF-8';
        (document.getElementsByTagName('head')[0] 
        || document.getElementsByTagName('body')[0]).appendChild(ds);
      })();
    </script> 

</section>


</article>

              <footer class="footer">

    <span class="footer__copyright">  &copy; 2017 阿菁菁菁菁菁 | 由<a href="https://hexo.io/">Hexo</a>强力驱动 | 主题<a href="https://github.com/someus/huno">Huno</a></span>

</footer>

          </div>
      </div>

    



    <!-- js files -->
    <script src="/js/jquery.min.js"></script>
    <script src="/js/main.js"></script>
    <script src="/js/scale.fix.js"></script>


    

    <script type="text/javascript" src="//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <script type="text/javascript"> 
        $(document).ready(function(){
            MathJax.Hub.Config({ 
                tex2jax: {inlineMath: [['[latex]','[/latex]'], ['\\(','\\)']]} 
            });
        });
    </script>


    

    <script src="/js/awesome-toc.min.js"></script>
    <script>
        $(document).ready(function(){
            $.awesome_toc({
                overlay: true,
                contentId: "post-content",
            });
        });
    </script>


    
    
    <!--kill ie6 -->
<!--[if IE 6]>
  <script src="//letskillie6.googlecode.com/svn/trunk/2/zh_CN.js"></script>
<![endif]-->

</body>
</html>
