<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="chrome=1">

    

    <title>
      阿菁菁菁菁菁 | 阿菁菁菁菁菁
    </title>

    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
    
      <meta name="author" content="阿菁菁菁菁菁">
    
    

    <meta name="description" content="响应式设计现状反模式为所有设备加载同样的内容为手机和桌面渲染加载完全一样的资源，加载同样的CSS文件，通过媒体查询给不同的分辨率设备提供不同的体验，加载同样的图片，通过缩放来解决不同分辨率下的显示需要。
会在HTTP拥堵时造成性能急剧下降，且考虑更大分辨率的显示设备如苹果饿Retina显示屏以及超高清电视时，这种解决方案不能很好地扩展显示。
加载额外的资源在手机端除了加载通用资源外，加载一些额外的">
<meta property="og:type" content="article">
<meta property="og:title" content="阿菁菁菁菁菁 | 阿菁菁菁菁菁">
<meta property="og:url" content="http://lijingjing.top/blog/2017/04/16/响应式Web设计性能优化/index.html">
<meta property="og:site_name" content="阿菁菁菁菁菁">
<meta property="og:description" content="响应式设计现状反模式为所有设备加载同样的内容为手机和桌面渲染加载完全一样的资源，加载同样的CSS文件，通过媒体查询给不同的分辨率设备提供不同的体验，加载同样的图片，通过缩放来解决不同分辨率下的显示需要。
会在HTTP拥堵时造成性能急剧下降，且考虑更大分辨率的显示设备如苹果饿Retina显示屏以及超高清电视时，这种解决方案不能很好地扩展显示。
加载额外的资源在手机端除了加载通用资源外，加载一些额外的">
<meta property="og:image" content="http://lijingjing.top/images/window-performance.jpeg">
<meta property="og:image" content="http://lijingjing.top/images/user-agent.jpeg">
<meta property="og:updated_time" content="2017-04-16T13:52:11.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="阿菁菁菁菁菁 | 阿菁菁菁菁菁">
<meta name="twitter:description" content="响应式设计现状反模式为所有设备加载同样的内容为手机和桌面渲染加载完全一样的资源，加载同样的CSS文件，通过媒体查询给不同的分辨率设备提供不同的体验，加载同样的图片，通过缩放来解决不同分辨率下的显示需要。
会在HTTP拥堵时造成性能急剧下降，且考虑更大分辨率的显示设备如苹果饿Retina显示屏以及超高清电视时，这种解决方案不能很好地扩展显示。
加载额外的资源在手机端除了加载通用资源外，加载一些额外的">
<meta name="twitter:image" content="http://lijingjing.top/images/window-performance.jpeg">

    
    
      <link rel="icon" type="image/x-icon" href="/images/avatar.png">
    
    <link rel="stylesheet" href="/css/uno.css">
    <link rel="stylesheet" href="/css/highlight.css">
    <link rel="stylesheet" href="/css/archive.css">
    <link rel="stylesheet" href="/css/china-social-icon.css">


</head>
<body>

    
      <header class="panel-cover panel-cover--collapsed">


  <div class="panel-main">


    <div class="panel-main__inner panel-inverted">
    <div class="panel-main__content">

        
        <a href="/" title="link to homepage for 阿菁菁菁菁菁"><img src="/images/avatar.png" width="100" alt="阿菁菁菁菁菁 logo" class="panel-cover__logo logo" /></a>
        

        <h1 class="panel-cover__title panel-title"><a href="/" title="link to homepage">阿菁菁菁菁菁</a></h1>
        <hr class="panel-cover__divider" />

        
        <h2 class="panel-cover__description panel-description-small">
          Change takes time.
        </h2>
        <hr class="panel-cover__divider panel-cover__divider--secondary" />
        

        <div class="navigation-wrapper">


        <nav class="cover-navigation cover-navigation--primary">
          <ul class="navigation">
            
              
              <li class="navigation__item"><a href="/blog" title="" class="blog-button">文章</a></li>
            
              
              <li class="navigation__item"><a href="/archive" title="" class="">归档</a></li>
            
              
              <li class="navigation__item"><a href="/about" title="" class="">关于我</a></li>
            

          </ul>
        </nav>

      <!-- ----------------------------
To add a new social icon simply duplicate one of the list items from below
and change the class in the <i> tag to match the desired social network
and then add your link to the <a>. Here is a full list of social network
classes that you can use:

    icon-social-500px
    icon-social-behance
    icon-social-delicious
    icon-social-designer-news
    icon-social-deviant-art
    icon-social-digg
    icon-social-dribbble
    icon-social-facebook
    icon-social-flickr
    icon-social-forrst
    icon-social-foursquare
    icon-social-github
    icon-social-google-plus
    icon-social-hi5
    icon-social-instagram
    icon-social-lastfm
    icon-social-linkedin
    icon-social-medium
    icon-social-myspace
    icon-social-path
    icon-social-pinterest
    icon-social-rdio
    icon-social-reddit
    icon-social-skype
    icon-social-spotify
    icon-social-stack-overflow
    icon-social-steam
    icon-social-stumbleupon
    icon-social-treehouse
    icon-social-tumblr
    icon-social-twitter
    icon-social-vimeo
    icon-social-xbox
    icon-social-yelp
    icon-social-youtube
    icon-social-zerply
    icon-mail

-------------------------------->

<!-- add social info here -->



<nav class="cover-navigation navigation--social">
  <ul class="navigation">

    
      <!-- Github -->
      <li class="navigation__item">
        <a href="https://github.com/BabysbreathJJ" title="阿菁 on GitHub">
          <i class='icon icon-social-github'></i>
          <span class="label">GitHub</span>
        </a>
      </li>
      <li class="navigation__item">
        <a href="mailto:lijingjing1008@gmail.com" title="阿菁‘s e-mail">
          <i class='icon icon-mail'></i>
          <span class="label">Mail</span>
        </a>
      </li>
      <li class="navigation__item">
        <a href="http://weibo.com/2797656002/profile" title="阿菁 on Weibo">
          <i class='icon cs-icon-weibo'></i>
          <span class="label">Weibo</span>
        </a>
      </li>
    

    <!-- China social icon -->
    <!--

      <li class="navigation__item">
        <a href="" title="">
          <i class='icon cs-icon-douban'></i>
          <span class="label">Douban</span>
        </a>
      </li>



    -->



  </ul>
</nav>




      <nav class="cover-navigation cover-navigation--primary">
        <h2 class="panel-cover__description panel-description-small">
        友情链接
        </h2>
        <ul class="navigation">
          
            <li class="friend__item"><a target="_blank" href="http://gaocegege.com/Blog" title="" class="">高策</a></li>
          
            <li class="friend__item"><a target="_blank" href="http://lizheming.top/" title="" class="">黎哲明</a></li>
          
            <li class="friend__item"><a target="_blank" href="http://peipeili.cn/" title="" class="">李佩佩</a></li>
          

        </ul>
      </nav>


        </div>

      </div>

    </div>

    <div class="panel-cover--overlay"></div>
  </div>
</header>

      <span class="mobile btn-mobile-menu">
          <i class="icon icon-list btn-mobile-menu__icon"></i>
          <i class="icon icon-x-circle btn-mobile-close__icon hidden"></i>
      </span>
      <div class="content-wrapper">
          <div class="content-wrapper__inner entry">
              

<article class="post-container post-container--single">

  <header class="post-header">

    <h1 class="post-title">响应式Web设计性能优化</h1>

    

    <div class="post-meta">
      <time datetime="2017-04-16" class="post-meta__date date">2017-04-16</time>

      <span class="post-meta__tags tags">
          
            <font class="categories">
            &#8226; 分类:
            <a class="categories-link" href="/categories/读书笔记/">读书笔记</a>
            </font>
          

          
             &#8226; 标签:
            <font class="tags">
              <a class="tags-link" href="/tags/性能优化/">性能优化</a>
            </font>
          
        </span>
     </div>
    

  </header>

  <section id="post-content" class="article-content post">
    <h3 id="响应式设计现状"><a href="#响应式设计现状" class="headerlink" title="响应式设计现状"></a>响应式设计现状</h3><h4 id="反模式"><a href="#反模式" class="headerlink" title="反模式"></a>反模式</h4><h5 id="为所有设备加载同样的内容"><a href="#为所有设备加载同样的内容" class="headerlink" title="为所有设备加载同样的内容"></a>为所有设备加载同样的内容</h5><p>为手机和桌面渲染加载完全一样的资源，加载同样的CSS文件，通过媒体查询给不同的分辨率设备提供不同的体验，加载同样的图片，通过缩放来解决不同分辨率下的显示需要。</p>
<p>会在HTTP拥堵时造成性能急剧下降，且考虑更大分辨率的显示设备如苹果饿Retina显示屏以及超高清电视时，这种解决方案不能很好地扩展显示。</p>
<h5 id="加载额外的资源"><a href="#加载额外的资源" class="headerlink" title="加载额外的资源"></a>加载额外的资源</h5><p>在手机端除了加载通用资源外，加载一些额外的CSS以及sprite文件等其他额外的资源。造成手机体验中会发送比桌面体验下发送更多的HTTP请求。</p>
<h5 id="加载双倍的图片"><a href="#加载双倍的图片" class="headerlink" title="加载双倍的图片"></a>加载双倍的图片</h5><p>有些站点会为手机版本加载另外一组图片，如此一来，图片文件的大小就是桌面图片的两倍了。</p>
<p>以上问题有几个共同的哲学思想：</p>
<ol>
<li>它们明显都是着眼于桌面版本，并以此作为基础，在其上修改或新增元素，而不是从最小版本往上开发。</li>
<li>它们都没有利用各个平台的优势，也没有意识到各个平台的限制。</li>
<li>它们都试图仅从客户端来解决问题。</li>
</ol>
<h4 id="模式"><a href="#模式" class="headerlink" title="模式"></a>模式</h4><h5 id="加载适合相应设备的资源"><a href="#加载适合相应设备的资源" class="headerlink" title="加载适合相应设备的资源"></a>加载适合相应设备的资源</h5><p>针对手机端加载相比桌面端一半大小的图片，使用设备独有的sprite图和CSS，并不是在桌面程序的基础上为其他设备增加其他资源。</p>
<h5 id="从后端提供专有的体验"><a href="#从后端提供专有的体验" class="headerlink" title="从后端提供专有的体验"></a>从后端提供专有的体验</h5><p>针对不同的设备提供完全不同的专有体验。有些站点提供了独立的“m.”网站，另外一些网站展示的是从服务端传输过来的基于设备独有布局和功能的页面。这种解决方案我们称之为<strong>RESS（响应式设计+服务端组件）</strong>。</p>
<h5 id="前端延迟加载的专有体验"><a href="#前端延迟加载的专有体验" class="headerlink" title="前端延迟加载的专有体验"></a>前端延迟加载的专有体验</h5><p>有些站点不仅对图片进行延迟加载，而且对整个内容模块也进行延迟加载，包括上方和下方的折叠部分。通过这种方式，可以有效地避免为每个断点加载内容，智能地加载那些需要的内容，从而适应客户端性能，达到最佳体验。但是是否延迟加载的决定权在客户端，问不是在服务端。</p>
<h3 id="初识Web应用性能"><a href="#初识Web应用性能" class="headerlink" title="初识Web应用性能"></a>初识Web应用性能</h3><h4 id="性能度量基础"><a href="#性能度量基础" class="headerlink" title="性能度量基础"></a>性能度量基础</h4><p>当提及网站和Web应用的性能的时候，我们说的要么是Web性能，要么是运行时性能。我们将Web性能定义为，一个终端用户从请求一段内容开始到这段内容显示在用户设备上这段时间的度量值。将运行时性能定义为，应用在运行时对用户输入响应能力的一个标示。</p>
<p>将性能指标类型分为以下几类：</p>
<ol>
<li>定量指标： 可以通过实验进行度量的一种目标（如某个东西的数量）</li>
<li>定性指标： 不能通过实验度量的一种目标（如某个东西的质量）</li>
<li>先行指标： 用于预测结果</li>
<li>输入指标：用户度量某个过程中消耗的资源</li>
</ol>
<h5 id="什么是Web性能"><a href="#什么是Web性能" class="headerlink" title="什么是Web性能"></a>什么是Web性能</h5><p>想想每次浏览网页的过程。打开浏览器，键入URL，然后等待网页加载。从键入URL后按下回车键（或是从书签列表中点击某个书签，亦或是点击页面中的某个链接），到页面渲染，这之间消耗的时间就是所浏览页面的Web性能。若站点运行正常，这个时间甚至不应该被人感受到。</p>
<p>Web性能的定量指标数不胜数：</p>
<ol>
<li>页面加载时间</li>
<li>页面文件大小</li>
<li>HTTP请求数</li>
<li>页面渲染时间</li>
</ol>
<p><strong>页面是如何到达浏览器并展现给用户的？</strong></p>
<ol>
<li>当通过浏览器请求一个Web页面，浏览器会创建一个线程去处理这个请求，随后开始远程DNS查找，远程DNS服务器将你输入的URL对应的IP地址返回给浏览器。</li>
<li>接着，浏览器通过与远程Web服务端的三次握手来建立一个TCP/IP连接。这个握手由浏览器与远程服务端之间的SYN、SYN-ACK以及ACK消息组成。</li>
<li>TCP连接建立之后，浏览器同构连接发送一个HTTP GET请求到Web服务端。Web服务端找到请求的资源，然后再HTTP响应中将其返回，状态200表示响应正常。如果服务端找不到请求的资源或是解析资源的过程中出错，亦或是资源被重定向，HTTP响应状态也会反映出这些情况。</li>
<li>当浏览器收到页面的HTML后，就开始解析并渲染页面内容。</li>
<li>浏览器用其渲染引擎来解析和渲染内容。</li>
</ol>
<p>一些常见的状态码：</p>
<ul>
<li>200 表示服务端成功响应</li>
<li>301 表示永久重定向</li>
<li>302 表示临时重定向</li>
<li>401 表示未授权</li>
<li>403 表示请求被拒绝</li>
<li>404 表示服务端找不到请求的资源</li>
<li>500 表示处理请求时出错</li>
<li>503 表示服务不可用</li>
<li>504 表示网关超时</li>
</ul>
<p>加载一个HTML页面不知需要一次这个过程，浏览器还要为页面链接的每个资源发起一个HTTP请求-所有的图片，链接的CSS和JS文件以及其他类型的外部资源（<strong>只要后续的HTTP请求链接的是相同的源，浏览器就可以重用相应的TCP链接</strong>）。</p>
<p>现有的浏览器架构由几个关联的模块组成：<br><strong>UI层</strong><br>这一层为浏览器绘制界面。有些元素，如地址栏。刷新按钮以及用户界面上的（UI）的其他元素是浏览器自身的。<br><strong>网络层</strong><br>该层处理网络连接，承担的职责有建立TCP连接以及处理HTTP的往返过程。网络层处理内容下载，然后将内容传递给渲染引擎。<br><strong>渲染引擎</strong><br>渲染引擎负责将内容绘制到显示器上。浏览器制造商会将他们的渲染引擎以及JS引擎打上商标并对外授权。最流行的渲染引擎是webkit/chrome(Blink)/Safari/Opera以及其他浏览器都用到了webkit。当渲染引擎遇到了JS，会将其传递给JS解释器。<br><strong>JS引擎</strong><br>JS引擎会解析并执行JS。如果渲染引擎，浏览器制造商给他们的JS打上商标并授权，一个流行的JS引擎是V8，Node.js就是用它作为引擎的。</p>
<p><strong>用户在浏览器键入一个URL后发生了什么？</strong></p>
<ul>
<li>UI层将这个请求传递给网络层，网络层随后建立连接，然后下载初始页面。当含有HTML块的数据包到达，就被传递给渲染引擎。渲染引擎将HTML组装成原始文本，然后对文本中的字符开始进行词法分析或解析。这些字符会与一个规则集相比较，我们在HTML文档中指定的文档类型定义（DTD），然后转换成基于规则集的符号。DTD规定了一系列标签，这些标签组成了我们将要使用的语言版本。这些标签就是由一些被分割成有意义片段的字符组成。</li>
<li>渲染引擎拿到这些符号后，将它们转换成文档对象类型（DOM）元素，DOM是页面元素的内存表现形式，也是JS用于访问页面元素的API。DOM元素被布局成一棵渲染树，渲染引擎会迭代该树。首次迭代中，渲染引擎会布局好DOM元素的位置，下一次迭代就将这些元素绘制到屏幕上。</li>
<li>如果渲染层在解析和符号化过程中发现了<code>&lt;script&gt;</code>标签，就会暂停下来然后评估接下来要进行的处理。如果<code>&lt;script&gt;</code>标签指向一个外部的JS文件，解析过程暂停，随后网络层接入，下载JS文件，然后初始化JS引擎解析，执行该文件。如果<code>&lt;script&gt;</code>标签包含的是内嵌的JS，渲染引擎暂停，JS引擎被初始化，内嵌的JS会被解析与执行。执行完成后，之前暂停的渲染过程会恢复运行。</li>
</ul>
<h5 id="性能指标"><a href="#性能指标" class="headerlink" title="性能指标"></a>性能指标</h5><ul>
<li>HTTP请求数<br>当浏览器获取HTML页面时会创建一个HTTP请求，还会创建更多的HTTP请求来获取页面中链接的每个资源。根据网络延迟情况，每个HTTP请求都会使总的页面加载时间增加20~200毫秒（如果考虑可以并行加载资源的浏览器，这个数字会有所不同）。如果只是少量的资源，这些额外的加载时间可以忽略不计，但如果是100个或更多的HTTP请求，将会显著增大总体的Web性能的延迟。</li>
</ul>
<p>减少页面需要的HTTP请求数，开发者可以有很多办法，比如将不同的CSS或JS文件合并成单个文件，将常用的图片合并成单个的称之为sprite的图片文件。</p>
<ul>
<li><p>页面加载<br>影响Web性能的因素之一是页面的总文件大小。总负载包括组成该页面的HTML、CSS以及JS累计的文件大小。还包括所有的图片、cookie以及其他潜在页面中的媒体。</p>
</li>
<li><p>页面加载时间<br>HTTP请求数以及总的页面负载本身只是输入，但Web性能方面需要关注的真正KPI是页面加载时间。</p>
</li>
</ul>
<p>压面加载时间是最明显的性能指标，也最容易被量化。简而言之，它是从浏览器下载并渲染所有页面内容的时间。以前度量的是从页面请求到页面（窗口加载，window onload）事件之间消耗的时间。最近，由于开发者越来越喜欢在页面完成加载之前就提供好的用户体验，这样度量结束的时间点就会移动，甚至完全改变。</p>
<p>特别是，在一些用例中，window.onload事件出发后，可以动态加载内容，比如，如果内容是延迟加载的，就会出现这种情况，并且有一些用例，在window.onload事件触发之前页面就是可用的，看起来也是完整的（先加载内容，然后再加载广告）。这些用例会降低依靠window.onload事件追踪特定页面加载时间的有效性。</p>
<h4 id="Web运行时性能"><a href="#Web运行时性能" class="headerlink" title="Web运行时性能"></a>Web运行时性能</h4><p>Web性能跟踪的是内容传递到用户的耗时。Web运行时性能，跟踪的是用户与应用交互时应用的行为。</p>
<p>对于传统的编译类型的应用，运行时性能是有关内存管理、垃圾回收以及线程等各个方面的。这是因为变一类的应用运行在内核之上，直接使用系统资源。</p>
<p>在客户端运行Web应用与运行编译类应用是大不相同的。这是因为Web应用运行在沙盒中，即运行在浏览器中。当它们运行时，用的是浏览器的资源。而浏览器的资源是运行在它事先从内核中分配的内存资源中的。所以，当我们提到Web运行时性能，我们实际上说的是应用是怎样在客户端的浏览器运行，以及让浏览器在虚拟内存中其自身的内存里执行。</p>
<p>我们需要考虑到的影响Web运行时性能的因素：</p>
<ul>
<li><p>内存管理与垃圾回收<br>首先要看的是，我们有没有因为太多无用的对象以及创建更多对象时仍保留这些无用对象而导致浏览器的内存分配被阻塞。<br>随着时间的推移，我们是否有什么机制限制JS中的对象创建，或应用用的越多越久时，内存消耗是否也越多，是否存在内存泄露？<br>回收无用对象可能会导致浏览器在渲染或播放动画的时候暂停，容易在用户体验上出现锯齿现象。我们可以通过减少创建的对象数量以及可能重用已有对象来将垃圾回收次数降到最少。</p>
</li>
<li><p>布局<br>我们更新DOM的时候是否引发了页面重绘？这一般是由于大范围的样式变化，需要渲染引擎重新计算页面元素的大小和位置。</p>
</li>
<li><p>高代价的绘制<br>当用户滚动页面时，我们有没有因为绘制一些区域而加重浏览器的负担？动画效果或是更新除了位置、缩放、旋转或透明度之外的任意元素属性，都将引起渲染引擎重绘对应元素并消耗时间。位置、缩放、旋转以及透明度是渲染引擎最后配置的元素属性，所以，更新这些属性只需极小的开销。<br>如果我们在宽度、高度、背景或者其他属性上使用动画，渲染引擎就需要重新考虑页面的布局并且重绘那个元素，这就会在渲染和动画过程中消耗更多的时间。更糟的是，如果我们引起了父元素的重绘，渲染引擎就需要重绘所有的子元素，严重影响运行时性能。</p>
</li>
<li><p>同步调用</p>
</li>
<li><p>CPU占用率<br>我们要查看的Web运行时性能指标是每秒的帧数和CPU的占用率。</p>
</li>
</ul>
<p><strong>每秒帧数（FPS）</strong>：是系统重绘屏幕的速率。人类感觉动作平滑、逼真的理想帧率是60FPS。 FPS还是浏览器的一个重要性能指标，因为其反映出了动画运行以及窗口滚动的平滑程度。滚动时出现锯齿（卡顿）已经是Web性能问题的一个明显标志。<br><strong>内存分析</strong>：内存分析是监控我们应用所用到的内存消耗模式的一种方法，这对检测内存泄露与不会销毁的对象创建非常有用——JS中，当我们用程序为DOM对象指定事件处理器，而后又忘了将事件处理器移除时尤为常见。内存分析对优化内存占用也很有用。</p>
<p><img src="/images/window-performance.jpeg" alt="window.performance"></p>
<h3 id="千里之行始于计划"><a href="#千里之行始于计划" class="headerlink" title="千里之行始于计划"></a>千里之行始于计划</h3><h3 id="响应式服务端实现"><a href="#响应式服务端实现" class="headerlink" title="响应式服务端实现"></a>响应式服务端实现</h3><h4 id="Web栈"><a href="#Web栈" class="headerlink" title="Web栈"></a>Web栈</h4><p>Web栈是一系列栈的集合。<br><strong>网络栈</strong><br>网络栈是由不同网络系统相互通信的一系列协议的统称，它由下面一些层构成：</p>
<ol>
<li><strong>数据链路层</strong>： 数据链路层对应的是硬件连接到网络的标准方式。对我们而言，通常是以太网的形式，具体是支持IEEE 802.3标准的物理互联设备；或者也可以通过WiFi，即支持802.11标准的无线互联设备。</li>
<li><strong>网络层</strong>：网络层对应的是网络中不同网络节点之间相互识别和通信的标准，具体是IP协议或者互联网协议。它是通过IP地址在网络中识别网络节点，并且在主机之间通过数据包的形式传递数据。</li>
<li><strong>传输层</strong>：传输层通常相当于TCP，全称是Transmission Control Protocol，也就是传输控制协议。TCP是用来在主机之间建立链接的协议。IP协议负责将数据以数据包的形式进行传输，而TCP将数据包分成多个段，并且为每个段创建含有目标IP地址的header，重新组装并且对接收到的这些网络传输数据进行校验。</li>
<li><strong>应用层</strong>：应用层是这一系列协议的最上层，它对应的是像HTTP这样的协议，HTTP也成为超文本传输协议。HTTP的标准是IETF RFC2616。HTTP是一种Web语言，主要由Request/Response两个动作组成。</li>
</ol>
<p><strong>HTTP请求</strong><br>一个HTTP请求由两部分组成：请求正文和一系列请求header。其中，请求正文包括请求的HTTP方法或者动作，以及请求远程资源的URI。简单来说，它表明了当前要执行的动作（获取文件，发送文件或者获取一个文件的信息）以及这个动作在哪执行（文件或者资源的地址路径），下面是一些在HTTP1.1中支持的方法：</p>
<ol>
<li>OPTIONS：服务器支持的HTTP请求方法的功能选项。</li>
<li>GET：当你请求远程资源时，如果你在HTTP header中指定了If-Modified-Since/If-Unmodified-Since/If-Match/If-None-Match或者If-Range里的一项，那么它就变成一个有条件的GET了。因为在这个时候，服务器只返回符合这些请求条件的资源。一般来说，如果你想控制获取资源的方式，是获取最新的资源还是使用当前缓存的时候，就可以使用这种有条件的GET。</li>
<li>HEAD：只请求远程资源的HTTP header，它主要是用来检查最后更改的日期或者确认一个URI是否可用。</li>
<li>POST：请求服务器对一个资源进行更新或者修改。</li>
<li>PUT：请求服务器创建一个新的资源。</li>
<li>DELETE：请求服务器删除一个资源。</li>
</ol>
<p>一些请求header：</p>
<ol>
<li>Host：在URI中指定的域名名称</li>
<li>If-Modified-Since：这个参数在Request header中传给服务器，指示服务器只返回在指定的时间里有过更新的资源。如果资源已经更新过了，那么服务器就返回这个资源和200状态码。如果没有，那么服务器返回304状态码。</li>
<li>User-Agent：这个参数标识客户端的具体特征信息，</li>
</ol>
<p><strong>HTTP响应</strong><br>当服务器接收并处理了一个请求以后，它将会返回客户端一个响应信息，和HTTP请求一样，HTTP响应也由两个部分组成：状态行和响应header的属性。</p>
<p>状态行中有协议版本号（HTTP 1.1），状态码和描述请求状态的文本短语，状态码由三位数字组成，并且把响应分成了五个层次类别。状态码的第一位数字表示它的类别。具体类别如下所示：<br>1xx:信息 —— 请求已收到，正在处理中。<br>2xx:成功 —— 请求已经成功接收、解析并执行了。<br>3xx:重定向 —— 需要进一步的跳转和更多的操作来完成当前请求。<br>4xx:客户端错误 —— 请求包含了语法错误，不能被执行。<br>5xx:服务端错误 —— 服务端在处理一个有效的请求时失败。</p>
<p>响应header里的属性值和请求header里的属性值很像，服务端通过指定这一系列的键值对表明当前响应的具体信息。下面是一些常用的响应header：</p>
<ol>
<li>Age: 标识请求的资源从创建或更新时到请求发生时的大概时间。</li>
<li>ETag: 列出服务器为这个资源分配的唯一实体标记符，这个参数在一些需要额外匹配验证的时候非常有用。</li>
<li>Vary: 这个参数标明当前请求的哪个请求头用来表示该请求是否可以被缓存。这个参数很重要，因为它让我们可以将User Agent头信息作为一个请求是否可以被缓存的决定因素之一。</li>
</ol>
<p><strong>Web应用栈</strong><br>绝大部分情况下，Web应用是基于客户端-服务器模式的，也可以将其看成是一个分布式计算方式。用一句话来总结就是，客户端向服务器端请求数据，服务端处理请求和响应。通常情况下，为了可扩展性，这些服务器分布在整个网络中。</p>
<p>假设浏览器就是客户端，Web服务器就是server。当我们说Web服务器时，指的是像Apache和微软的IIS这样的应用软件，或者是运行这些软件的硬件。</p>
<p>这些Web服务器监听某些特定的端口——表示应用端口的数字，也就是HTTP请求的端口。通常情况下，HTTP请求的是80端口，HTTPS请求的是403端口。当Web服务器接收到这个请求的时候，它就会把这个请求发送给对应的资源。</p>
<p>类似于Ruby或者PHP，或者像HTML页面这样的静态内容，这些资源可以再服务端以代码的形式进行评估和解析。无论哪种方式，这个被发送的请求都会获得服务端的响应。</p>
<p>如果服务端响应的正文是HTML文件，HTML将在客户端设备上进行解析和渲染，如果内容中包含了任何JS文件，它们也会被客户端设备解释运行。</p>
<h4 id="服务端响应"><a href="#服务端响应" class="headerlink" title="服务端响应"></a>服务端响应</h4><p>在整个栈中，第一件事应该做的是判断出客户端的相关特性。现在，响应式设计是客户端获取服务端发送HTTP响应后，在客户端根据获取到的相应的客户端特性，然后根据这些特性对响应的内容进行接收、解析和渲染等一系列操作。<strong>在服务器端根据客户端特性发送针对设备专有的代码而不是全部的代码。</strong></p>
<p><strong>检查User Agent</strong><br>在发送请求时，请求的header里会自动添加user-agent属性<br><img src="/images/user-agent.jpeg" alt="user-agent"></p>
<p><strong>Wurfl</strong><br>Wurfl全称是无限通用资源文件（Wireless Universal Resource File）。<br>Wurfl Cloud —— 提供API访问设备数据库；<br>Wrufl Onsite —— 本地安装的设备数据库；<br>Wrufl Infuze —— 在服务端通过环境变量保证Wurfl数据库的可用性。</p>
<p>最好的解决方案是Wrufl Infuze，因为当查询设备数据时没有产生文件I/O和传输延迟的额外消耗。<br>然而门槛最低的解决方案是WurflCloud，因为它不需要内部主机，不需要安装基础设施，甚至还有免费的选项。</p>
<h4 id="缓存的影响"><a href="#缓存的影响" class="headerlink" title="缓存的影响"></a>缓存的影响</h4><p>在开发大型网站时，我们常常会依赖于缓存减轻我们的服务器压力。当我们把响应式移到服务端但又缓存了响应时，问题便出现了，无论从客户端传来什么样的User Agent信息，我们将只看到当前缓存的版本而无法看到最新的响应。</p>
<p>为了解决这个问题，我们可以在发送响应的时候使用Vary这个HTTP响应header参数。当有请求进来的时候，服务端会基于User Agent的值做一些判断，然后决定哪些响应需要缓存起来。</p>
<p><strong>大多数的CDN在使用Vary Response header的时候都不会缓存，如果你的CDN也会这样，你需要针对这种情况有相应的替代方案。可能需要使用Edge Side Includes将User Agent的检查逻辑移到CDN的边缘层。</strong></p>
<h4 id="Edge-Side-Include"><a href="#Edge-Side-Include" class="headerlink" title="Edge Side Include"></a>Edge Side Include</h4><p>CDN</p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>如何尽快从最早的请求中获取客户端设备功能？最重要的是如何尽快对响应进行处理？<br>为了回答这个文艺，我们重点对请求的HTTP请求中的UserAgent进行检测，甚至使用了第三方的设备检测服务，比如Wurlf。<br>不过这个解决方案的一个潜在的风险就是如何处理缓存内容。一个解决方式就是使用响应header中的Vary参数。缓存服务器通过UserAgent决定哪一种响应需要缓存起来。另外一种方式就是通过使用ESI，把我们的设备或者能力检测逻辑从我们的服务器移到CDN edge服务器上。</p>
<p>不管哪一种解决方案，只要我们将响应式的处理在服务端解决，避免客户端加载所有的响应式相关代码，避免提供两份相同内容或者无效内容的反模式，就可以减少向客户端传送的负载，取而代之的是一种更精简、更合理的响应方式，所以这种实现方式更好。</p>
<h3 id="响应式前端实现"><a href="#响应式前端实现" class="headerlink" title="响应式前端实现"></a>响应式前端实现</h3><p>上一章展示了如何将响应式规范从客户端迁移到服务端。这个过程包括两个方面：第一，从服务端加载符合设备特性的内容和提供专有的体验；第二，避免加载所有设备内容的反模式。这样做可以有效降低页面的父子啊，减少客户端设备渲染页面的整体时间。</p>
<p>如果基础设施、商业模式或者团队技术深度不能够有效地支持服务端的解决方案，那该如何做呢？<br>可以从单纯的客户端解决方案中获得相近的性能提升。</p>
<h4 id="图片操作"><a href="#图片操作" class="headerlink" title="图片操作"></a>图片操作</h4><p>调查表明，对页面负载影响最大的就是页面上的图片。所以，在客户端提高响应式性能，优化移动设备客户端的图片传输非常重要。</p>
<h5 id="SRCSET属性"><a href="#SRCSET属性" class="headerlink" title="SRCSET属性"></a>SRCSET属性</h5><p>通过srcset属性，<img>标签可以为不同客户端设备的不同像素比指定不同的图片。</p>
<p><strong>设备像素比</strong><br>设备像素比是指物理像素和设备独立像素之间的比例。典型的例子就是iPad Retina屏，包含更多信息的像素或者设备独立像素，实际上它的真是像素宽度是2048。所以iPad Retina屏显示的设备像素比的计算公式为：<br>【设备独立像素】/【物理像素】，即 2048/1024 = 2;</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"1x.jpg"</span> <span class="attr">srcset</span>=<span class="string">"2x.jpg 2x"</span>&gt;</span></div></pre></td></tr></table></figure>
<p>上面的代码中，<img>标签有个默认的图片1x.jpg，这主要是为了向后兼容，防止浏览器不支持srcset属性。如果设备像素比是2，那么我们设置的srcset属性和它指定的图片就会起作用。</p>
<p>浏览器使用的设备像素比的值，可以使用window.devicePixelRatio属性来获取。</p>
<p>使用srcset的缺点：<br>必须指定可能需要的所有不同的图片，这会额外增加发送的字节数，从而增加额外的负载。但是可以把像素比的映射关系放到服务端来完成来针对这个问题进行优化。</p>
<p>使用srcset的优点：<br>除了可以让你指定设备的特定使用的多个图像，而无需加载多余的图像之外，还有就是现代的浏览器已经开始支持这个属性了。</p>
<h5 id="picture属性"><a href="#picture属性" class="headerlink" title="picture属性"></a>picture属性</h5><p>处理响应式图片的另外一个可选性技术是使用<picture>元素。<picture>元素是HTML5中新增的一个元素。从概念上讲，它是一个容器元素，包含了多种不同的源标签，基于不同的视口宽度像素密度指定不同的图片，它也可以容纳一个img标签进行优雅降级。</picture></picture></p>
<p><source>属性支持media属性，使用它可以指明要关注的媒体类型和目标CSS属性。source元素还有src属性，使用这个属性来指明针对目标的媒体类型和CSS属性所随影要下载的图片。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">picture</span>&gt;</span></div><div class="line">	<span class="tag">&lt;<span class="name">source</span> <span class="attr">media</span> = <span class="string">"(min-width: 640px, min-device-pixel-ratio:2)"</span> <span class="attr">src</span>=<span class="string">"hi-res_small.jpg"</span>&gt;</span></div><div class="line">	<span class="tag">&lt;<span class="name">source</span> <span class="attr">media</span> = <span class="string">"(min-width: 2048px, min-device-pixel-ratio:2)"</span> <span class="attr">src</span>=<span class="string">"hi-res_large.jpg"</span>&gt;</span></div><div class="line">	<span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"1x.png"</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">picture</span>&gt;</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">&lt;!--&lt;picture&gt;同样可以支持srcset属性--&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">picture</span>&gt;</span></div><div class="line">	<span class="tag">&lt;<span class="name">source</span> <span class="attr">srcset</span>=<span class="string">"big.jpg 1x, big-2x.jpg 2x, big-3x.jpg 3x"</span> <span class="attr">type</span>=<span class="string">"image/jpeg"</span> <span class="attr">media</span> = <span class="string">"(min-width: 40em)"</span>&gt;</span></div><div class="line">	<span class="tag">&lt;<span class="name">source</span> <span class="attr">srcset</span>=<span class="string">"big.jpg 1x, big-2x.jpg 2x, big-3x.jpg 3x"</span> <span class="attr">type</span>=<span class="string">"image/jpeg"</span>&gt;</span></div><div class="line">	<span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"1x.png"</span> <span class="attr">alt</span>=<span class="string">"fancy pants"</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">picture</span>&gt;</span></div></pre></td></tr></table></figure>
<h5 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h5><p>不管是srcset属性还是<picture>元素，它们都是我们可能用到的解决方案。如果从性能的角度来比较两种方案，我们会发现，在理论上，它们只会下载最适合客户端设备特性的资源，但是<picture>元素很明显比使用了srcset属性的<img>标签更冗长。</picture></picture></p>
<p>如果我们想对它们使用的字节数进行量化比较，以上述代码为例，使用srcset属性的<img>标签使用了95个字节，而<picture>元素使用了231个字节，srcset属性的方式比<picture>元素的方式节约了近60%的字节数。所以当页面中<img>标签很多时，这种差距是不能忽视的。</picture></picture></p>
<h4 id="延迟加载"><a href="#延迟加载" class="headerlink" title="延迟加载"></a>延迟加载</h4><p>如何在客户端使用某一个策略——在页面渲染时只加载适用于该设备的资源？<br>答案是使用延迟加载。</p>
<p>使用延迟加载，它会在真正需要的时候才会去加载相关的内容。一个延迟加载的例子就是无限滚动：只有真正需要显示的内容才会被显示到“显著位置”（设备中展示在屏幕范围内的内容），当用户向下滑动后，更多的内容才会被下载并渲染显示到屏幕上。<br>因此，我们第一次需要加载HTML语义结构的股价，然后根据客户端的特性，延迟加载相应的CSS和JS。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">&lt;script&gt;</div><div class="line">	<span class="built_in">window</span>.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">		<span class="keyword">var</span> client = determineClient();</div><div class="line">		<span class="keyword">var</span> section = [<span class="string">"head"</span>,<span class="string">"body"</span>,<span class="string">"client"</span>];</div><div class="line">		<span class="keyword">for</span>(<span class="keyword">var</span> n = <span class="number">0</span>; n &lt; sections.length; n++) &#123;</div><div class="line">			loadSection(n,client);</div><div class="line">		&#125;</div><div class="line">		</div><div class="line">		<span class="function"><span class="keyword">function</span> <span class="title">loadSection</span>(<span class="params">n,client</span>) </span>&#123;</div><div class="line">			<span class="keyword">var</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</div><div class="line">			xhr.open(<span class="string">"get"</span>,client.sectionURLs[section],<span class="literal">true</span>);</div><div class="line">			xhr.send();</div><div class="line">			xhr.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">				<span class="built_in">document</span>.getElementById(xhr.section).innerHTML = xhr.responseText;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		</div><div class="line">		<span class="function"><span class="keyword">function</span> <span class="title">determineClient</span>(<span class="params"></span>)</span>&#123;</div><div class="line">		 ...</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&lt;<span class="regexp">/script&gt;</span></div></pre></td></tr></table></figure>
<p><strong>浏览器默认的延迟加载项</strong><br>浏览器将自动延迟加载CSS背景图。如果display属性被设置成none,那么背景图片只有当display属性设置成visible的时候才会被加载。这是页面中延迟加载默认图片的另外一种使用策略。</p>

  </section>

  
  

<section class="post-comments">

    <div class="ds-thread" data-thread-key="blog/2017/04/16/响应式Web设计性能优化/"></div>

    <script type="text/javascript">
      var duoshuoQuery = {short_name:"lijingjing"};
      (function() {
        var ds = document.createElement('script');
        ds.type = 'text/javascript';ds.async = true;
        ds.src = '//static.duoshuo.com/embed.js';
        ds.charset = 'UTF-8';
        (document.getElementsByTagName('head')[0] 
        || document.getElementsByTagName('body')[0]).appendChild(ds);
      })();
    </script> 

</section>


</article>

              <footer class="footer">

    <span class="footer__copyright">  &copy; 2017 阿菁菁菁菁菁 | 由<a href="https://hexo.io/">Hexo</a>强力驱动 | 主题<a href="https://github.com/someus/huno">Huno</a></span>

</footer>

          </div>
      </div>

    



    <!-- js files -->
    <script src="/js/jquery.min.js"></script>
    <script src="/js/main.js"></script>
    <script src="/js/scale.fix.js"></script>


    

    <script type="text/javascript" src="//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <script type="text/javascript"> 
        $(document).ready(function(){
            MathJax.Hub.Config({ 
                tex2jax: {inlineMath: [['[latex]','[/latex]'], ['\\(','\\)']]} 
            });
        });
    </script>


    

    <script src="/js/awesome-toc.min.js"></script>
    <script>
        $(document).ready(function(){
            $.awesome_toc({
                overlay: true,
                contentId: "post-content",
            });
        });
    </script>


    
    
    <!--kill ie6 -->
<!--[if IE 6]>
  <script src="//letskillie6.googlecode.com/svn/trunk/2/zh_CN.js"></script>
<![endif]-->

</body>
</html>
